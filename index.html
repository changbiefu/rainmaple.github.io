    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js" defer></script>

    <!-- Font Awesome 7 -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />

    <!-- Flaticon UIcons：动态图标需要 RR + SR 两套 -->
    <link
      rel="stylesheet"
      href="https://cdn-uicons.flaticon.com/3.0.0/uicons-regular-rounded/css/uicons-regular-rounded.css"
    />
    <!-- rr -->
    <link
      rel="stylesheet"
      href="https://cdn-uicons.flaticon.com/3.0.0/uicons-solid-rounded/css/uicons-solid-rounded.css"
    />
    <!-- sr（底栏“动态”用） -->
    <link
      rel="stylesheet"
      href="https://cdn-uicons.flaticon.com/3.0.0/uicons-thin-rounded/css/uicons-thin-rounded.css"
    />
    <!-- tr -->
    <link rel="stylesheet" href="https://cdn-uicons.flaticon.com/3.0.0/uicons-thin-chubby/css/uicons-thin-chubby.css" />
    <!-- tc -->
    <link
      rel="stylesheet"
      href="https://cdn-uicons.flaticon.com/3.0.0/uicons-regular-chubby/css/uicons-regular-chubby.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn-uicons.flaticon.com/3.0.0/uicons-solid-rounded/css/uicons-solid-rounded.css"
    />

    <style>
      /* ===================== 基础变量 ===================== */
      :root {
        --size: 1vh;
        --width: 50vw;
        --aspect-ratio: 37/76;
        --pad: 1.25em;
        --border-radius: 6.666em;
        --gutter: calc(var(--pad) * 2);
        --button-width: 0.333em;
        --notch-height: 3.33em;
        --notch-width: 33.3%;
        --notch-radius: calc(var(--border-radius) - calc(var(--pad) * 2));
        --notch-duration: 0.333s;
        --ease: cubic-bezier(0.666, 0, 0.4, 1);
        --ease-spring: cubic-bezier(0.666, 0, 0.4, 1.2);
        --ease-out: cubic-bezier(0.15, 0, 0.333, 1);
        --border-width: 0.4em;
        --bksx: 284;
        --c-h: var(--bksx);
        --icon-cols: 4;
        --icon-gap: calc(var(--pad) * 0.9);
      }
      @keyframes appear {
        to {
          transform: scale3d(1, 1, 1);
          opacity: 1;
        }
      }
      body {
        background: black;
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: Inter;
        font-size: var(--size);
        box-sizing: border-box;
      }

      /* ===================== 机身外壳 ===================== */
      .RMPhone {
        margin: 1em;
        position: relative;
        z-index: 1;
        aspect-ratio: var(--aspect-ratio);
        background: black;
        width: var(--width);
        border-radius: var(--border-radius);
        box-shadow: 0 0 0.1em 0.25em hsl(var(--c-h), 20%, 25%), 0 0 0 var(--border-width) hsl(var(--c-h), 30%, 85%);
        box-sizing: border-box;
        opacity: 0;
        transform: scale3d(1.1, 1.1, 1);
        animation: appear 1s var(--ease-out) forwards;
        -webkit-backface-visibility: hidden;
      }
      .RMPhone:before {
        content: '';
        position: absolute;
        top: var(--border-radius);
        right: calc(var(--border-width) * -1);
        bottom: var(--border-radius);
        left: calc(var(--border-width) * -1);
        border: 0.5em solid hsl(var(--c-h), 20%, 30%);
        border-left-width: 0;
        border-right-width: 0;
      }
      .RMPhone-side-buttons {
        position: absolute;
        inset: calc(var(--border-width) * -1);
        pointer-events: none;
      }
      .RMPhone-side-buttons .left,
      .RMPhone-side-buttons .right {
        position: absolute;
        width: var(--button-width);
        display: flex;
        flex-direction: column;
        gap: 1.5em;
      }
      .RMPhone-side-buttons .left {
        right: 100%;
        top: calc(var(--border-radius) * 2);
      }
      .RMPhone-side-buttons .left .button:nth-child(1) {
        height: 3em;
        margin-bottom: 0.5em;
      }
      .RMPhone-side-buttons .right {
        left: 100%;
        transform: scale3d(-1, 1, 1);
        top: calc(var(--border-radius) * 3);
      }
      .RMPhone-side-buttons .right .button {
        height: 9.5em;
      }
      .RMPhone-side-buttons .button {
        background: hsl(var(--c-h), 20%, 95%);
        height: 6em;
        box-shadow: inset -0.15em 0 0.1em black, inset 0 0 0.1em hsl(var(--c-h), 30%, 90%),
          inset 0 0.2em 0.1em hsl(var(--c-h), 30%, 90%), inset 0 -0.2em 0.1em hsl(var(--c-h), 30%, 90%),
          inset -0.1em 0.333em 0.1em rgba(0, 0, 0, 0.5), inset -0.1em -0.333em 0.1em rgba(0, 0, 0, 0.5);
        border-top-left-radius: 0.2em;
        border-bottom-left-radius: 0.2em;
      }

      /* ===================== 屏幕容器与壁纸 ===================== */
      .RMPhone-screen-container {
        position: absolute;
        inset: 0;
        border-radius: var(--border-radius);
        border: var(--pad) solid black;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: calc(var(--pad) * 2);
        overflow: hidden;
      }
      .RMPhone-screen-container:before {
        display: none;
      } /* 用真实home条替代伪元素 */
      .RMPhone-bg {
        position: absolute;
        inset: 0;
        background: url('https://i.postimg.cc/05nwGQKJ/dusk-dark-wallpaper.jpg') center/cover no-repeat;
        border-radius: calc(var(--border-radius) - var(--pad));
        overflow: hidden;
        transform: translateZ(0);
      }

      /* ===================== 灵动岛（保留） ===================== */
      .RMPhone .notch-container {
        position: absolute;
        z-index: 11;
        top: var(--pad);
        right: var(--pad);
        left: var(--pad);
        display: flex;
        justify-content: center;
        height: 100%;
        max-height: calc(var(--notch-radius) * 2);
        pointer-events: none;
        outline: none;
        transition: var(--notch-duration) var(--ease);
        transition-property: max-height, max-width, filter, transform;
        will-change: max-width, max-height, filter;
      }
      .RMPhone .is-resizing .notch-container,
      .RMPhone .is-resizing .notch-container * {
        transition: none;
      }
      .RMPhone .notch-container:hover,
      .RMPhone .notch-container:focus-within {
        --shadow-opacity: 0.5;
        transition-timing-function: var(--ease-spring);
      }
      .RMPhone .notch-container:hover .notch-content,
      .RMPhone .notch-container:focus-within .notch-content {
        --content-padding: 2em;
      }
      .RMPhone .notch-container:hover .notch-content .song-info,
      .RMPhone .notch-container:focus-within .notch-content .song-info {
        opacity: 1;
      }
      .RMPhone .notch-container:hover .notch,
      .RMPhone .notch-container:focus-within .notch {
        max-width: 100%;
        max-height: 100%;
        pointer-events: all;
        transform: scale3d(1, 1, 1);
      }
      .RMPhone .notch-container:hover ~ .notch-blur,
      .RMPhone .notch-container:focus-within ~ .notch-blur {
        opacity: 1;
        max-height: calc(var(--notch-radius) * 3.333 + var(--pad));
      }
      .RMPhone .notch-container:focus-within {
        max-height: calc(var(--notch-radius) * 3);
        --bar-height: 1em;
        --bar-opacity: 1;
      }
      .RMPhone .notch-container:focus-within .notch-media,
      .RMPhone .notch-container:focus-within .notch-controls {
        max-height: calc(100% - var(--bar-height, 0%) - var(--content-gap));
      }
      .RMPhone .notch-container:focus-within ~ .notch-blur {
        max-height: calc(var(--notch-radius) * 5);
        opacity: 1;
      }
      .RMPhone .notch-blur {
        position: absolute;
        z-index: 2;
        top: calc(var(--pad) - 3px);
        right: calc(var(--pad) - 3px);
        left: calc(var(--pad) - 3px);
        height: 100%;
        max-height: calc(var(--notch-radius) * 1.5);
        backdrop-filter: blur(0.2em);
        mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 60%, rgba(0, 0, 0, 0) 100%);
        opacity: 0;
        border-radius: calc(var(--border-radius) - var(--pad));
        transition: var(--notch-duration) var(--ease);
        transition-property: max-height, max-width, opacity, transform;
        will-change: max-width, max-height;
        pointer-events: none;
      }
      .RMPhone .notch {
        position: relative;
        border-radius: var(--notch-radius);
        pointer-events: all;
        overflow: hidden;
        color: #fff;
        display: flex;
        cursor: pointer;
        width: 100%;
        transition: inherit;
        filter: drop-shadow(0 1em 2em hsla(0 0% 0% / var(--shadow-opacity, 0)));
        transform: scale3d(0.375, 0.4, 1);
        transform-origin: top;
      }
      .RMPhone .notch:before {
        content: '';
        position: absolute;
        inset: 0;
        background: black;
        filter: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1'><defs><filter id='round'><feGaussianBlur in='SourceGraphic' stdDeviation='5' result='blur' /><feColorMatrix in='blur' mode='matrix' values='1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 19 -9' result='goo'/><feComposite in='SourceGraphic' in2='goo' operator='atop'/></filter></defs></svg>#round");
        border-radius: inherit;
      }
      .RMPhone .notch-content {
        --content-padding: 1.75em;
        --duration-height: 0.5em;
        --content-gap: 1em;
        width: 100%;
        display: flex;
        flex-wrap: wrap;
        align-items: stretch;
        justify-content: stretch;
        padding: var(--content-padding);
        gap: var(--content-gap);
        font-size: 125%;
        transition-property: padding;
        position: relative;
      }
      .RMPhone .notch-content,
      .RMPhone .notch-content .notch-media,
      .RMPhone .notch-content .notch-controls,
      .RMPhone .notch-content .notch-playback-bar,
      .RMPhone .notch-content .song-info {
        transition: var(--notch-duration) var(--ease-out);
      }
      .RMPhone .notch-content .notch-media,
      .RMPhone .notch-content .notch-controls {
        height: 100%;
        max-height: calc(100% - var(--bar-height, 0%));
        display: flex;
        align-items: center;
        gap: 1em;
      }
      .RMPhone .notch-content .notch-media {
        flex-grow: 2;
      }
      .RMPhone .notch-content .song-info {
        display: flex;
        flex-direction: column;
        gap: 0.333em;
        transition-property: opacity;
        opacity: var(--bar-opacity, 0);
      }
      .RMPhone .notch-content .song-info:before {
        content: "Is It Over Now? (Taylor's Version)";
        order: 1;
        text-transform: uppercase;
      }
      .RMPhone .notch-content .song-info:after {
        content: 'Taylor Swift';
        order: 2;
        opacity: 0.5;
      }
      .RMPhone .notch-content .notch-controls {
        flex-grow: 1;
      }
      .RMPhone .notch-content .album-artwork {
        background: url('https://i.postimg.cc/43tkgCJX/image.jpg') center/cover no-repeat;
        height: 100%;
        aspect-ratio: 1;
        border-radius: 20%;
        position: relative;
      }
      .RMPhone .notch-content .notch-playback-bar {
        display: flex;
        align-items: center;
        gap: 1em;
        flex-basis: 100%;
        height: 100%;
        max-height: var(--bar-height, 0%);
        color: rgba(255, 255, 255, 0.5);
        opacity: var(--bar-opacity, 0);
      }
      .RMPhone .notch-content .notch-playback-progress {
        position: relative;
        height: var(--duration-height);
        background: rgba(255, 255, 255, 0.25);
        border-radius: calc(var(--duration-height) * 0.5);
        overflow: hidden;
        flex-grow: 1;
      }
      .RMPhone .notch-content .notch-playback-progress:before {
        content: '';
        height: 100%;
        background: #fff;
        width: 25%;
        position: absolute;
      }
      .RMPhone .notch-content .notch-playback-bar:before {
        content: '0:56';
      }
      .RMPhone .notch-content .notch-playback-bar:after {
        content: '-2:53';
      }

      .RMPhone .camera {
        display: flex;
        justify-content: center;
        align-items: center;
        height: var(--notch-height);
        aspect-ratio: 1/1;
        border-radius: 50%;
        pointer-events: none;
        position: absolute;
        z-index: 12;
        top: calc(var(--pad) * 2);
        right: calc(50% - calc(var(--notch-width) * 0.5));
        margin-right: calc(var(--pad) * 0.333);
      }
      .RMPhone .camera:before {
        content: '';
        height: 33.3%;
        aspect-ratio: 1;
        border-radius: inherit;
        box-shadow: inset 0 0 0.25em #4c4da3;
        background: radial-gradient(#6667ac, transparent 50%) no-repeat 33.3% 10% / 75% 50%,
          radial-gradient(#3c3d8a, transparent 50%) no-repeat 60% 85% / 50% 50%;
        background-color: #080928;
      }

      /* ===================== 桌面分页 ===================== */
      .RMPhone-screen {
        display: flex;
        flex-grow: 1;
        box-sizing: border-box;
        width: 100%;
        position: relative;
        overflow: hidden;
        z-index: 1;
        padding: 0;
        border-radius: calc(var(--border-radius) - var(--pad));
      }
      .RMPhone-pages {
        display: flex;
        width: 100%;
        height: 100%;
        overflow-x: auto;
        overflow-y: hidden;
        scroll-snap-type: x mandatory;
        -webkit-overflow-scrolling: touch;
        scroll-behavior: smooth;
      }
      .RMPhone-page {
        flex: 0 0 100%;
        width: 100%;
        height: 100%;
        scroll-snap-align: start;
        box-sizing: border-box;
        padding: calc(var(--gutter) * 3) var(--gutter) var(--gutter);
        border-radius: calc(var(--border-radius) - var(--pad));
        display: grid;
        grid-template-columns: repeat(var(--icon-cols), minmax(0, 1fr));
        gap: var(--icon-gap);
        align-content: start;
        justify-items: stretch;
      }
      .RMPhone-page-dots {
        position: absolute;
        left: 50%;
        bottom: calc(var(--pad) * 1.2 + 1em);
        transform: translateX(-50%);
        display: flex;
        gap: 1em;
        z-index: 20;
      }
      .RMPhone-page-dots .dot {
        width: 0.5em;
        height: 0.5em;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.4);
        transition: transform 0.2s var(--ease), background-color 0.2s var(--ease);
      }
      .RMPhone-page-dots .dot.active {
        background: #fff;
        transform: scale(1.2);
      }
      .RMPhone-pages::-webkit-scrollbar {
        display: none;
      }

      /* ===================== 图标：按钮版 ===================== */
      button.RMPhone-app {
        border: 0;
        background: transparent;
        padding: 0;
        appearance: none;
        -webkit-appearance: none;
        aspect-ratio: 1;
        border-radius: 30%;
        position: relative;
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        margin: 0;
        box-sizing: border-box;
        user-select: none;
        touch-action: pan-x;
      }
      button.RMPhone-app:active {
        transform: scale(0.96);
      }
      button.RMPhone-app:focus-visible {
        outline: 2px solid rgba(255, 255, 255, 0.7);
        outline-offset: 2px;
      }
      button.RMPhone-app::before {
        content: '';
        background: linear-gradient(190deg, var(--app-bg-s1, #fff), var(--app-bg-s2, var(--app-bg-s1, #fff))) top/100%
          125%;
        border-radius: inherit;
        position: absolute;
        inset: 0;
      }
      .RMPhone-app--grey::before {
        --app-bg-s1: #cecdd5;
        --app-bg-s2: #89888d;
      }
      .RMPhone-app--white::before {
        --app-bg-s1: #f0f0f0;
        --app-bg-s2: #ffffff;
      }
      .RMPhone-app img {
        position: relative;
        z-index: 1;
        width: 80%;
        height: 80%;
        object-fit: contain;
        pointer-events: none;
        user-select: none;
        -webkit-user-drag: none;
      }

      /* ===================== 视口 / 后台 / home条 ===================== */
      .RMPhone-viewport {
        position: absolute;
        inset: 0;
        z-index: 30;
        display: none;
        overflow: hidden;
        border-radius: calc(var(--border-radius) - var(--pad));
      }
      .RMPhone.is-app-open .RMPhone-viewport {
        display: block;
      }

      .RMPhone-switcher {
        position: absolute;
        inset: 0;
        z-index: 35;
        display: none;
        border-radius: calc(var(--border-radius) - var(--pad));
        background: transparent;
        padding: 0;
      }
      .RMPhone-switcher.is-open {
        display: flex;
      }
      .RMPhone-switcher-track {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        gap: 1rem;
        overflow-x: auto;
        overflow-y: hidden;
        scroll-snap-type: x mandatory;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
      }
      .RMPhone-switcher-track::-webkit-scrollbar {
        width: 0;
        height: 0;
        display: none;
      }

      .RMPhone-switcher-card {
        flex: 0 0 74%;
        height: 74%;
        margin: auto;
        border-radius: 1.4rem;
        background: #fff;
        color: #000;
        box-shadow: 0 0.6rem 1.2rem rgba(0, 0, 0, 0.25);
        scroll-snap-align: center;
        position: relative;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        transform: translateY(var(--ty, 0)) scale(var(--sc, 0.9));
        transition: transform 0.2s var(--ease), opacity 0.2s var(--ease);
        touch-action: pan-x;
      }
      .RMPhone-switcher-card .title {
        opacity: 0.8;
      }

      .RMPhone-switcher-card .thumb{
  position: absolute;
  inset: 0;
  background-size: cover;
  background-position: center;
  border-radius: inherit;
  filter: none;
}
.RMPhone-switcher-card .title{
  position: relative;           /* 让标题在缩略图之上 */
  z-index: 1;
  padding:0 .4rem .4rem;
  border-radius: .6rem;
  font-size: 2em;
  background: rgba(0,0,0,.35);  /* 让文字更清楚，可按需删掉 */
  color: #fff;
}

      /* 虚化后台：只做一层模糊 */
      .RMPhone.is-switcher-open .RMPhone-screen {
        filter: blur(10px) brightness(0.9);
        transform: scale(0.985);
        transition: filter 0.2s var(--ease), transform 0.2s var(--ease);
        pointer-events: none;
      }

      .RMPhone.is-switcher-open .RMPhone-bg {
        filter: blur(4px) brightness(0.9);
      }
      .RMPhone.is-switcher-open .notch-blur {
        display: none !important;
      }
      .RMPhone.is-switcher-open #page-dots,
      .RMPhone.is-switcher-open .RMPhone-homebar {
        opacity: 0.35;
      }
      .RMPhone.is-switcher-open .RMPhone-viewport {
        display: none !important;
      }

      /* 后台管理器里的一切都不可被选中、图片不可被拖拽 */
      .RMPhone-switcher,
      .RMPhone-switcher * {
        user-select: none;
        -webkit-user-select: none;
      }
      .RMPhone-switcher img {
        -webkit-user-drag: none;
        pointer-events: none; /* 不影响点卡片，点在卡片容器上 */
      }

      .RMPhone-homebar {
        position: absolute;
        z-index: 40;
        left: 50%;
        bottom: calc(var(--pad) * 0.8);
        transform: translateX(-50%);
        width: 36.6%;
        height: calc(var(--pad) * 0.5);
        border-radius: calc(var(--pad) * 0.25);
        background: rgba(255, 255, 255, 0.85);
        touch-action: none;
        will-change: transform;
        transition: transform 0.2s var(--ease);
        user-select: none;
      }
      /* 打开 App 时，保留 home 条手势 */
      .RMPhone.is-app-open .RMPhone-homebar {
        opacity: 0.85;
        pointer-events: auto;
      }

      .RMPhone-switcher-empty {
        margin: auto;
        color: #fff;
        opacity: 0.8;
        font-size: 2.2em;
        user-select: none;
      }

      .RMPhone-screen {
        z-index: 10;
      }
      .RMPhone-viewport {
        z-index: 40;
      }
      .RMPhone-switcher {
        z-index: 60;
      }
      .RMPhone .notch-container {
        z-index: 90;
      }
      .RMPhone .camera {
        z-index: 95;
      }
      .RMPhone-homebar {
        z-index: 100;
      }

      /* 小屏适配 */
      @media (max-width: 480px) {
        .RMPhone {
          width: 95vw;
          height: auto;
        }
      }
    </style>

    <div class="RMPhone" data-initial-index="1">
      <div class="RMPhone-side-buttons">
        <div class="left">
          <div class="button"></div>
          <div class="button"></div>
          <div class="button"></div>
        </div>
        <div class="right"><div class="button"></div></div>
      </div>

      <div class="camera"></div>

      <div class="RMPhone-screen-container">
        <div class="RMPhone-bg"></div>

        <div class="notch-container" tabindex="0">
          <div class="notch">
            <div class="notch-content">
              <div class="notch-media">
                <div class="album-artwork"></div>
                <div class="song-info"></div>
              </div>
              <div class="notch-controls"></div>
              <div class="notch-playback-bar"><div class="notch-playback-progress"></div></div>
            </div>
          </div>
        </div>
        <div class="notch-blur"></div>

        <!-- 桌面分页 -->
        <div class="RMPhone-screen" id="app-container">
          <div class="RMPhone-pages" id="pages">
            <section class="RMPhone-page"></section>

            <section class="RMPhone-page">
              <button class="RMPhone-app RMPhone-app--grey" data-app="settings" aria-label="设置">
                <img src="https://i.postimg.cc/05fCzPV9/R.png" alt="" />
              </button>
              <button class="RMPhone-app RMPhone-app--white" data-app="qq" aria-label="QQ">
                <img
                  src="https://img.icons8.com/external-tal-revivo-color-tal-revivo/96/external-tencent-qq-an-instant-messaging-software-service-and-web-portal-developed-logo-color-tal-revivo.png"
                  alt=""
                />
              </button>
            </section>

            <section class="RMPhone-page">
              <button class="RMPhone-app RMPhone-app--grey" data-app="youtube" aria-label="YouTube">
                <img src="https://img.icons8.com/color/96/youtube-play.png" alt="" />
              </button>
              <button class="RMPhone-app RMPhone-app--white" data-app="discord" aria-label="Discord">
                <img src="https://img.icons8.com/color/96/discord-logo.png" alt="" />
              </button>
            </section>
          </div>
          <div class="RMPhone-page-dots" id="page-dots"></div>
        </div>

        <!-- 视口 / 后台 / home条 -->
        <div class="RMPhone-viewport" id="viewport"></div>
        <div class="RMPhone-switcher" id="switcher"></div>
        <div class="RMPhone-homebar" id="homebar" role="button" aria-label="Home"></div>
      </div>
    </div>
    <!-- ===================== JS：RMPhone 命名空间 ===================== -->
    <script>
      /* 全局命名空间 */
      window.RMPhone = window.RMPhone || { Apps: {} };

      /* ===== RMPhoneToWorldBook（命名根：RMPhoneSettingsData；新：扫描/只创建/分区读写） ===== */
      const RMPhoneToWorldBook = (() => {
        const ENTRY = 'RMPhone手机设置';
        const ORDER = 1213;
        const ROOT_KEY = 'RMPhoneSettingsData';

        // 全局三项默认值
        const DEFAULT_GLOBAL = {
          wallpaper: 'https://i.postimg.cc/05nwGQKJ/dusk-dark-wallpaper.jpg',
          aspectRatio: '37/76',
          bksx: 284,
        };

        const needFns = [
          'getCharWorldbookNames',
          'rebindCharWorldbooks',
          'createWorldbook',
          'getWorldbook',
          'createWorldbookEntries',
          'updateWorldbookWith',
        ];
        const waitAPI = async (t = 15000) => {
          const ok = () => needFns.every(k => typeof window[k] === 'function');
          if (ok()) return;
          const s = Date.now();
          while (Date.now() - s < t) {
            await new Promise(r => setTimeout(r, 50));
            if (ok()) return;
          }
          throw new Error('Worldbook API 未就绪');
        };
        const J = o => JSON.stringify(o, null, 2);
        const P = t => {
          try {
            return JSON.parse(String(t || '').trim());
          } catch {
            return {};
          }
        };

        // 规范化成 { global:{...}, apps:{...} }
        const normalizeData = raw => {
          const root = (raw && typeof raw === 'object' && (raw[ROOT_KEY] || raw)) || {};
          const global = {
            ...DEFAULT_GLOBAL,
            ...(root.global || (root.wallpaper || root.aspectRatio || root.bksx ? root : {})),
          };
          const apps = root.apps && typeof root.apps === 'object' ? root.apps : {};
          return { global, apps };
        };

        async function ensurePrimary() {
          const bind = getCharWorldbookNames('current');
          if (bind?.primary) return bind.primary;
          const name = `RMPhone@${Date.now()}`;
          await createWorldbook(name, []);
          await rebindCharWorldbooks('current', { primary: name, additional: bind?.additional || [] });
          return name;
        }

        /* ========== 基础：加载（不存在则创建带 ROOT_KEY 的初始结构） ========== */
        async function load() {
          await waitAPI();
          const wb = await ensurePrimary();
          const list = await getWorldbook(wb);
          let entry = list.find(e => e.name === ENTRY);
          if (!entry) {
            const initial = { [ROOT_KEY]: { global: { ...DEFAULT_GLOBAL }, apps: {} } };
            const res = await createWorldbookEntries(
              wb,
              [
                {
                  name: ENTRY,
                  enabled: false,
                  strategy: {
                    type: 'selective',
                    keys: [],
                    keys_secondary: { logic: 'and_any', keys: [] },
                    scan_depth: 1,
                  },
                  position: { order: ORDER },
                  content: J(initial),
                },
              ],
              { render: 'debounced' },
            );
            entry = res.new_entries[0];
          }
          const raw = P(entry.content);
          const data = normalizeData(raw);
          return { wb, data };
        }

        /* ========== 内部：整包写回（覆盖 content） ========== */
        async function writeAll(wb, nextData) {
          const payload = { [ROOT_KEY]: nextData };
          let out = null;
          await updateWorldbookWith(wb, worldbook =>
            worldbook.map(e => {
              if (e.name !== ENTRY) return e;
              out = nextData;
              return {
                ...e,
                enabled: false,
                strategy: {
                  type: 'selective',
                  keys: [],
                  keys_secondary: { logic: 'and_any', keys: [] },
                  scan_depth: 1,
                },
                position: { ...(e.position || {}), order: ORDER },
                content: J(payload),
              };
            }),
          );
          return out;
        }

        /* ========== 应用到页面：只认 { global } ========== */
        function apply(s) {
          const global = { ...DEFAULT_GLOBAL, ...(s.global || {}) };
          const css = document.documentElement.style;
          css.setProperty('--aspect-ratio', global.aspectRatio);
          css.setProperty('--bksx', String(global.bksx));
          const bg = document.querySelector('.RMPhone-bg');
          if (bg) bg.style.backgroundImage = `url('${global.wallpaper}')`;
        }

        /* ========== 新：扫描 / 只创建 / 读 JSON（适合“只需创建一次，不再修改”的条目） ========== */
        // 仅扫描是否存在该 name 的条目（不创建不修改）
        async function scan(entryName = ENTRY) {
          await waitAPI();
          const wb = await ensurePrimary();
          const list = await getWorldbook(wb);
          const entry = list.find(e => e.name === entryName);
          return { wb, exists: !!entry, entry };
        }

        // 确保存在该条目：不存在则用 initialContent 创建；存在则原样返回（不修改）
        async function ensure(entryName, initialContent = '', { order = ORDER, protect = true } = {}) {
          await waitAPI();
          const { wb, exists, entry } = await scan(entryName);
          if (exists) return { wb, entry };
          const payload = {
            name: entryName,
            position: { order },
            content: typeof initialContent === 'string' ? initialContent : J(initialContent),
          };
          if (protect) {
            payload.enabled = false;
            payload.strategy = {
              type: 'selective',
              keys: [],
              keys_secondary: { logic: 'and_any', keys: [] },
              scan_depth: 1,
            };
          }
          const res = await createWorldbookEntries(wb, [payload], { render: 'debounced' });
          return { wb, entry: res.new_entries[0] };
        }

        // 读取某个条目的 content 并尝试解析为 JSON（不存在或解析失败返回 null）
        async function readEntryJSON(entryName) {
          const { entry } = await scan(entryName);
          if (!entry) return null;
          try {
            return JSON.parse(String(entry.content || '').trim());
          } catch {
            return null;
          }
        }

        /* ========== 分区读写：整包 / 单 App / 只改 global ========== */
        async function getAll() {
          const { data } = await load();
          return data; // { global, apps }
        }

        async function getApp(appName) {
          const { data } = await load();
          return (data.apps && data.apps[appName]) || {};
        }

        async function saveGlobal(patch) {
          await waitAPI();
          const { wb, data } = await load();
          const next = { ...data, global: { ...data.global, ...(patch || {}) } };
          return await writeAll(wb, next);
        }

        async function saveApp(appName, patch) {
          await waitAPI();
          const { wb, data } = await load();
          const nextApps = { ...(data.apps || {}), [appName]: { ...(data.apps?.[appName] || {}), ...(patch || {}) } };
          const next = { ...data, apps: nextApps };
          const saved = await writeAll(wb, next);
          return saved.apps?.[appName] || {};
        }

        // 新增：创建 QQ 群聊条目（RMPhoneQQ群聊.<群名>）
        async function createQQGroupEntry(groupName, contentText) {
          await waitAPI();
          const primary = await ensurePrimary(); // 确保有主世界书（没有就新建并绑定）:contentReference[oaicite:10]{index=10}
          const entryName = `RMPhoneQQ群聊.${groupName}`;

          const entry = {
            name: entryName,
            enabled: true,
            position: { type: 'at_depth', role: 'system', depth: 4, order: 1213 },
            recursion: { prevent_incoming: true, prevent_outgoing: true },
            strategy: { type: 'selective', keys: ['群聊', String(groupName)] },
            content: String(contentText || ''),
          };

          // 追加条目（不覆盖已有）
          await createWorldbookEntries(primary, [entry], { replace: false });
          return entryName;
        }

/* ==== 新增：QQ 表情库（RMPhoneQQ表情存放） =====================================
 * 放到 RMPhoneToWorldBook IIFE 里，紧接在 createQQGroupEntry(...) 下面即可。
 * 用法：
 *   await RMPhoneToWorldBook.ensureQQEmojiStore();           // 没有就创建
 *   const txt = await RMPhoneToWorldBook.readQQEmojiStore(); // 读文本
 *   await RMPhoneToWorldBook.writeQQEmojiStore('...');       // 覆盖文本
 *   // 便捷：追加一条
 *   await RMPhoneToWorldBook.addEmojiToStore('打坐','https://files.catbox.moe/qzr8yo.jpg');
 * ============================================================================ */
const EMOJI_ENTRY = 'RMPhoneQQ表情存放';
const EMOJI_DEFAULT = `这里是聊天可用表情包：
<bqb>
[打坐|https://files.catbox.moe/qzr8yo.jpg]
[楚楚可怜|ls7328.jpg]
</bqb>`;

async function ensureQQEmojiStore({ content = EMOJI_DEFAULT } = {}) {
  await waitAPI();
  const { exists } = await scan(EMOJI_ENTRY);
  if (exists) return { created: false, name: EMOJI_ENTRY };

  const wb = await ensurePrimary();
  const entry = {
    name: EMOJI_ENTRY,
    enabled: true,
    // 等价于你说的 position: 'at_depth_as_system' + depth:4
    position: { type: 'at_depth', role: 'system', depth: 4, order: 1213 },
    // 兼容两种写法
    prevent_recursion: true,
    exclude_recursion: false,
    recursion: { prevent_incoming: true, prevent_outgoing: false },
    strategy: {
      type: 'selective',
      keys: ['bqb', '表情包'],
      keys_secondary: { logic: 'and_any', keys: [] },
      scan_depth: 1,
    },
    content: String(content || ''),
  };
  await createWorldbookEntries(wb, [entry], { replace: false });
  return { created: true, name: EMOJI_ENTRY };
}

async function readQQEmojiStore() {
  const { entry } = await scan(EMOJI_ENTRY);
  return entry ? String(entry.content || '') : null;
}

async function writeQQEmojiStore(nextText) {
  const { wb } = await scan(EMOJI_ENTRY);
  let ok = false;
  await updateWorldbookWith(wb, worldbook =>
    worldbook.map(e => {
      if (e.name !== EMOJI_ENTRY) return e;
      ok = true;
      return { ...e, content: String(nextText ?? '') };
    }),
  );
  return ok;
}

// 小工具：往 <bqb>...</bqb> 里追加一行 [名字|URL]
function _appendBqbLine(src, label, url) {
  const line = `[${label}|${url}]`;
  const start = src.indexOf('<bqb>');
  const end = src.indexOf('</bqb>');
  if (start >= 0 && end > start) {
    const head = src.slice(0, start + 5);
    const body = src.slice(start + 5, end).trimEnd();
    const tail = src.slice(end);
    return `${head}\n${body}\n${line}\n${tail}`;
  }
  // 没有 <bqb> 块就新建
  return `${src}\n<bqb>\n${line}\n</bqb>`;
}

async function addEmojiToStore(label, url) {
  const cur = (await readQQEmojiStore()) ?? EMOJI_DEFAULT;
  const next = _appendBqbLine(cur, label, url);
  await writeQQEmojiStore(next);
  return next;
}

// === 新增：RMPhone格式规范（只创建，不改动） ===
async function ensureFormatSpecEntry() {
  await waitAPI();
  const name = 'RMPhone格式规范';
  const { exists } = await scan(name);
  if (exists) return { created: false, name };

  const wb = await ensurePrimary();
  const entry = {
    name,
    enabled: true,
    position: { order: ORDER },               // 顺序 1213（ORDER 上面已经是 1213）
    prevent_recursion: true,
    exclude_recursion: true,
    strategy: {
      type: 'selective',
      keys: ['<RMPhone>', 'QQ', 'qq', 'DM', 'GROUP'],
      keys_secondary: { logic: 'and_any', keys: [] },
      scan_depth: 0                           // 你要的 depth=0（这里对应 scan_depth）
    },
    content: 'RMPhone格式规范'
  };
  await createWorldbookEntries(wb, [entry], { replace: false });
  return { created: true, name };
}

        return {
          ROOT_KEY,
          DEFAULT_GLOBAL,
          // 主设定（带 ROOT_KEY）
          load,
          apply,
          getAll,
          getApp,
          saveGlobal,
          saveApp,
          // 通用“扫描/只创建/读 JSON”
          scan,
          ensure,
          readEntryJSON,
          createQQGroupEntry,

          ensureQQEmojiStore, readQQEmojiStore, writeQQEmojiStore, addEmojiToStore, ensureFormatSpecEntry,
        };
      })();

      /* ===== 启动一次：读 → 应用（只有首次缺条目才会新建一次） ===== */
      (async () => {
        if (window.__RMPhoneWBLoaded__) return;
        window.__RMPhoneWBLoaded__ = true;
        try {
          const { data } = await RMPhoneToWorldBook.load();
          RMPhoneToWorldBook.apply(data); // 应用 global（壁纸 / 比例 / bksx）
          await RMPhoneToWorldBook.ensureQQEmojiStore?.();
          await RMPhoneToWorldBook.ensureFormatSpecEntry?.();
        } catch (e) {
          console.warn('RMPhoneToWorldBook:', e);
        }
      })();

      /* =============== RMPhoneToChatMessage：自动用 `$1` 初始化、解析、分发、回写 =============== */
      const RMPhoneToChatMessage = (() => {
        /* ---- 内部状态：先置空，等待异步初始化 ---- */
  let _raw = '';
  let _data = { qq: { accounts: [] } };
  let _initialized = false;
  let _initPromise = null;

  /* 依赖检测：等插件把 getChatMessages / setChatMessages 挂到 window */
  const needFns = ['getChatMessages', 'setChatMessages'];
  const waitAPI = async (t = 15000) => {
          const ok = () => needFns.every(k => typeof window[k] === 'function');
          if (ok()) return;
          const s = Date.now();
          while (Date.now() - s < t) {
            await new Promise(r => setTimeout(r, 50));
            if (ok()) return;
          }
          throw new Error('ChatMessage API 未就绪');
        };

        /* ---- 小工具 ---- */
        const ESC = {
          unescape(s = '') {
            return s
              .replace(/\\\\/g, '\u0000')
              .replace(/\\\|/g, '|')
              .replace(/\\\]/g, ']')
              .replace(/\u0000/g, '\\');
          },
          escape(s = '') {
            return String(s).replace(/\\/g, '\\\\').replace(/\|/g, '\\|').replace(/\]/g, '\\]');
          },
        };
        function cleanseContent(s) {
          if (s == null) return '';
          const t = String(s).trim();
          if (t.startsWith('"') && t.endsWith('"')) return ESC.unescape(t.slice(1, -1));
          return ESC.unescape(t);
        }
        function splitFields(raw) {
          const out = [];
          let cur = '',
            i = 0,
            q = null;
          while (i < raw.length) {
            const ch = raw[i],
              prev = raw[i - 1];
            if (q) {
              if (ch === q && prev !== '\\') {
                q = null;
                cur += ch;
                i++;
                continue;
              }
              cur += ch;
              i++;
              continue;
            }
            if (ch === '"' && prev !== '\\') {
              q = '"';
              cur += ch;
              i++;
              continue;
            }
            if (ch === '|' && prev !== '\\') {
              out.push(cur);
              cur = '';
              i++;
              continue;
            }
            cur += ch;
            i++;
          }
          out.push(cur);
          return out.map(s => s.trim());
        }
        function tokenize(inner) {
          const PH = '\u0001';
          const safe = String(inner || '').replace(/\\\]/g, PH);
          const re = /\[([^\[\]]+)]/g;
          const toks = [];
          let m;
          while ((m = re.exec(safe))) toks.push(m[1].replaceAll(PH, ']'));
          return toks;
        }
        const RX_BLOCK = /<RMPhone>([\s\S]*?)<\/RMPhone>/i;
        function extractBlock(full) {
          const m = String(full || '').match(RX_BLOCK);
          if (!m) return null;
          const start = m.index,
            end = start + m[0].length;
          return { inner: m[1], before: full.slice(0, start), after: full.slice(end) };
        }

        /* ---- 解析：raw -> data（支持 QQ / DM / GROUP / ZONE） ---- */
        function parseRaw(raw) {
          const data = { qq: { accounts: [] } };
          const toks = tokenize(raw);
          const stack = [];
          let acc = null,
            sess = null;
          const push = (scope, name) => stack.push({ scope, name });
          const pop = (scope, expectName) => {
            for (let i = stack.length - 1; i >= 0; i--) {
              if (stack[i].scope === scope) {
                const it = stack.splice(i)[0];
                if (expectName && it.name && expectName.trim() !== it.name.trim()) {
                  console.warn(`闭合名不匹配: [/${scope}|${expectName}] vs [${it.scope}|${it.name}]`);
                }
                if (scope === 'qq') {
                  acc = null;
                  sess = null;
                }
                if (scope === 'dm' || scope === 'group' || scope === 'zone') {
                  sess = null;
                }
                return;
              }
            }
          };

          for (const t of toks) {
            const parts = splitFields(t);
            if (!parts.length) continue;
            const head = (parts[0] || '').trim().toUpperCase();

            if (head === 'QQ') {
              // [QQ|角色名]
              const login = (parts[1] || '').trim();
              acc = { login, sessions: [] };
              data.qq.accounts.push(acc);
              push('qq', login);
              continue;
            }
            if (head === '/QQ') {
              pop('qq', (parts[1] || '').trim());
              continue;
            }

            if (head === 'DM') {
              // [DM|对方]
              if (!acc) {
                console.warn('DM 前未进入 QQ');
                continue;
              }
              const peer = (parts[1] || '').trim();
              sess = { kind: 'dm', peer, items: [] };
              acc.sessions.push(sess);
              push('dm', peer);
              continue;
            }
            if (head === '/DM') {
              pop('dm', (parts[1] || '').trim());
              continue;
            }

            if (head === 'GROUP') {
              // [GROUP|群名]
              if (!acc) {
                console.warn('GROUP 前未进入 QQ');
                continue;
              }
              const peer = (parts[1] || '').trim();
              sess = { kind: 'group', peer, items: [] };
              acc.sessions.push(sess);
              push('group', peer);
              continue;
            }
            if (head === '/GROUP') {
              pop('group', (parts[1] || '').trim());
              continue;
            }

            if (head === 'ZONE') {
              // [ZONE] （QQ 空间动态块，无 peer）
              if (!acc) {
                console.warn('ZONE 前未进入 QQ');
                continue;
              }
              if (!acc.zone) acc.zone = { kind: 'zone', items: [] };
              sess = acc.zone;
              push('zone', 'ZONE');
              continue;
            }
            if (head === '/ZONE') {
              pop('zone');
              continue;
            }
            // 消息行：新协议 [type|speaker|...args]（不兼容旧 key=value）
            if (!acc || !sess) {
              console.warn('忽略消息：不在 QQ/DM/GROUP/ZONE 作用域', t);
              continue;
            }

            const type = (parts[0] || '').trim();
            const speaker = (parts[1] || '').trim();

            // 从第3段开始全部作为位置参数（保留原有转义/引号处理）
            const args = parts.slice(2).map(s => cleanseContent(s || ''));

            // 为了后续个别地方好用，给一个“便利字段”：content = 第一个参数（可能为空）
            const content = args[0] || '';

            sess.items.push({ type, speaker, args, content, out: speaker === acc.login });
          }

          if (stack.length) console.warn('有未闭合的作用域：', stack);
          return data;
        }

        /* ---- 序列化：data -> raw（含 ZONE） ---- */
        function stringify(data) {
          const lines = [];
          for (const acc of data?.qq?.accounts || []) {
            lines.push(`[QQ|${acc.login}]`);

            // DM/GROUP
            for (const s of acc.sessions || []) {
              if (!Array.isArray(s.items) || s.items.length === 0) continue;
              lines.push(s.kind === 'dm' ? `[DM|${s.peer}]` : `[GROUP|${s.peer}]`);
              for (const it of s.items || []) {
                const esc = val => {
                  const sv = String(val ?? '');
                  return sv.includes('|') || sv.includes(']')
                    ? `"${sv.replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`
                    : ESC.escape(sv);
                };
                const head = `[${it.type}|${it.speaker}`;
                const tail =
                  Array.isArray(it.args) && it.args.length
                    ? '|' + it.args.map(esc).join('|') + ']'
                    : it.content
                    ? '|' + esc(it.content) + ']'
                    : ']'; // 仅兜底，不再输出 params
                lines.push(head + tail);
              }
              lines.push(s.kind === 'dm' ? `[/DM|${s.peer}]` : `[/GROUP|${s.peer}]`);
            }

            // ZONE（若存在）
            if (acc.zone && Array.isArray(acc.zone.items)) {
              lines.push(`[ZONE]`);
              for (const it of acc.zone.items) {
                const payload =
                  String(it.content).includes('|') || String(it.content).includes(']')
                    ? `"${String(it.content).replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`
                    : ESC.escape(String(it.content));
                const params = Object.entries(it.params || {}).map(([k, v]) => {
                  const sv = String(v);
                  const vv =
                    sv.includes('|') || sv.includes(']')
                      ? `"${sv.replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`
                      : ESC.escape(sv);
                  return `${k}=${vv}`;
                });
                lines.push(`[${it.type}|${it.speaker}|${payload}${params.length ? `|${params.join('|')}` : ''}]`);
              }
              lines.push(`[/ZONE]`);
            }

            lines.push(`[/QQ|${acc.login}]`);
            lines.push('');
          }
          return lines.join('\n');
        }

         /* ---- 新增：异步初始化函数 ---- */
  async function initialize() {
    if (_initialized) return;
    if (_initPromise) return _initPromise; // 如果正在初始化，返回同一个 promise

    _initPromise = (async () => {
      await waitAPI();
      const last = (await window.getChatMessages?.(-1) || [])[0];
      if (!last || !last.message) {
        console.warn('RMPhone: No last message found to initialize from.');
        _initialized = true;
        return;
      }
      
      // 复用已有的 extractBlock 函数
      const block = extractBlock(String(last.message));
      
      if (block && block.inner) {
        _raw = block.inner;
        _data = parseRaw(_raw);
      } else {
        console.warn('RMPhone: <RMPhone> block not found in the last message.');
      }
      _initialized = true;
    })();
    
    await _initPromise;
  }

  /* ---- 对外：给 app 用、更新回写 ---- */
  function getData() {
    if (!_initialized) console.warn("RMPhoneToChatMessage not initialized. Call .initialize() first.");
    return _data;
  }
  function setData(next) {
    if (!_initialized) console.warn("RMPhoneToChatMessage not initialized. Call .initialize() first.");
    _data = next || { qq: { accounts: [] } };
    return _data;
  }

        function getApp(appName) {
          if (!_data[appName]) _data[appName] = { accounts: [] };
          return _data[appName];
        }
        function setApp(appName, appData) {
          _data[appName] = appData || { accounts: [] };
          return _data[appName];
        }
        function toRaw() {
          _raw = stringify(_data);
          return _raw;
        }

        // 从“片段数据”生成 raw 文本（不包 <RMPhone> 外壳）
        function buildRaw(fragment) {
          try {
            const data =
              fragment && fragment.qq && Array.isArray(fragment.qq.accounts) ? fragment : { qq: { accounts: [] } };
            return stringify(data);
          } catch (e) {
            console.warn('buildRaw 失败：', e);
            return '';
          }
        }

        // 安全解析 raw -> data（失败返回 null，不抛）
        function safeParse(raw) {
          try {
            return parseRaw(String(raw || ''));
          } catch (e) {
            console.warn('safeParse 失败：', e);
            return null;
          }
        }

        // 把 toRaw() 的内容写回最新一楼的 <RMPhone>…</RMPhone> 中间
        async function RMPhoneCommit() {
          const inner = toRaw();
          const last = (window.getChatMessages?.(-1) || [])[0];
          if (!last) return false;
          const full = String(last.message || '');
          const blk = extractBlock(full);
          const nextFull = blk
            ? `${blk.before}<RMPhone>\n${inner}\n</RMPhone>${blk.after}`
            : `${full}\n\n<RMPhone>\n${inner}\n</RMPhone>`;
          if (nextFull === full) return false;
          await window.setChatMessages?.([{ message_id: last.message_id, message: nextFull }], { refresh: 'none' });
          return true;
        }

        return { initialize, getData, setData, getApp, setApp, toRaw, RMPhoneCommit, buildRaw, safeParse };
      })();

      /* ===== App 管理器 ===== */
      class AppManager {
        constructor(root) {
          this.root = root;
          this.viewport = root.querySelector('#viewport');
          this.stack = []; // [{ name, inst }]
          this.top = null;
        }
        open(name, sourceEl) {
          const factory = RMPhone.Apps.registry?.[name];
          if (!factory) {
            console.warn('未注册的 app:', name);
            return;
          }
          let item = this.stack.find(i => i.name === name);
          if (!item) {
            const inst = factory(sourceEl);
            inst.__name = name;
            item = { name, inst };
            this.stack.push(item);
          }
          this.top = item;
          this._mountTop();
        }
        _mountTop() {
          this.root.classList.add('is-app-open');
          this.viewport.style.display = 'block';
          this.viewport.innerHTML = '';
          this.top?.inst?.mount?.(this.viewport);
        }
        async toDesktop() {
  // ← 新增：截图保存缩略图
  if (this.top && window.html2canvas) {
    try {
      const canvas = await html2canvas(this.viewport, {
        backgroundColor: null,
        useCORS: true,
        scale: 1         // 缩放减小体积，可改 1 得更清晰
      });
      this.top.previewDataURL = canvas.toDataURL('image/png');
    } catch (e) {
      console.warn('preview failed:', e);
    }
  }

  // 回桌面，不杀进程
  this.viewport.innerHTML = '';
  this.root.classList.remove('is-app-open');
  this.viewport.style.display = '';
}
        closeByName(name) {
          const idx = this.stack.findIndex(i => i.name === name);
          if (idx < 0) return;
          const item = this.stack[idx];
          item.inst?.unmount?.();
          this.stack.splice(idx, 1);
          if (this.top && this.top.name === name) {
            this.top = null;
            this.toDesktop();
          }
        }
        list() {
          return this.stack.map(i => i.name);
        }
        getPreview(name) {
          return this.stack.find(i => i.name === name)?.previewDataURL || null;
        }
      }

      /* ===== 桌面模块 ===== */
      (function (NS) {
        class Desktop {
          constructor(root) {
            this.root = root;
            this.pages = root.querySelector('.RMPhone-pages');
            this.pageEls = Array.from(root.querySelectorAll('.RMPhone-page'));
            this.dotsWrap = root.querySelector('.RMPhone-page-dots');
            this.homebar = root.querySelector('#homebar');
            this.switcher = root.querySelector('#switcher');
            this.manager = new AppManager(root);
            const idxAttr = parseInt(root.getAttribute('data-initial-index'), 10);
            this.INITIAL_INDEX = Number.isFinite(idxAttr) ? Math.max(0, Math.min(idxAttr, this.pageEls.length - 1)) : 0;
            this.isDragging = false;
            this.startX = 0;
            this.startLeft = 0;
            this.snapTimer = null;
          }

          mount() {
            this.buildDots();
            this.jumpTo(this.INITIAL_INDEX, false);
            this.bindScrollSnap();
            this.bindDragScroll();
            this.disableImageDrag();
            this.bindAppLaunch();
            this.bindHomebar();
            window.addEventListener('resize', () => this.snapToNearest());
          }

          buildDots() {
            this.dotsWrap.innerHTML = '';
            this.pageEls.forEach((_, i) => {
              const d = document.createElement('div');
              d.className = 'dot' + (i === this.INITIAL_INDEX ? ' active' : '');
              d.dataset.index = i;
              d.addEventListener('click', () => this.jumpTo(i, true));
              this.dotsWrap.appendChild(d);
            });
            this.dots = Array.from(this.dotsWrap.children);
          }

          updateDots() {
            const idx = Math.round(this.pages.scrollLeft / this.pages.clientWidth);
            this.dots.forEach((d, i) => d.classList.toggle('active', i === idx));
          }

          jumpTo(index, animate) {
            const left = index * this.pages.clientWidth;
            if (animate) this.pages.scrollTo({ left, behavior: 'smooth' });
            else this.pages.scrollLeft = left;
            this.updateDots();
          }

          bindScrollSnap() {
            this.pages.addEventListener('scroll', () => {
              this.updateDots();
              clearTimeout(this.snapTimer);
              this.snapTimer = setTimeout(() => this.snapToNearest(), 120);
            });
          }

          snapToNearest() {
            const target = Math.round(this.pages.scrollLeft / this.pages.clientWidth) * this.pages.clientWidth;
            this.pages.scrollTo({ left: target, behavior: 'smooth' });
          }

          bindDragScroll() {
            const PULL_THRESHOLD = 5;
            let startX = 0,
              startLeft = 0;
            let dragging = false,
              mayDrag = false,
              pid = null;

            this.pages.addEventListener('pointerdown', e => {
              if (e.target.closest('button.RMPhone-app')) {
                dragging = false;
                mayDrag = false;
                pid = null;
                return;
              }
              pid = e.pointerId;
              mayDrag = true;
              startX = e.clientX;
              startLeft = this.pages.scrollLeft;
            });

            this.pages.addEventListener('pointermove', e => {
              if (!mayDrag) return;
              const dx = e.clientX - startX;
              if (!dragging && Math.abs(dx) > PULL_THRESHOLD) {
                dragging = true;
                this.pages.setPointerCapture(pid);
              }
              if (dragging) this.pages.scrollLeft = startLeft - dx;
            });

            const end = () => {
              if (dragging) this.snapToNearest();
              dragging = false;
              mayDrag = false;
              pid = null;
            };
            this.pages.addEventListener('pointerup', end);
            this.pages.addEventListener('pointercancel', end);
            this.pages.addEventListener('lostpointercapture', end);
          }

          disableImageDrag() {
            this.root.querySelectorAll('.RMPhone-app img').forEach(img => {
              img.setAttribute('draggable', 'false');
              img.addEventListener('dragstart', e => e.preventDefault());
            });
          }

          bindAppLaunch() {
            this.pages.addEventListener('click', e => {
              const btn = e.target.closest('button.RMPhone-app');
              if (!btn) return;
              const name = btn.getAttribute('data-app');
              this.manager.open(name, btn);
            });
          }

          /* Home 条手势 */
          bindHomebar() {
            const hb = this.homebar;
            const OPEN_ZONE = 24;
            const MAX_DRAG = 32;
            const HOLD_MS = 350;
            const SWIPE_DY = 14;
            const SWIPE_DT = 350;

            let startY = 0,
              dragging = false,
              held = false,
              inZone = false,
              t0 = 0,
              holdTimer = null,
              lastY = 0;

            const setY = y => {
              hb.style.transform = `translateX(-50%) translateY(${-y}px)`;
            };
            const clearHold = () => {
              clearTimeout(holdTimer);
              holdTimer = null;
            };

            hb.addEventListener('pointerdown', e => {
              dragging = true;
              held = false;
              inZone = false;
              startY = e.clientY;
              t0 = performance.now();
              hb.setPointerCapture(e.pointerId);
              hb.style.transition = 'none';
            });

            hb.addEventListener('pointermove', e => {
              if (!dragging) return;
              const dy = Math.max(0, Math.min(MAX_DRAG, startY - e.clientY)); // 上拖为正
              lastY = dy;
              setY(dy);

              if (dy >= OPEN_ZONE && !inZone) {
                inZone = true;
                clearHold();
                holdTimer = setTimeout(() => {
                  held = true;
                  this.showSwitcher();
                  reset();
                }, HOLD_MS);
              } else if (dy < OPEN_ZONE && inZone) {
                inZone = false;
                clearHold();
              }
            });

            const reset = () => {
              dragging = false;
              clearHold();
              inZone = false;
              hb.style.transition = 'transform .25s var(--ease)';
              setY(0);
            };

            hb.addEventListener('pointerup', () => {
              if (held) {
                reset();
                return;
              }
              const dt = performance.now() - t0;
              if (lastY > SWIPE_DY && dt < SWIPE_DT) {
                this.manager.toDesktop();
              }
              reset();
            });

            hb.addEventListener('pointercancel', reset);
            hb.addEventListener('lostpointercapture', reset);
          }

          /* 后台：渲染、点击空白关闭；卡片可上滑关闭 */
          async showSwitcher() {
            // 先回到桌面，保留进程但把视图收起来
            await this.manager.toDesktop();   // ← 加了 await
            this.manager.toDesktop();

            const names = this.manager.list().slice().reverse();
            this.root.classList.add('is-switcher-open');

            if (!names.length) {
              this.switcher.innerHTML = '<div class="RMPhone-switcher-empty">无后台应用</div>';
              this.switcher.classList.add('is-open');
              this.switcher.onclick = () => this.hideSwitcher();
              return;
            }

            this.switcher.innerHTML = '<div class="RMPhone-switcher-track" id="switcher-track"></div>';
            const track = this.switcher.querySelector('#switcher-track');

            names.forEach(name => {
              const card = document.createElement('div');
              card.className = 'RMPhone-switcher-card';
              card.dataset.name = name;
              card.innerHTML = `<div class="thumb"></div><div class="title">${name}</div>`;
              const prev = this.manager.getPreview?.(name);
              if (prev) card.querySelector('.thumb').style.backgroundImage = `url('${prev}')`;
              this.attachCardSwipeToClose(card, name);
              // names.forEach(...) 里：创建 card 后
              let moved = false,
                sx = 0,
                sy = 0;
              card.addEventListener('pointerdown', e => {
                moved = false;
                sx = e.clientX;
                sy = e.clientY;
              });
              card.addEventListener(
                'pointermove',
                e => {
                  if (Math.abs(e.clientX - sx) > 6 || Math.abs(e.clientY - sy) > 6) moved = true;
                },
                { passive: true },
              );
              card.addEventListener('click', e => {
                if (moved) return; // 真的是“拖动”就不触发打开
                this.manager.open(name);
                this.hideSwitcher();
              });
              track.appendChild(card);
            });

            this.switcher.onclick = e => {
              if (!e.target.closest('.RMPhone-switcher-card')) this.hideSwitcher();
            };

            const update = () => {
              const rect = track.getBoundingClientRect(),
                cx = rect.left + rect.width / 2;
              track.querySelectorAll('.RMPhone-switcher-card').forEach(card => {
                const r = card.getBoundingClientRect(),
                  cc = r.left + r.width / 2;
                const t = Math.max(0, 1 - Math.abs(cc - cx) / (rect.width * 0.6));
                const s = 0.9 + 0.06 * t; // 0.90 ~ 0.96
                card.style.setProperty('--sc', s);
              });
            };
            track.addEventListener('scroll', () => requestAnimationFrame(update));
            this.switcher.classList.add('is-open');
            update();
          }

          hideSwitcher() {
            this.switcher.classList.remove('is-open');
            this.root.classList.remove('is-switcher-open');
            this.switcher.innerHTML = '';
            this.switcher.onclick = null;
          }

          attachCardSwipeToClose(card, name) {
            const LOCK_DIST = 10; // 判定方向阈值
            let pid = null,
              startX = 0,
              startY = 0,
              lock = null; // null | 'x' | 'y'
            let dragging = false,
              didClose = false;

            const reset = () => {
              if (pid !== null) {
                try {
                  card.releasePointerCapture(pid);
                } catch (_) {}
              }
              pid = null;
              lock = null;
              dragging = false;
              card.style.transition = 'transform .2s var(--ease), opacity .2s var(--ease)';
              card.style.setProperty('--ty', '0px');
              card.style.opacity = '1';
              card.style.touchAction = 'pan-x';
            };

            card.style.touchAction = 'pan-x';

            card.addEventListener('pointerdown', e => {
              pid = e.pointerId;
              startX = e.clientX;
              startY = e.clientY;
              lock = null;
              dragging = false;
              didClose = false;
              card.style.transition = 'none';
            });

            card.addEventListener('pointermove', e => {
              if (pid === null) return;
              const dx = e.clientX - startX,
                dy = e.clientY - startY;

              if (lock === null && (Math.abs(dx) > LOCK_DIST || Math.abs(dy) > LOCK_DIST)) {
                if (Math.abs(dy) > Math.abs(dx) && dy < 0) {
                  lock = 'y';
                  dragging = true;
                  card.setPointerCapture(pid);
                  card.style.touchAction = 'none';
                } else {
                  lock = 'x';
                  dragging = false;
                  return;
                }
              }

              if (lock === 'y' && dragging) {
                const y = Math.min(0, dy); // 上滑为负
                card.style.setProperty('--ty', `${y}px`);
                card.style.opacity = Math.max(0.35, 1 + y / 220);
              }
            });

            const end = e => {
              if (pid === null) return;

              if (lock === 'y') {
                const dy = e.clientY - startY,
                  H = card.getBoundingClientRect().height;

                // 触发关闭：让卡片向上飞出后再移除并重建
                if (dy <= -H * 0.5) {
                  didClose = true;
                  card.style.transition = 'transform .18s var(--ease), opacity .18s var(--ease)';
                  card.style.setProperty('--ty', `${-H}px`);
                  card.style.opacity = '0';

                  // 动画结束后再真正关闭 & 重建列表
                  setTimeout(() => {
                    this.manager.closeByName(name);
                    this.showSwitcher();
                  }, 200);

                  // 重要：这里直接 return，不要 reset()，避免“回落再飞走”
                  pid = null;
                  return;
                }
              }

              // 没触发关闭就复位
              reset();
            };

            card.addEventListener('pointerup', end);
            card.addEventListener('pointercancel', end);
            card.addEventListener('lostpointercapture', end);

            // 刚关闭时防止误点
            card.addEventListener('click', e => {
              if (didClose) {
                e.stopPropagation();
                e.preventDefault();
              }
            });
          }
        }

        NS.Desktop = Desktop;

        function init() {
          const root = document.querySelector('.RMPhone');
          if (root) {
            const inst = new Desktop(root);
            inst.mount();
            NS._instance = inst;
            NS.toDesktop = () => inst.manager.toDesktop();
            NS.showSwitcher = () => inst.showSwitcher();
          }
        }
        if (document.readyState !== 'loading') init();
        else document.addEventListener('DOMContentLoaded', init);
      })(window.RMPhone);

      /* ===== App 基类（Shadow DOM 版）与示例 Apps ===== */
      RMPhone.Apps.Base = class {
        constructor(el) {
          this.el = el;
          this.view = null;
          this.host = null;
          this.shadow = null;
        }
        mount(viewport) {
          this.view = viewport;
          this.host = document.createElement('div');
          this.host.className = 'RMPhone-app-host';
          this.host.style.cssText = 'position:absolute; inset:0; border-radius:inherit; overflow:hidden;';
          viewport.appendChild(this.host);
          this.shadow = this.host.attachShadow({ mode: 'open' });
        }
        unmount() {
          try {
            if (this.shadow) this.shadow.innerHTML = '';
          } catch (e) {}
          this.host?.remove();
          this.shadow = null;
          this.host = null;
          this.view = null;
        }
      };

      // ---- Shadow DOM 模板：每个 App 自含样式，不污染外层 ----
      RMPhone.Apps.Settings = class extends RMPhone.Apps.Base {
        mount(viewport) {
          super.mount(viewport);
          this.shadow.innerHTML = `
        <style>
          :host{display:block;height:100%}
          .wrap{position:absolute; inset:0; background:#fff; color:#111; font:14px/1.4 system-ui; display:flex; align-items:center; justify-content:center}
          .close{ position:absolute; top:12px; right:12px; border:0; cursor:pointer; padding:.25rem .6rem; border-radius:.5rem; background:#f0f0f0; }
        </style>
        <div class="wrap">
          <button class="close">关闭</button>
          <div>设置 App（示例）</div>
        </div>`;
          this._onClose ??= () => RMPhone.toDesktop?.();
          this.shadow.querySelector('.close')?.addEventListener('click', this._onClose);
        }
        unmount() {
          const btn = this.shadow?.querySelector('.close');
          if (btn && this._onClose) {
            btn.removeEventListener('click', this._onClose);
          }
          this._onClose = null; // 推荐：把引用也置空
          super.unmount();
        }
      };

      // ===== QQ App（重构版：迷你路由 + 屏幕协议 + 保留原样式/交互） =====
      /**
       * =========================================
       * RMQQ 契约说明（放在 RMQQ IIFE 顶部）
       * 作用：提供 QQ 子应用的屏幕系统（迷你路由 + 页面对象）
       * 外层：RMPhone.Apps.QQ 只依赖本契约，不依赖你的内部实现细节
       * =========================================
       *
       * @exports
       *   RMQQ.ScreenManager
       *   RMQQ.TabsView
       *   RMQQ.ChatView
       *   RMQQ.SpaceView
       *   RMQQ.VERSION (可选)
       *
       * 一、ScreenManager API（外壳强依赖）
       *   new ScreenManager(root: HTMLElement)
       *   - push(screen: Screen, opts?: { animate?: boolean, isRoot?: boolean }): void
       *   - pop(): Promise<void> | void
       *   - popTo(index: number): Promise<void>         // 反复 pop 到指定索引（用于“跨栈去重”）
       *   - top(): { screen: Screen, wrap: HTMLElement } | null
       *   - topIndex(): number                          // -1 表示空
       *   - findIndexReverse(predicate: (item)=>boolean): number
       *   - destroy(): void
       *
       *   语义约定（必须满足）：
       *   1) 首屏 push 视为 root（stack.length===0 或 opts.isRoot===true）：
       *      - 不使用“右进”入场动画（直接就位）
       *   2) push 新屏时：
       *      - 若存在下层顶屏：调用其 screen.onHide?.() 并给其 wrap 加上 'hidden'
       *   3) pop 完成后：
       *      - 新顶层 wrap 去掉 'hidden'，并调用其 screen.onShow?.()
       *
       * 二、Screen 接口（你封包内所有页面对象必须实现）
       *   interface Screen {
       *     key: 'tabs' | 'chat' | 'space' | string
       *     keepAlive: boolean          // tabs=true；子页=false
       *     mount(container: HTMLElement): void
       *     unmount(): void
       *     onShow?(): void
       *     onHide?(): void
       *   }
       *
       * 三、页面构造器（外壳会直接调用）
       *   - new TabsView(options: { onOpenChat(peerName: string): void, onOpenSpace(): void })
       *   - new ChatView(options: { peerName: string, onBack(): void })
       *   - new SpaceView(options: { onBack(): void })
       *
       * 四、CSS/类名契约（Manager 必须按这些类名增删）
       *   每个屏幕包裹元素 wrap 需添加：
       *     - 'qq-screen'   // 基础定位/裁剪
       *     - 'qq-anim'     // 启用过渡（需与外壳样式一致的 transition）
       *   入场/离场（右进右退，仅子页使用，root 不加 enter-from）：
       *     - 'qq-enter-from' → 初始（translateX(100%), opacity≈0）
       *     - 'qq-enter-to'   → 目标（translateX(0)）
       *     - 'qq-leave-from' → 初始（translateX(0)）
       *     - 'qq-leave-to'   → 目标（translateX(100%), opacity≈0）
       *   下层静默：
       *     - 'hidden' → pointer-events:none;（外壳样式已提供）
       *
       * 五、导航/去重策略（外壳 openChat/openSpace 会依赖此语义）
       *   openChat(name):
       *     const i = manager.findIndexReverse(it => it.screen.key==='chat' && it.screen.peerName===name)
       *     i === topIndex() → 仅 onShow()
       *     i >= 0           → await manager.popTo(i)
       *     否则             → manager.push(new ChatView(...))
       *
       *   openSpace():
       *     与上同，但按 key==='space' 去重（栈中最多存在一个 space）
       *
       * 六、资源与清理（必须）
       *   - 事件监听/定时器在 mount 注册，并在 unmount 全部移除
       *   - keepAlive=true 的 tabs：仅 onHide/onShow 切换，不销毁 DOM
       *   - ScreenManager.destroy()：逆序调用每个 screen.unmount() 并移除 wrap
       *
       * 七、非目标（不在封包内做）
       *   - 持久化/恢复（Worldbook）
       *   - 真实数据/账号（Tabs/Chat/Space 仅 UI 壳）
       *
       * 八、扩展点
       *   - 可新增自定义 Screen（如 ProfileView），遵守同一接口与类名即可
       *   - 如需自定义动效类名，建议 ScreenManager 支持可选参数：
       *       new ScreenManager(root, {
       *         classes: {
       *           screen:'qq-screen', hidden:'hidden',
       *           enterFrom:'qq-enter-from', enterTo:'qq-enter-to',
       *           leaveFrom:'qq-leave-from', leaveTo:'qq-leave-to', anim:'qq-anim'
       *         }
       *       })
       *
       * 九、外壳使用范例（伪代码，仅示意）
       *   const router = shadow.querySelector('#router');
       *   const mgr = new RMQQ.ScreenManager(router);
       *   const tabs = new RMQQ.TabsView({
       *     onOpenChat: (name)=> openChat(name),
       *     onOpenSpace: ()=> openSpace()
       *   });
       *   mgr.push(tabs); // 首屏：root，无入场动画
       *   function openChat(name){ /* 依“五、导航/去重策略”实现 *\/ }
       *   function openSpace(){ /* 同上 *\/ }
       *
       * 十、自测清单
       *   [ ] 初始仅 [tabs]；点会话→[tabs,chat]；返回→[tabs]
       *   [ ] 同会话二次进入不重复入栈；若被其它页覆盖，能 popTo 唤起
       *   [ ] 动态→space→返回，动画一致；下层屏幕被 .hidden 静默
       *   [ ] 回桌面再进来仍停在 QQ 的当前内部页（非持久化）
       *   [ ] Tabs 的滚动/搜索在进出 chat 后保持
       *   [ ] 切屏/返回后无残留监听器/定时器（unmount 清理）
       */
      /**
       * =========================================
       * QQ 数据所有权 & 接口（基于 RMPhoneToChatMessage）
       * =========================================
       *
       * 本 App 仅负责管理 _data.qq 名下的数据片段；不在这里存任何 HTML/DOM。
       * UI（ChatView/TabsView）只根据数据渲染。
       * 二、读写 API（由 RMPhoneToChatMessage 提供）
       *   // 读取引用（就地改）
       *   const qq = RMPhoneToChatMessage.getApp('qq');      // -> 引用 _data.qq
       *
       *   // 序列化为文本（调试用）
       *   RMPhoneToChatMessage.toRaw();
       *
       *   // 持久化到酒馆：把 <RMPhone>…</RMPhone> 最新块更新
       *   await RMPhoneToChatMessage.RMPhoneCommit();
       *
       * 三、编辑约定
       *   1) 先确保账号，再确保会话，再 push 消息。
       *   2) 会话按 (kind, peer) 唯一；不存在就创建。
       *   3) 不把 HTML/样式/组件实例写入数据；所有 UI 由渲染层决定。
       *   4) 消息 type 不限，QQ 只需在渲染层支持对应类型即可。
       *
       * 四、推荐的保存方式
       *   就地修改（快）
       *      const qq = RMPhoneToChatMessage.getApp('qq');
       *      // mutate qq...
       *      await RMPhoneToChatMessage.RMPhoneCommit();
       *
       * 五、辅助：最小工具（可选）
       *   function ensureAccount(qq, login){ ... }           // 找不到就新建
       *   function ensureSession(acc, kind, peer){ ... }     // 找不到就新建
       *   function pushItem(sess, item, login){ ... }        // 自动填充 item.out
       */

      // ====================== QQ 封包（便于折叠） ======================
      const RMQQ = (() => {
        /* ----------------- ScreenManager（带静默下层 & 动画优化） ----------------- */
        // =========================
        // RMQQ.ScreenManager（数据驱动版，保留你原动画/类名契约）
        // =========================
        // ====================== ScreenManager（数据驱动版，配合 .qq-* 动画类） ======================
        class ScreenManager {
          /**
           * @param {HTMLElement} root 包裹所有屏幕的容器（例如 <div id="router">）
           * @param {Object} [classes] 可选：自定义类名
           */
          constructor(root, classes) {
            this.root = root;
            this.stack = [];
            this.classes = Object.assign(
              {
                screen: 'qq-screen',
                hidden: 'hidden',
                anim: 'qq-anim',
                enterFrom: 'qq-enter-from',
                enterTo: 'qq-enter-to',
                leaveFrom: 'qq-leave-from',
                leaveTo: 'qq-leave-to',
              },
              classes || {},
            );
          }

          /** 栈顶项 */
          top() {
            return this.stack[this.stack.length - 1] || null;
          }

          /** 栈顶索引（空栈时为 -1） */
          topIndex() {
            return this.stack.length - 1;
          }

          /**
           * 从后往前找符合条件的屏幕，返回索引；找不到返回 -1
           * @param {(item:{screen:any,wrap:HTMLElement}, index:number)=>boolean} predicate
           */
          findIndexReverse(predicate) {
            for (let i = this.stack.length - 1; i >= 0; i--) {
              if (predicate(this.stack[i], i)) return i;
            }
            return -1;
          }

          /**
           * 入栈：首屏（或 key==='tabs'）不右进，其余页面右进
           * @param {Object} screen 需实现 { key, keepAlive, mount(el), unmount(), onShow?, onHide? }
           */
          push(screen) {
            const cls = this.classes;
            const wrap = document.createElement('div');
            wrap.className = cls.screen;
            wrap.setAttribute('data-key', screen.key || 'screen');

            const prev = this.top();
            if (prev?.wrap) {
              // 让下层完全静默
              prev.wrap.classList.add(cls.hidden);
              prev.wrap.setAttribute('aria-hidden', 'true');
              try {
                prev.screen.onHide?.();
              } catch {}
            }

            // 挂载
            this.root.appendChild(wrap);
            screen.mount(wrap);

            // 首屏或 tabs 不走“右进”
            const isFirst = this.stack.length === 0 || screen.key === 'tabs';
            if (!isFirst) {
              wrap.classList.add(cls.anim, cls.enterFrom);
              requestAnimationFrame(() => {
                // 触发过渡
                wrap.classList.add(cls.enterTo);
                const onDone = () => {
                  wrap.removeEventListener('transitionend', onDone);
                  wrap.classList.remove(cls.enterFrom, cls.enterTo);
                };
                wrap.addEventListener('transitionend', onDone);
              });
            }

            this.stack.push({ screen, wrap });
          }

          /**
           * 出栈：返回上一层；首屏不弹空
           * @returns {Promise<boolean>}
           */
          pop() {
            const cls = this.classes;
            if (this.stack.length <= 1) return Promise.resolve(false);

            const top = this.stack.pop();
            const below = this.top();
            const { wrap, screen } = top;

            return new Promise(resolve => {
              wrap.classList.add(cls.anim, cls.leaveFrom);
              requestAnimationFrame(() => {
                wrap.classList.add(cls.leaveTo);
                const done = () => {
                  wrap.removeEventListener('transitionend', done);
                  // 卸载并移除
                  try {
                    screen?.unmount?.();
                  } catch {}
                  wrap.remove();
                  // 下层恢复
                  if (below?.wrap) {
                    below.wrap.classList.remove(cls.hidden);
                    below.wrap.removeAttribute('aria-hidden');
                  }
                  try {
                    below?.screen?.onShow?.();
                  } catch {}
                  resolve(true);
                };
                wrap.addEventListener('transitionend', done);
              });
            });
          }

          /**
           * 连续弹出到栈中某一索引（包含目标保留）
           * @param {number} index
           */
          async popTo(index) {
            const target = Math.max(0, Math.min(index, this.topIndex()));
            while (this.topIndex() > target) {
              await this.pop();
            }
          }

          /** 销毁：逆序卸载所有屏幕并清空栈 */
          destroy() {
            for (let i = this.stack.length - 1; i >= 0; i--) {
              const it = this.stack[i];
              try {
                it.screen?.unmount?.();
              } catch {}
              try {
                it.wrap?.remove?.();
              } catch {}
            }
            this.stack = [];
          }
        }

        /* ----------------- TabsView（根屏：保留你原样式与交互） ----------------- */
        // ===================== TabsView（数据驱动，保留你所有样式与交互） =====================
        class TabsView {
          constructor({ login, onOpenChat, onOpenSpace, onLoginChanged } = {}) {
            this.key = 'tabs';
            this.keepAlive = true;
            this.login = login; // 当前账号，用于数据订阅
            this.onOpenChat = onOpenChat; // 外壳回调：打开聊天
            this.onOpenSpace = onOpenSpace; // 外壳回调：打开空间
            this.onLoginChanged = onLoginChanged;
            this.root = null; // mount 后赋值
            this._onResize = null;
            this._qa = null; // 右上角 + 菜单引用
            this._unsubTabs = null; // 数据订阅取消函数
          }

          mount(container) {
            this.root = container;
            this.root.innerHTML = `
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css"
    crossorigin="anonymous" referrerpolicy="no-referrer">
  <link rel="stylesheet" href="https://cdn-uicons.flaticon.com/3.0.0/uicons-regular-rounded/css/uicons-regular-rounded.css">
  <link rel="stylesheet" href="https://cdn-uicons.flaticon.com/3.0.0/uicons-solid-rounded/css/uicons-solid-rounded.css">
  <link rel="stylesheet" href="https://cdn-uicons.flaticon.com/3.0.0/uicons-thin-rounded/css/uicons-thin-rounded.css">
  <link rel="stylesheet" href="https://cdn-uicons.flaticon.com/3.0.0/uicons-thin-chubby/css/uicons-thin-chubby.css">
  <link rel="stylesheet" href="https://cdn-uicons.flaticon.com/3.0.0/uicons-regular-chubby/css/uicons-regular-chubby.css">
  <link rel='stylesheet' href='https://cdn-uicons.flaticon.com/3.0.0/uicons-solid-rounded/css/uicons-solid-rounded.css'>
  <style>
    :host{display:block;height:100%} *{box-sizing:border-box;}

    .qq-wrap{
      --accent:#2b84ff;
      --tabbar-h: 7%;
      --island-clearance: 10%;
      --bg-white:#fff;
      --bg-tint:#f2f4f7;
      --line:#e8ecf2;
      --text:#111;
      position:absolute; inset:0;
      font:12px/1.35 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;
      user-select:none; -webkit-user-select:none;
      -webkit-touch-callout:none; touch-action: pan-y;
      color:var(--text);
    }

    .pages{ position:absolute; inset:0; overflow:hidden; }
    .track{ height:100%; width:300%; display:flex; transform:translate3d(0,0,0); transition:transform .28s cubic-bezier(.4,0,.2,1); }
    .page{ flex:0 0 33.3333%; overflow:auto; background:var(--bg-white); }
    .page::-webkit-scrollbar{ width:0; height:0; }

    .topbar{
      position:sticky; top:0; z-index:5;
      background:rgba(242,244,247,.96);
      backdrop-filter:saturate(160%) blur(10px);
      border-bottom:1px solid var(--line);
      padding: calc(env(safe-area-inset-top, 0px) + var(--island-clearance)) 12px 4px;
    }
    .topline{ display:flex; align-items:center; justify-content:space-between; }
    .top-left{ display:flex; align-items:center; gap:8px; min-width:0; }
    .avatar{ width:24px; height:24px; border-radius:50%; background:#dfe3ea; flex:0 0 auto; }
    .topbar .avatar{ position:relative; }
    .uinfo{ display:flex; flex-direction:column; min-width:0; }
    .name{ font-weight:600; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .online{ display:flex; align-items:center; gap:6px; font-size:10px; color:#6b7280; }
    .dot{ width:6px; height:6px; border-radius:50%; background:#22c55e; box-shadow:0 0 0 2px var(--bg-tint) inset; }
    .top-btn{
      border:0; background:transparent; width:28px; height:28px; border-radius:8px;
      display:grid; place-items:center; font-size:16px; color:#000; -webkit-tap-highlight-color:transparent;
    }
    .top-btn:active{ background:rgba(0,0,0,.06); }
    .top-right{ display:flex; align-items:center; }
    #drawer .account .avatar{ width:44px; height:44px; }



    .searchbar{
      position:relative;
      margin:6px auto 6px; width:92%;
      height:28px; border-radius:10px;
      background:#f7f8fb; border:1px solid #eef1f5;
      display:flex; align-items:center; justify-content:center;
    }
    .searchbar input{ flex:1; width:100%; height:100%; border:none; outline:none; background:transparent; font-size:12.5px; color:#111; padding:0 10px; }
    .searchbar .hint{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; gap:6px; color:#9aa3ad; font-size:12.5px; pointer-events:none; transition:opacity .15s ease; }
    .searchbar .hint i{ font-size:13px; }
    .searchbar.focused .hint, .searchbar.not-empty .hint{ opacity:0; }

    .list{ flex:1; overflow:auto; }
    .list::-webkit-scrollbar{ width:0; height:0; }
    .list::after{ content:""; display:block; height: calc(var(--tabbar-h) + 10px); }

    .items{ list-style:none; margin:0; padding:0; }

    .item{ position:relative; overflow:hidden; background:#fff; }
    .item + .item{ border-top:1px solid #f0f2f5; }
    .row{ position:relative; overflow:hidden; width:100%; }
    .cell{
      width:100%;
      display:flex; gap:8px; align-items:flex-start;
      padding:7px 12px; background:#fff;
      position:relative; z-index:1;
      transform: translateX(0);
      transition: transform .2s cubic-bezier(.4,0,.2,1);
      will-change: transform;
    }
    .item.pinned .cell{ background:#f2f4f7; }
    .ava{ width:34px; height:34px; border-radius:999px; background:#eef2f7; flex:0 0 auto; position:relative; overflow:visible; }
    .meta{ flex:1; min-width:0; }
    .row1{ display:flex; align-items:baseline; justify-content:space-between; gap:6px; }
    .title{ font-weight:600; font-size:13px; min-width:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .time{ font-size:10px; color:#9aa3ad; white-space:nowrap; }
    .row2{ margin-top:1px; font-size:11.5px; color:#6b7280; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

    .actions{
      position:absolute; top:0; left:100%; height:100%;
      width: calc(100% * var(--action-frac, .56));
      display:flex; z-index:0;
      transform: translateX(calc(-1 * var(--reveal, 0px)));
      transition: transform .2s cubic-bezier(.4,0,.2,1);
    }
    .action{ border:0; outline:0; margin:0; display:flex; align-items:center; justify-content:center; color:#fff; font-size:12px; font-weight:700; }
    .action:nth-child(1){ flex: var(--w1, .333) 0 0; }
    .action:nth-child(2){ flex: var(--w2, .333) 0 0; }
    .action:nth-child(3){ flex: var(--w3, .333) 0 0; }

    .action.pin{    background:#2b84ff; }
    .action.unread{ background:#ffb11a; }
    .action.del{    background:#ff4d4f; }

    .row .cell{ touch-action: pan-y; }

    .ct-tabs{ display:flex; gap:8px; padding:8px 12px 6px; border-top:8px solid #f6f7fa; border-bottom:6px solid #f6f7fa; overflow-x:auto; }
    .ct-tabs::-webkit-scrollbar{ height:0; }
    .ct-tab{ padding:6px 10px; border-radius:999px; background:#f7f8fb; border:1px solid #eef1f5; color:#4b5563; font-size:12px; white-space:nowrap; }
    .ct-tab:active{ transform:scale(.98); }
    .ct-tab.active{ background:#e8f1ff; border-color:#cfe3ff; color:#2b84ff; font-weight:600; }

    .tabbar{
      position:absolute; left:0; right:0; bottom:0; height:var(--tabbar-h);
      background:rgba(242,244,247,.78); min-height:50px;
      backdrop-filter:saturate(160%) blur(10px);
      border-top:1px solid var(--line);
      display:flex; align-items:stretch;
      padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
    }
    .tab{ position:relative; flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; color:#4b5563; border:0; background:transparent; }
    .tab:active{ transform:scale(.98); }
    .icon-wrap{ position:relative; height:18px; display:flex; align-items:flex-end; justify-content:center; }
    .tab i{ font-size:15px; line-height:1; }
    .tab .label{ font-size:10px; }
    .tab .icon-on{ display:none; }
    .tab.active .icon-on{ display:inline-block; }
    .tab.active .icon-off{ display:none; }
    .tab.active{ color:var(--accent); font-weight:600; }
    .tab--feed .icon-wrap {transform: translateY(2px);}
    .badge{ position:absolute; right:-2px; top:-2px; width:10px; height:10px; border-radius:999px; background:#ff3b30; color:#fff; font-size:9px; line-height:10px; display:none; align-items:center; justify-content:center; }
    .badge.show{ display:flex; }
    .ava > .badge{ width:10px; height:10px; top:-4px; right:-4px; line-height:10px; font-size:8px; }
    .tab .badge{ right:-2px; top:-2px; }
    .tab .icon-wrap > .badge{ right:-2px; top:-2px; }

    .mask{ position:absolute; inset:0; background:rgba(0,0,0,.5); opacity:0; pointer-events:none; transition:opacity .2s ease; z-index:55; }
    .drawer{ position:absolute; left:0; top:0; bottom:0; width:88%; max-width:320px; background:#fff;
      box-shadow: 2px 0 16px rgba(0,0,0,.2); transform:translateX(-100%); will-change:transform; z-index:60; touch-action: pan-y;
      display:flex; flex-direction:column; color:#000;
    }
    .drawer-scroll{ flex:1; overflow:auto; padding-top:12px; }
    .drawer-scroll::-webkit-scrollbar{ width:0; height:0; }

    .account{ margin:20% 12px 12px; padding:12px; border:1px solid var(--line); border-radius:14px; background:#fff; }
    .account-top{ display:flex; gap:10px; align-items:center; }
    .acc-right{ flex:1; min-width:0; }
    .acc-headline{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .acc-name{ font-weight:700; font-size:14px; min-width:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .switch-btn{ display:inline-flex; align-items:center; gap:4px; padding:4px 8px; font-size:12px; border-radius:999px; border:1px solid var(--line); background:#fff; color:#374151; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .switch-btn i{ font-size:14px; transform: translateY(2px); }
    .acc-sign{ margin-top:2px; font-size:12px; color:#6b7280; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .acc-tags{ margin-top:8px; display:flex; align-items:center; gap:6px; flex-wrap:wrap; font-size:11px; }
    .tag{ padding:2px 6px; border-radius:999px; background:#f7f8fb; border:1px solid #eef1f5; color:#6b7280; }
    .tag.vip{ background:#fff7dc; border-color:#ffe8a6; color:#a87300; }
    .tag.crown{ background:#fff3d6; border-color:#ffd889; color:#b67b00; }
    .tag.star{ background:#f7fbff; border-color:#d8e9ff; color:#2b84ff; }

    .func{ margin:0 8px 8px; background:#fff; border:1px solid var(--line); border-radius:14px; overflow:hidden; }
    .func-item{ display:flex; align-items:center; gap:10px; padding:9px 12px; }
    .func-item + .func-item{ border-top:1px solid #f0f2f5; }
    .func-item i{ font-size:17px; transform: translateY(1.5px);} 
    .func-item .label{ font-size:13px; flex:1; }

    .drawer-bottom{ position:relative; padding:5px 12px 14px; border-top:1px solid var(--line);
      display:flex; gap:22px; align-items:flex-end; color:#4b5563;}
    .mini{ display:flex; flex-direction:column; align-items:center; gap:4px; font-size:11px; }
    .mini i{ font-size:18px; color:#374151; transform: translateY(5px);} 

    .edge{ position:absolute; left:0; top:0; bottom: var(--tabbar-h); width:44px; z-index:90; touch-action: none; -webkit-tap-highlight-color: transparent; }

    /* ============ 新增：右上角“+”弹出小组件 ============ */
    .qa-menu{
      position:absolute;
      right:8px;
      top: calc(100% + 6px);
      width:45%;
      background:#fff;
      border:1px solid var(--line);
      border-radius:14px;
      box-shadow:0 10px 24px rgba(0,0,0,.14);
      padding:6px 0;
      z-index:9;
      transform-origin: top right;
      transform: translateY(-8px) scale(.98);
      opacity:0; visibility:hidden;
      transition: transform .18s cubic-bezier(.4,0,.2,1), opacity .18s cubic-bezier(.4,0,.2,1), visibility .18s steps(1,end);
    }
    .qa-menu.show{ transform: translateY(0) scale(1); opacity:1; visibility:visible; }
    .qa-item{
      width:100%; border:0; background:transparent; text-align:left;
      display:flex; align-items:center; gap:12px; padding:10px 12px; font-size:13px; color:#111;
    }
    .qa-item i{ font-size:18px; width:20px; text-align:center; transform: translateY(3px); }
    .qa-item:active{ background:#f6f7fa; }
    /* ============ 新增结束 ============ */
    /* ============ 新增：抽屉里的“切换账号”弹窗 ============ */
.acc-headline{ position:relative; } /* 让弹窗靠它定位 */

.acc-switch{
  position:absolute;
  right:0;
  top: calc(100% + 6px);
  width:50%;                 /* 按你要求的 50% 宽 */
  min-width:140px;
  background:#fff;
  border:1px solid var(--line);
  border-radius:12px;
  box-shadow:0 10px 24px rgba(0,0,0,.14);
  padding:6px 0;
  z-index:9;
  transform-origin: top right;
  transform: translateY(-8px) scale(.98);
  opacity:0; visibility:hidden;
  transition: transform .18s cubic-bezier(.4,0,.2,1), opacity .18s cubic-bezier(.4,0,.2,1), visibility .18s steps(1,end);
  overflow:hidden;           /* 边角圆润不外露 */
}

.acc-switch.show{ transform: translateY(0) scale(1); opacity:1; visibility:visible; }

.acc-switch-scroll{
  max-height:50vh;           /* 可滚动区域高度 */
  overflow:auto;
  -webkit-overflow-scrolling: touch; /* 手机手指上下滑 */
}

.acc-item{
  width:100%;
  border:0; background:transparent;
  display:flex; align-items:center; gap:10px;
  padding:8px 10px; text-align:left;
  font-size:13px; color:#111;
}
.acc-item:active{ background:#f6f7fa; }
.acc-item .head{
  width:28px; height:28px; border-radius:999px; position: relative;
  background:#e9eef6 center/cover no-repeat;
  flex:0 0 auto;
}
.acc-item .name{
  flex:1; min-width:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}
.acc-item .check{
  font-size:16px; color:#2b84ff;   /* 蓝色 ✓ */
  visibility:hidden;
}
.acc-item.active .check{ visibility:visible; }

.acc-new{
  width:100%;
  display:flex; align-items:center; gap:10px;
  border:0; background:transparent;
  padding:10px; border-top:1px solid var(--line);
  font-size:13px; color:#111;
}
.acc-new:active{ background:#f6f7fa; }
.acc-new .round{
  width:26px; height:26px; border-radius:999px;
  border:1px dashed #9aa3ad;
  display:grid; place-items:center; color:#6b7280;
  flex:0 0 auto;
}
.acc-new i{ font-size:18px; transform: translateY(2px); }
/* ============ 通用弹窗（添加账号 / 加好友） ============ */
.qq-modal-mask{ position:absolute; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:95; }
.qq-modal-mask.show{ display:flex; }
.qq-modal{ width:86%; max-width:340px; background:#fff; border:1px solid var(--line); border-radius:14px; box-shadow:0 10px 24px rgba(0,0,0,.2); padding:12px; }
.qq-modal .title{ font-weight:700; font-size:14px; margin-bottom:8px; }
.qq-field{ display:flex; flex-direction:column; gap:6px; margin:8px 0; }
.qq-field label{ font-size:12px; color:#6b7280; }
.qq-field input{ height:32px; border:1px solid #eef1f5; border-radius:8px; padding:0 10px; outline:none; font-size:13px; background:#fff; color:#111; }
.qq-actions{ display:flex; justify-content:flex-end; gap:8px; margin-top:10px; }
.qq-btn{ border:1px solid var(--line); background:#fff; border-radius:10px; padding:6px 10px; font-size:12px; }
.qq-btn.primary{ background:#2b84ff; color:#fff; border-color:#2b84ff; }
.qq-error{ color:#ff4d4f; font-size:12px; min-height:1.2em; }
  </style>

  <div class="qq-wrap" id="qq">
    <div class="mask" id="mask"></div>

    <div class="drawer" id="drawer" aria-label="个人账号页" role="dialog">
      <div class="drawer-scroll">
        <section class="account">
          <div class="account-top">
  <div class="avatar" id="avatar"></div>
  <div class="acc-right">
    <div class="acc-headline">
      <div class="acc-name">落水的林维</div>
      <button class="switch-btn"><i class="fi fi-rr-exchange"></i><span>切换账号</span></button>

      <!-- 新增：账号切换弹窗 -->
      <div class="acc-switch" id="accSwitch" role="menu" aria-hidden="true">
        <div class="acc-switch-scroll" id="accSwitchList">
          <!-- 这里由 JS 填充账号项 -->
        </div>
        <button class="acc-new" id="accSwitchNew">
          <div class="round"><i class="fi fi-rr-plus-small"></i></div>
          <span>登录新账户</span>
        </button>
      </div>
      <!-- 新增结束 -->
    </div>
    <div class="acc-sign">编辑个签，展示我的独特态度。</div>
  </div>
</div>
          <div class="acc-tags">
            <span class="tag vip">年SVIP8</span>
            <span class="tag crown"><i class="fi fi-rr-crown"></i> 特权</span>
            <span class="tag star">⭐️⭐️⭐️⭐️⭐️</span>
          </div>
        </section>

        <nav class="func" aria-label="功能列表">
          <div class="func-item">
            <i class="fi fi-rr-picture" style="color:#f2b91e"></i>
            <span class="label">相册</span>
            <i class="fi fi-rr-angle-small-right chev gray"></i>
          </div>
          <div class="func-item">
            <i class="fi fi-rr-wishlist-star" style="color:#2b84ff"></i>
            <span class="label">收藏</span>
            <i class="fi fi-rr-angle-small-right chev gray"></i>
          </div>
          <div class="func-item">
            <i class="fi fi-rr-folder" style="color:#2b84ff"></i>
            <span class="label">文件</span>
            <i class="fi fi-rr-angle-small-right chev gray"></i>
          </div>
          <div class="func-item">
            <i class="fi fi-rr-wallet" style="color:#2b84ff"></i>
            <span class="label">钱包</span>
            <i class="fi fi-rr-angle-small-right chev gray"></i>
          </div>
          <div class="func-item">
            <i class="fi fi-rr-crown" style="color:#ff4d4f"></i>
            <span class="label">会员中心</span>
            <i class="fi fi-rr-angle-small-right chev gray"></i>
          </div>
          <div class="func-item">
            <i class="fi fi-rr-tshirt" style="color:#ff4d4f"></i>
            <span class="label">个性装扮</span>
            <i class="fi fi-rr-angle-small-right chev gray"></i>
          </div>
          <div class="func-item">
            <i class="fi fi-rr-broadcast-tower" style="color:#22c55e"></i>
            <span class="label">免流量</span>
            <i class="fi fi-rr-angle-small-right chev gray"></i>
          </div>
        </nav>
      </div>

      <div class="drawer-bottom">
        <div class="mini"><i class="fi fi-tc-settings"></i><span>设置</span></div>
        <div class="mini"><i class="fi fi-tc-moon"></i><span>夜间</span></div>
        <div class="mini"><i class="fi fi-tr-cloud-sun"></i><span>天气</span></div>
      </div>
    </div>
    <!-- 添加账号弹窗 -->
<div class="qq-modal-mask" id="dlgAddAccount" aria-hidden="true">
  <div class="qq-modal" role="dialog" aria-label="添加账号">
    <div class="title">添加账号</div>
    <div class="qq-field">
      <label>名字</label>
      <input id="accAddName" placeholder="例如：小明">
    </div>
    <div class="qq-field">
      <label>头像 URL（可空）</label>
      <input id="accAddAvatar" placeholder="https://...">
    </div>
    <div class="qq-error" id="accAddErr"></div>
    <div class="qq-actions">
      <button class="qq-btn" id="accAddCancel">取消</button>
      <button class="qq-btn primary" id="accAddOK">确定</button>
    </div>
  </div>
</div>

<!-- 加好友弹窗 -->
<div class="qq-modal-mask" id="dlgAddFriend" aria-hidden="true">
  <div class="qq-modal" role="dialog" aria-label="加好友">
    <div class="title">加好友</div>
    <div class="qq-field">
      <label>好友名字</label>
      <input id="frAddName" placeholder="例如：阿土">
    </div>
    <div class="qq-field">
      <label>头像 URL（可空）</label>
      <input id="frAddAvatar" placeholder="https://...">
    </div>
    <div class="qq-error" id="frAddErr"></div>
    <div class="qq-actions">
      <button class="qq-btn" id="frAddCancel">取消</button>
      <button class="qq-btn primary" id="frAddOK">确定</button>
    </div>
  </div>
</div>
<!-- 创建群聊弹窗 -->
<div class="qq-modal-mask" id="dlgCreateGroup" aria-hidden="true">
  <div class="qq-modal" role="dialog" aria-label="创建群聊">
    <div class="title">创建群聊</div>

    <div class="qq-field">
      <label>群聊名</label>
      <input id="grpName" placeholder="比如：我们的快乐老家">
    </div>

    <div class="qq-field">
      <label>群头像 URL（可空）</label>
      <input id="grpAvatar" placeholder="https://">
    </div>

    <div class="qq-field">
      <label>搜索好友</label>
      <input id="grpSearch" placeholder="输入名字筛选">
    </div>

    <!-- 滚动好友列表 -->
    <div id="grpFriendList"
         style="max-height:200px; overflow:auto; border:1px solid #eef1f5; border-radius:10px; padding:6px; display:flex; flex-direction:column; gap:6px;"
         aria-label="好友列表（可多选）">
    </div>

    <div class="qq-error" id="grpErr"></div>

    <div class="qq-actions">
      <button class="qq-btn" id="grpCancel">取消</button>
      <button class="qq-btn primary" id="grpOK">确定</button>
    </div>
  </div>
</div>
    <div class="edge" id="edge"></div>

    <!-- 三页 -->
    <div class="pages">
      <div class="track" id="track">
        <!-- 消息 -->
        <section class="page page--chats">
          <header class="topbar">
            <div class="topline">
              <div class="top-left">
                <div class="avatar" id="tbarAvatar" title="打开侧边栏"></div>
                <div class="uinfo">
                  <div class="name">落水的林维</div>
                  <div class="online"><span class="dot"></span><span>iPhone 15 Plus 在线</span></div>
                </div>
              </div>
              <button class="top-btn" aria-label="新建"><i class="fi fi-rr-plus"></i></button>
              <div class="qa-menu" role="menu">
  <button class="qa-item" data-act="create-group"><i class="fi fi-rr-comment-medical"></i><span>创建群聊</span></button>
  <button class="qa-item" data-act="create-channel"><i class="fi fi-rc-hashtag"></i><span>创建频道</span></button>
  <button class="qa-item" data-act="add-friend"><i class="fi fi-rr-user-add"></i><span>加好友</span></button>
  <button class="qa-item" data-act="scan"><i class="fi fi-rr-qr-scan"></i><span>扫一扫</span></button>
  <button class="qa-item" data-act="file"><i class="fi fi-rr-move-to-folder-2"></i><span>传文件</span></button>
  <button class="qa-item" data-act="pay"><i class="fi fi-rr-barcode-scan"></i><span>收付款</span></button>
</div>
            </div>
          </header>

          <main class="list" aria-label="消息列表">
            <div class="searchbar" role="search">
              <div class="hint"><i class="fi fi-rr-search"></i><span>搜索对话/内容</span></div>
              <input aria-label="搜索对话/内容">
            </div>
            <ul class="items" id="chatList"><!-- 数据订阅后会填充 --></ul>
          </main>
        </section>

        <!-- 联系人 -->
        <section class="page page--contacts">
          <header class="topbar">
            <div class="topline">
              <div class="top-left">
                <div class="avatar" title="打开侧边栏"></div>
                <div class="uinfo"><div class="name">联系人</div></div>
              </div>
              <button class="top-btn" aria-label="添加联系人"><i class="fi fi-rr-user-add"></i></button>
            </div>
          </header>

          <main class="list" aria-label="联系人列表">
            <div class="searchbar" role="search">
              <div class="hint"><i class="fi fi-rr-search"></i><span>搜索联系人/群聊</span></div>
              <input aria-label="搜索联系人/群聊">
            </div>

            <ul class="items" id="ctTop">
              <li class="item">
                <div class="row" style="--action-frac:0">
                  <div class="cell">
                    <div class="meta">
                      <div class="row1"><div class="title">新朋友</div><i class="fi fi-rr-angle-small-right chev"></i></div>
                    </div>
                  </div>
                  <div class="actions" aria-hidden="true"></div>
                </div>
              </li>
              <li class="item">
                <div class="row" style="--action-frac:0">
                  <div class="cell">
                    <div class="meta">
                      <div class="row1"><div class="title">群通知</div><i class="fi fi-rr-angle-small-right chev"></i></div>
                    </div>
                  </div>
                  <div class="actions" aria-hidden="true"></div>
                </div>
              </li>
            </ul>

            <div class="ct-tabs" id="ctTabs" role="tablist">
              <button class="ct-tab" data-type="groups">分组</button>
              <button class="ct-tab active" data-type="friends">好友</button>
              <button class="ct-tab" data-type="groupchats">群聊</button>
              <button class="ct-tab" data-type="channels">频道</button>
              <button class="ct-tab" data-type="bots">机器人</button>
              <button class="ct-tab" data-type="devices">设备</button>
            </div>

            <ul class="items" id="ctContainer"></ul>
          </main>
        </section>

        <!-- 动态 -->
        <section class="page page--feed">
          <header class="topbar">
            <div class="topline">
              <div class="top-left">
                <div class="avatar"></div>
                <div class="uinfo"><div class="name">动态</div></div>
              </div>
              <div class="top-right">
                <button class="top-btn" aria-label="分类"><i class="fi fi-rc-category fi-rr-apps"></i></button>
                <button class="top-btn" aria-label="设置"><i class="fi fi-rc-settings fi-rr-settings"></i></button>
              </div>
            </div>
          </header>

          <main class="list" aria-label="动态列表">
            <div class="searchbar" role="search">
              <div class="hint"><i class="fi fi-rr-search"></i><span>搜索动态入口</span></div>
              <input aria-label="搜索动态入口">
            </div>
            <nav class="func" aria-label="动态入口" id="feedNav">
              <div class="func-item" id="openSpaceEntry">
                <i class="fi fi-rr-stars" style="color:#f2b91e"></i>
                <span class="label">空间动态</span>
                <i class="fi fi-rr-angle-small-right chev"></i>
              </div>
            </nav>
          </main>
        </section>
      </div>
    </div>

    <nav class="tabbar" id="tabbar" aria-label="底部导航">
      <button class="tab active" data-tab="0" aria-label="消息">
        <span class="icon-wrap">
          <i class="fa-regular fa-comment-dots icon-off"></i>
          <i class="fa-solid   fa-comment-dots icon-on"></i>
        </span>
        <span class="label">消息</span>
        <span class="badge" id="tabBadge">1</span>
      </button>
      <button class="tab" data-tab="1" aria-label="联系人">
        <span class="icon-wrap">
          <i class="fa-regular fa-user icon-off"></i>
          <i class="fa-solid   fa-user icon-on"></i>
        </span>
        <span class="label">联系人</span>
      </button>
      <button class="tab tab--feed" data-tab="2" aria-label="动态">
        <span class="icon-wrap">
          <i class="fi fi-rr-world icon-off"></i>
          <i class="fi fi-sr-world icon-on"></i>
        </span>
        <span class="label">动态</span>
      </button>
    </nav>
  </div>
      `;

            // ——— 下面交互逻辑与你版本一致，仅作用域指向 this.root ———
            const $ = s => this.root.querySelector(s);
            const $$ = s => Array.from(this.root.querySelectorAll(s));
            // NEW: 用当前登录名覆盖界面里的占位名
            const loginName = this.login && String(this.login).trim() ? this.login.trim() : '{{user}}';

            // 消息页顶栏用户名
            const chatTopName = this.root.querySelector('.page--chats .topbar .top-left .uinfo .name');
            if (chatTopName) chatTopName.textContent = loginName;

            // 抽屉名片用户名
            const drawerAccName = this.root.querySelector('.drawer .account .acc-name');
            if (drawerAccName) drawerAccName.textContent = loginName;

            const wrap = $('#qq');
            const track = $('#track');
            const tabs = $$('.tabbar .tab');
            const tabbar = $('#tabbar');
            const drawer = $('#drawer');
            const mask = $('#mask');
            const edge = $('#edge');
            // 让左侧拖拽热区 .edge 从“顶栏底部”开始，避免盖住顶栏头像
            const placeEdgeBelowTopbar = () => {
              const bars = Array.from(this.root.querySelectorAll('.topbar'));
              const topH = bars.reduce((m, el) => Math.max(m, el.getBoundingClientRect().height || 0), 0);
              edge.style.top = `${topH}px`; // 关键：把 .edge 的 top 往下挪
            };
            placeEdgeBelowTopbar();
            window.addEventListener('resize', placeEdgeBelowTopbar);
            this._edgeReflow = placeEdgeBelowTopbar; // 卸载时清理

            const avatar = $('#avatar');
            const tbarAvatar =
              this.root.querySelector('#tbarAvatar') || this.root.querySelector('.page--chats .avatar');

            // 三页切换
            let current = 0;
            const setTab = (i, animate = true) => {
              current = Math.max(0, Math.min(2, i));
              track.style.transition = animate ? 'transform .28s cubic-bezier(.4,0,.2,1)' : 'none';
              track.style.transform = `translate3d(${-current * 33.3333}%,0,0)`;
              tabs.forEach((t, idx) => t.classList.toggle('active', idx === current));
            };
            setTab(0, false);
            tabs.forEach(btn => {
              let pid = null,
                sx = 0,
                sy = 0,
                moved = false;
              const down = e => {
                pid = e.pointerId;
                sx = e.clientX;
                sy = e.clientY;
                moved = false;
                btn.setPointerCapture?.(pid);
              };
              const move = e => {
                if (pid == null) return;
                if (Math.abs(e.clientX - sx) > 6 || Math.abs(e.clientY - sy) > 6) moved = true;
              };
              const up = e => {
                if (pid != null) {
                  try {
                    btn.releasePointerCapture(pid);
                  } catch {}
                }
                if (!moved) setTab(parseInt(btn.dataset.tab, 10), true);
                pid = null;
                moved = false;
              };
              btn.addEventListener('pointerdown', down);
              btn.addEventListener('pointermove', move, { passive: true });
              btn.addEventListener('pointerup', up);
              btn.addEventListener('pointercancel', up);
              btn.addEventListener('lostpointercapture', up);
            });

            // 抽屉
            let dragging = false,
              lock = null,
              pid = null,
              sx = 0,
              sy = 0,
              startFrac = 0,
              width = 0,
              progress = 0;
            const getW = () => drawer.getBoundingClientRect().width;
            const renderDrawer = f => {
              progress = Math.max(0, Math.min(1, f));
              const x = -getW() + progress * getW();
              drawer.style.transform = `translateX(${x}px)`;
              mask.style.opacity = progress * 0.6;
              mask.style.pointerEvents = progress > 0 ? 'auto' : 'none';
            };
            const openDrawer = () => {
              drawer.style.transition = 'transform .24s cubic-bezier(.4,0,.2,1)';
              renderDrawer(1);
              setTimeout(() => {
                drawer.style.transition = 'none';
              }, 240);
            };
            const closeDrawer = () => {
              drawer.style.transition = 'transform .24s cubic-bezier(.4,0,.2,1)';
              renderDrawer(0);
              setTimeout(() => {
                drawer.style.transition = 'none';
              }, 240);
            };

            const startDrag = (e, capTarget = edge) => {
              pid = e.pointerId ?? 9999;
              width = getW();
              dragging = true;
              lock = null;
              sx = e.clientX;
              sy = e.clientY;
              startFrac = progress;
              drawer.style.transition = 'none';
              mask.style.transition = 'none';
              capTarget && capTarget.setPointerCapture && capTarget.setPointerCapture(pid);
            };
            const moveDrag = e => {
              if (!dragging) return;
              const dx = e.clientX - sx,
                dy = e.clientY - sy;
              if (lock == null && (Math.abs(dx) > 10 || Math.abs(dy) > 10)) {
                lock = Math.abs(dx) >= Math.abs(dy) ? 'x' : 'y';
              }
              if (lock === 'y') return;
              if (lock === 'x') {
                e.preventDefault && e.preventDefault();
                const px = Math.max(0, Math.min(width, startFrac * width + dx));
                renderDrawer(px / width);
              }
            };
            const endDrag = e => {
              progress >= 0.5 ? openDrawer() : closeDrawer();
              if (e?.target?.releasePointerCapture)
                try {
                  e.target.releasePointerCapture(pid);
                } catch {}
              dragging = false;
              pid = null;
              lock = null;
              mask.style.transition = 'opacity .2s ease';
            };

            edge.addEventListener('pointerdown', e => {
              const rect = wrap.getBoundingClientRect();
              const y = e.clientY - rect.top;
              const btmH = tabbar.getBoundingClientRect().height || rect.height * 0.07;
              const topH = Math.max(
                ...Array.from(this.root.querySelectorAll('.topbar')).map(b => b.getBoundingClientRect().height || 0),
                0,
              );
              if (y <= topH) return; // 顶栏区域：不给 edge 抢事件
              if (y >= rect.height - btmH) return; // 底栏区域：不给 edge 抢事件
              startDrag(e, edge);
            });
            edge.addEventListener('pointermove', moveDrag);
            edge.addEventListener('pointerup', endDrag);
            edge.addEventListener('pointercancel', endDrag);
            edge.addEventListener('lostpointercapture', endDrag);
            mask.addEventListener('pointerdown', e => startDrag(e, mask));
            mask.addEventListener('pointermove', moveDrag);
            mask.addEventListener('pointerup', endDrag);
            mask.addEventListener('pointercancel', endDrag);
            mask.addEventListener('lostpointercapture', endDrag);
            mask.addEventListener('click', () => closeDrawer());
            // 只允许在抽屉的“右边缘 24px”起拖，且避开交互区（切换账号按钮/弹窗）
            const START_ZONE = 56;

            drawer.addEventListener('pointerdown', e => {
              const inNoDragArea =
                e.target.closest('.switch-btn') || // 你的“切换账号”按钮
                e.target.closest('#accSwitch'); // 账户弹窗本体

              if (inNoDragArea) return; // 在交互区：不进入拖拽

              const rect = drawer.getBoundingClientRect();
              const isInRightEdge = rect.right - e.clientX <= START_ZONE;
              if (!isInRightEdge) return; // 不是右边缘：不进入拖拽

              startDrag(e, drawer);
            });

            drawer.addEventListener('pointermove', moveDrag);
            drawer.addEventListener('pointerup', endDrag);
            drawer.addEventListener('pointercancel', endDrag);
            drawer.addEventListener('lostpointercapture', endDrag);

            avatar.addEventListener('click', openDrawer);
            tbarAvatar?.addEventListener('click', openDrawer);
            this.root.querySelector('.page--contacts .topbar .avatar')?.addEventListener('click', openDrawer);
            this.root.querySelector('.page--feed .topbar .avatar')?.addEventListener('click', openDrawer);

            renderDrawer(0);

            /* ========= 抽屉里的“切换账号”弹窗：数据 + 交互（已改：同时读取 WB 登录人） ========= */
            /* ========= 抽屉里的“切换账号”弹窗：添加账号 + 切换账号 ========= */
            (() => {
              const switchBtn = this.root.querySelector('.switch-btn');
              const accSwitch = this.root.querySelector('#accSwitch');
              const accList = this.root.querySelector('#accSwitchList');
              const accNewBtn = this.root.querySelector('#accSwitchNew');
              const drawerScroll = this.root.querySelector('.drawer-scroll');

              const FALLBACK = 'https://files.catbox.moe/pcwffp.jpg';

              // 弹窗引用（添加账号）
              const dlgAcc = this.root.querySelector('#dlgAddAccount');
              const accName = this.root.querySelector('#accAddName');
              const accAva = this.root.querySelector('#accAddAvatar');
              const accErr = this.root.querySelector('#accAddErr');
              const accOK = this.root.querySelector('#accAddOK');
              const accCancel = this.root.querySelector('#accAddCancel');

              // 小工具：弹窗显隐
              const showMask = el => {
                el.classList.add('show');
                el.setAttribute('aria-hidden', 'false');
              };
              const hideMask = el => {
                el.classList.remove('show');
                el.setAttribute('aria-hidden', 'true');
              };

              // 重新订阅 Tabs（用于切账号）
              const resubscribeTabs = () => {
                const makeChatRow = (title, kind, preview) => {
                  const li = document.createElement('li');
                  li.className = 'item';
                  if (kind === 'group') li.dataset.kind = 'group';
                  li.innerHTML = `
        <div class="row" style="--action-frac:.56">
          <div class="cell">
            <div class="ava"></div>
            <div class="meta">
              <div class="row1"><div class="title"></div><time class="time">刚刚</time></div>
              <div class="row2"></div>
            </div>
          </div>
          <div class="actions">
            <button class="action pin">置顶</button>
            <button class="action unread">标为未读</button>
            <button class="action del">删除</button>
          </div>
        </div>`;
                  li.querySelector('.title').textContent = title || '';
                  li.querySelector('.row2').textContent = preview || (kind === 'group' ? '群聊' : '好友');
                  const ava = li.querySelector('.ava');
                  if (ava) {
                    const key = `${this.login}|${kind === 'group' ? 'group' : 'dm'}|${title || ''}`;
                    const url = this._avatarMap?.get(key) || FALLBACK;
                    ava.style.background = '#e9eef6';
                    ava.style.backgroundImage = `url('${url}')`;
                    ava.style.backgroundPosition = 'center';
                    ava.style.backgroundSize = 'cover';
                    ava.style.backgroundRepeat = 'no-repeat';
                  }
                  return li;
                };

                this._unsubTabs?.();
                const ul = this.root.querySelector('.page--chats #chatList');
                if (ul) ul.innerHTML = '';
                this._unsubTabs = RMQQ.Data.subscribeTabsSummaries({ login: this.login }, e => {
                  const ul2 = this.root.querySelector('.page--chats #chatList');
                  if (!ul2) return;
                  if (e.type === 'init') {
                    ul2.innerHTML = '';
                    for (const s of e.summaries) {
                      ul2.appendChild(makeChatRow(s.peer, s.kind, s.preview || (s.kind === 'group' ? '群聊' : '好友')));
                      setUnreadCount(ul2.lastElementChild, s.unreadCount || 0);
                    }
                    const binder = this.root.__rmqq?.attachSwipe;
                    if (typeof binder === 'function') {
                      ul2.querySelectorAll('.item').forEach(li => {
                        if (!li.__rmqqBound) {
                          binder(li);
                          li.__rmqqBound = true;
                        }
                      });
                      this.root.__rmqq?.refreshTabBadge?.();
                    }
                  } else if (e.type === 'patch') {
                    let li = Array.from(ul2.children).find(
                      x => x.querySelector('.title')?.textContent?.trim() === e.summary.peer,
                    );
                    if (!li) {
                      li = makeChatRow(
                        e.summary.peer,
                        e.summary.kind,
                        e.summary.preview || (e.summary.kind === 'group' ? '群聊' : '好友'),
                      );
                      ul2.appendChild(li);
                      const binder = this.root.__rmqq?.attachSwipe;
                      if (typeof binder === 'function') {
                        if (!li.__rmqqBound) {
                          binder(li);
                          li.__rmqqBound = true;
                        }
                      }
                    } else {
                      li.querySelector('.row2').textContent = e.summary.preview || '';
                      const t = li.querySelector('.time');
                      if (t) t.textContent = '刚刚';
                    }
                    setUnreadCount(li, (e.summary && e.summary.unreadCount) || 0);
                    this.root.__rmqq?.refreshTabBadge?.();
                  } else if (e.type === 'remove') {
                    // 找到标题匹配的行并移除
                    const li = Array.from(ul.children).find(
                      x => x.querySelector('.title')?.textContent?.trim() === e.summary.peer,
                    );
                    if (li) li.remove();
                    // 刷新底部角标
                    this.root.__rmqq?.refreshTabBadge?.();
                    // 联系人视图也可同步刷新（保险起见）
                    typeof renderContactsFromWB === 'function' && renderContactsFromWB('friends');
                  }
                });
              };

              // 账号列表（合并 ChatMessage 和 WB）
              const renderAccList = async () => {
                const qq = RMPhoneToChatMessage.getApp('qq') || { accounts: [] };
                const cmLogins = (Array.isArray(qq.accounts) ? qq.accounts : [])
                  .map(a => ((a && a.login) || '').trim())
                  .filter(Boolean);

                let wb = {};
                try {
                  wb = (await RMPhoneToWorldBook.getApp('qq')) || {};
                } catch {}
                const wbLoginObj = wb.login && typeof wb.login === 'object' ? wb.login : {};
                const wbLogins = Object.keys(wbLoginObj);

                const set = new Set([this.login, ...cmLogins, ...wbLogins].filter(Boolean));
                const allLogins = Array.from(set);

                const html =
                  allLogins
                    .map(login => {
                      const a1 = this._avatarMap?.get(`${login}|__self__`);
                      const a2 = wbLoginObj?.[login]?.avatar;
                      const avatar = a1 || a2 || FALLBACK;
                      const loginUnread = RMQQ.Data.getLoginUnreadTotal?.(login) || 0;
                      const active = login === this.login;
                      return `
        <button class="acc-item ${active ? 'active' : ''}" data-login="${login}">
          <div class="head" style="background-image:url('${avatar}')">${loginUnread>0?'<span class="badge show" aria-label="未读"></span>':''}</div>
          <div class="name">${login}</div>
          <i class="fi fi-rr-check check" aria-label="当前账号"></i>
        </button>`;
                    })
                    .join('') || `<div style="padding:10px; color:#6b7280; font-size:12px;">暂无账号</div>`;

                accList.innerHTML = html;
              };

              const showAcc = async e => {
                e?.stopPropagation?.();
                await renderAccList();
                accSwitch.classList.add('show');
                accSwitch.setAttribute('aria-hidden', 'false');
                this.root.addEventListener('pointerdown', onOutside, true);
                drawerScroll?.addEventListener('scroll', hideAcc, { passive: true, once: true });
              };
              const hideAcc = () => {
                accSwitch.classList.remove('show');
                accSwitch.setAttribute('aria-hidden', 'true');
                this.root.removeEventListener('pointerdown', onOutside, true);
              };
              const onOutside = e => {
                if (accSwitch.contains(e.target)) return;
                if (switchBtn.contains(e.target)) return;
                hideAcc();
              };
              const onToggle = e => {
                accSwitch.classList.contains('show') ? hideAcc() : void showAcc(e);
              };

              // 真·切换账号
              const switchLogin = async sel => {
                if (!sel || sel === this.login) {
                  hideAcc();
                  return;
                }
                this.login = sel;

                // 顶栏名字 / 抽屉名字
                const chatTopName = this.root.querySelector('.page--chats .topbar .top-left .uinfo .name');
                const drawerAccName = this.root.querySelector('.drawer .account .acc-name');
                if (chatTopName) chatTopName.textContent = sel;
                if (drawerAccName) drawerAccName.textContent = sel;

                // 重新同步 WB（拿到头像字典）
                const { wb, amap } = await (async () => {
                  const res = await (async () => {
                    // 复用你前面定义的工具
                    const { wb, amap } = await (async () =>
                      await (async () => await syncWBFromDataAndBuildAvatarMap(this.login))())();
                    return { wb, amap };
                  })();
                  return res;
                })();
                this._wbQQ = wb;
                this._avatarMap = amap;

                // 顶栏/抽屉头像
                const selfUrl = this._avatarMap.get(`${this.login}|__self__`) || FALLBACK;
                [
                  this.root.querySelector('#avatar'),
                  this.root.querySelector('#tbarAvatar'),
                  this.root.querySelector('.page--contacts .topbar .avatar'),
                  this.root.querySelector('.page--feed .topbar .avatar'),
                ]
                  .filter(Boolean)
                  .forEach(el => {
                    el.style.background = '#e9eef6';
                    el.style.backgroundImage = `url('${selfUrl}')`;
                    el.style.backgroundPosition = 'center';
                    el.style.backgroundSize = 'cover';
                    el.style.backgroundRepeat = 'no-repeat';
                  });

                  const tbar = this.root.querySelector('#tbarAvatar');
const applyOtherLoginDot = flag => {
  if (!tbar) return;
  let dot = tbar.querySelector('.badge');
  if (flag) {
    if (!dot) {
      dot = document.createElement('span');
      dot.className = 'badge show';
      dot.setAttribute('aria-label', '其他账号有未读');
      tbar.appendChild(dot);
    } else {
      dot.classList.add('show');
    }
  } else if (dot) {
    dot.classList.remove('show');
  }
};
this._offOtherUnread?.();
this._offOtherUnread = RMQQ.Data.subscribeAnyUnreadExceptLogin?.(
  { login: this.login },
  flag => applyOtherLoginDot(!!flag)
);

                // 重渲染联系人（默认“好友”）
                typeof renderContactsFromWB === 'function' && renderContactsFromWB('friends');

                // 重新订阅消息摘要
                resubscribeTabs();

                hideAcc();
              };

              const onListClick = e => {
                const btn = e.target.closest('.acc-item');
                if (!btn) return;
                const sel = btn.dataset.login || '';
                accList.querySelectorAll('.acc-item').forEach(x => x.classList.toggle('active', x === btn));
                switchLogin(sel);
              };

              // “登录新账户” → 打开弹窗
              const onNewClick = () => {
                accErr.textContent = '';
                accName.value = '';
                accAva.value = '';
                showMask(dlgAcc);
                this.onLoginChanged?.(sel); // ← 关键：通知外壳更新 this._login
                hideAcc();
              };

              // 弹窗按钮
              const doAddAccount = async () => {
                const name = (accName.value || '').trim();
                const url = (accAva.value || '').trim();
                if (!name) {
                  accErr.textContent = '请输入名字';
                  return;
                }

                // 2) 世界书：为该账号建节点 + 头像
                const wb = (await RMPhoneToWorldBook.getApp('qq').catch(() => ({}))) || {};
                wb.login ||= {};
                wb.login[name] ||= { avatar: url || FALLBACK, contacts: { friends: {}, groups: {} } };
                if (url) wb.login[name].avatar = url;
                await RMPhoneToWorldBook.saveApp('qq', wb);

                // 3) 刷新本地头像字典 / 账号列表
                const { wb: wb2, amap } = await (async () => await syncWBFromDataAndBuildAvatarMap(this.login))();
                this._wbQQ = wb2;
                this._avatarMap = amap;
                await renderAccList();

                hideMask(dlgAcc);
              };

              const onEsc = e => {
                if (e.key === 'Escape') {
                  hideAcc();
                  hideMask(dlgAcc);
                }
              };

              // 绑定
              switchBtn?.addEventListener('click', onToggle);
              switchBtn?.addEventListener('pointerdown', e => e.stopPropagation());
              switchBtn?.addEventListener('touchstart', e => e.stopPropagation(), { passive: true });
              accList?.addEventListener('click', onListClick);
              accNewBtn?.addEventListener('click', onNewClick);
              this.root.addEventListener('keydown', onEsc);

              accCancel?.addEventListener('click', () => hideMask(dlgAcc));
              accOK?.addEventListener('click', doAddAccount);

              // 暴露刷新
              this._accSwitch = {
                switchBtn,
                accList,
                accNewBtn,
                onToggle,
                onListClick,
                onNewClick,
                onEsc,
                hideAcc,
                refreshFromWB: async () => {
                  await renderAccList();
                },
              };
            })();

            // 红点位置
            const tabBadge = $('#tabBadge');
            const msgTab = tabs[0];
            const iconWrap = msgTab?.querySelector('.icon-wrap');
            if (tabBadge && iconWrap && tabBadge.parentElement !== iconWrap) {
              iconWrap.appendChild(tabBadge);
            }

            // 消息滑动 + 点击进入 Chat
            const chatUl = $('#chatList');
            let openItem = null;

            const closeOpened = (except = null) => {
              if (openItem && openItem !== except) {
                const r = openItem.querySelector('.row');
                const c = openItem.querySelector('.cell');
                r?.style.setProperty('--reveal', '0px');
                if (c) {
                  c.style.transition = 'transform .2s cubic-bezier(.4,0,.2,1)';
                  c.style.transform = 'translateX(0px)';
                }
                openItem = null;
              }
            };

            const LAYOUT = {
              normal: { frac: 0.56, w1: 16 / 56, w2: 24 / 56, w3: 16 / 56 },
              pinned: { frac: 0.64, w1: 24 / 64, w2: 24 / 64, w3: 16 / 64 },
            };

            const updateActionsLayout = li => {
              const row = li.querySelector('.row');
              const actions = li.querySelector('.actions');
              const pinBtn = actions.querySelector('.pin');
              const unreadBtn = actions.querySelector('.unread');

              const pinned = li.dataset.pinned === '1';
              const unread = li.dataset.unread === '1';

              pinBtn.textContent = pinned ? '取消置顶' : '置顶';
              unreadBtn.textContent = unread ? '标为已读' : '标为未读';

              const cfg = pinned ? LAYOUT.pinned : LAYOUT.normal;
              row.style.setProperty('--action-frac', String(cfg.frac));
              row.style.setProperty('--w1', String(cfg.w1));
              row.style.setProperty('--w2', String(cfg.w2));
              row.style.setProperty('--w3', String(cfg.w3));
            };

            const refreshTabBadge = () => {
              const anyUnread = $$('#chatList > .item').some(li => li.dataset.unread === '1');
              if (tabBadge) {
                if (anyUnread) {
                  tabBadge.textContent = '1';
                  tabBadge.classList.add('show');
                } else {
                  tabBadge.classList.remove('show');
                }
              }
            };

            const setPinned = (li, val) => {
              if (val) {
                const pinnedElsExcl = Array.from(chatUl.children).filter(
                  x => x !== li && x.classList?.contains('pinned'),
                );
                const target = pinnedElsExcl[0] || chatUl.firstElementChild;
                chatUl.insertBefore(li, target);
              } else {
                const pinnedElsExcl = Array.from(chatUl.children).filter(
                  x => x !== li && x.classList?.contains('pinned'),
                );
                const lastPinned = pinnedElsExcl[pinnedElsExcl.length - 1];
                if (lastPinned) chatUl.insertBefore(li, lastPinned.nextElementSibling);
                else chatUl.appendChild(li);
              }
              li.dataset.pinned = val ? '1' : '0';
              li.classList.toggle('pinned', !!val);
              updateActionsLayout(li);
            };

            const setUnread = (li, val) => {
              li.dataset.unread = val ? '1' : '0';
              const ava = li.querySelector('.ava');
              let dot = li.querySelector('.ava > .badge');
              if (val) {
                if (!dot) {
                  dot = document.createElement('span');
                  dot.className = 'badge show';
                  dot.setAttribute('aria-label', '未读');
                  dot.textContent = '1';
                  ava.appendChild(dot);
                } else {
                  dot.textContent = '1';
                  dot.classList.add('show');
                }
              } else if (dot) {
                dot.classList.remove('show');
              }
              updateActionsLayout(li);
              refreshTabBadge();
            };

            const setUnreadCount = (li, n) => {
  const count = Math.max(0, parseInt(n || 0, 10) || 0);
  li.dataset.unread = count > 0 ? '1' : '0';
  const ava = li.querySelector('.ava');
  let dot = li.querySelector('.ava > .badge');
  if (count > 0) {
    const txt = count > 99 ? '99+' : String(count);
    if (!dot) {
      dot = document.createElement('span');
      dot.className = 'badge show';
      dot.setAttribute('aria-label', `未读 ${txt} 条`);
      dot.textContent = txt;
      ava.appendChild(dot);
    } else {
      dot.textContent = txt;
      dot.classList.add('show');
      dot.setAttribute('aria-label', `未读 ${txt} 条`);
    }
  } else if (dot) {
    dot.classList.remove('show');
  }
  updateActionsLayout(li);
  refreshTabBadge();
};

            const attachSwipe = li => {
              if (!li.dataset.pinned) li.dataset.pinned = '0';
              if (!li.dataset.unread) li.dataset.unread = '0';
              updateActionsLayout(li);

              const row = li.querySelector('.row');
              const cell = li.querySelector('.cell');
              const actions = li.querySelector('.actions');

              const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
              const getReveal = () => parseFloat(row.style.getPropertyValue('--reveal') || '0') || 0;
              const setReveal = px => {
                row.style.setProperty('--reveal', `${px}px`);
                cell.style.transform = `translateX(${-px}px)`;
              };

              const closeWithAnim = () => {
                cell.style.transition = 'transform .2s cubic-bezier(.4,0,.2,1)';
                actions.style.transition = 'transform .2s cubic-bezier(.4,0,.2,1)';
                setReveal(0);
                openItem = null;
              };

              const THRESH = 8,
                BIAS = 4,
                TAP_D = 6,
                TAP_T = 250;

              let pid = null;
              let startX = 0,
                startY = 0,
                startReveal = 0;
              let lock = null,
                moving = false,
                tapMoved = false,
                t0 = 0;
              let suppressNextClick = false;

              const maxOpen = () => actions.offsetWidth;

              const onDown = e => {
                if (pid !== null) return;
                closeOpened(li);
                pid = e.pointerId ?? 0;
                startX = e.clientX;
                startY = e.clientY;
                startReveal = getReveal();
                lock = null;
                moving = false;
                tapMoved = false;
                t0 = performance.now();
                cell.style.transition = 'none';
                actions.style.transition = 'none';
                try {
                  cell.setPointerCapture(pid);
                } catch {}
              };

              const onMove = e => {
                if (pid === null) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                if (!moving) {
                  if (Math.abs(dx) > TAP_D || Math.abs(dy) > TAP_D) tapMoved = true;
                }
                if (lock === null) {
                  const ax = Math.abs(dx),
                    ay = Math.abs(dy);
                  if (ax > THRESH || ay > THRESH) {
                    lock = ax > ay + BIAS ? 'x' : 'y';
                    moving = true;
                  }
                }
                if (lock === 'x') {
                  if (e.cancelable) e.preventDefault();
                  const want = startReveal - dx;
                  const reveal = clamp(want, 0, maxOpen());
                  setReveal(reveal);
                }
              };

              const onUpLike = () => {
                if (pid === null) return;
                try {
                  cell.releasePointerCapture(pid);
                } catch {}
                pid = null;
                cell.style.transition = 'transform .2s cubic-bezier(.4,0,.2,1)';
                actions.style.transition = 'transform .2s cubic-bezier(.4,0,.2,1)';

                const dt = performance.now() - t0;
                if ((lock === null || lock === 'y') && !tapMoved && dt <= TAP_T) {
                  if (openItem === li) {
                    closeWithAnim();
                  } else {
                    const title = li.querySelector('.title')?.textContent?.trim() || '';
                    const kind = li.dataset.kind === 'group' ? 'group' : 'dm';
                    this.onOpenChat?.({ kind, peer: title, login: this.login });
                  }
                  return;
                }

                if (lock === 'x') {
                  const now = getReveal();
                  const limit = maxOpen();
                  if (now > limit / 2) {
                    setReveal(limit);
                    openItem = li;
                    suppressNextClick = true;
                    setTimeout(() => {
                      suppressNextClick = false;
                    }, 260);
                  } else {
                    closeWithAnim();
                  }
                }
              };

              cell.addEventListener('pointerdown', onDown);
              cell.addEventListener('pointermove', onMove, { passive: false });
              cell.addEventListener('pointerup', onUpLike);
              cell.addEventListener('pointercancel', onUpLike);
              cell.addEventListener('lostpointercapture', onUpLike);

              li.addEventListener('click', e => {
                if (suppressNextClick) {
                  e.preventDefault();
                  e.stopPropagation();
                  return;
                }
                if (!e.target.closest('.actions') && openItem === li) {
                  closeWithAnim();
                }
              });

              const pinBtn = actions.querySelector('.pin');
              const unreadBtn = actions.querySelector('.unread');
              const delBtn = actions.querySelector('.del');

              pinBtn.addEventListener('click', e => {
                e.preventDefault();
                e.stopPropagation();
                const nowPinned = li.dataset.pinned === '1';
                setPinned(li, !nowPinned);
                closeWithAnim();
              });

              unreadBtn.addEventListener('click', e => {
                e.preventDefault();
                e.stopPropagation();
                const nowUnread = li.dataset.unread === '1';
                const kind = li.dataset.kind === 'group' ? 'group' : 'dm';
const peer = li.querySelector('.title')?.textContent?.trim();
if (nowUnread) {
  RMQQ.Data.markRead?.({ login: this.login, kind, peer });
} else {
  RMQQ.Data.markUnread?.({ login: this.login, kind, peer, count: 1 });
}
                closeWithAnim();
              });

              delBtn.addEventListener('click', e => {
                e.preventDefault();
                e.stopPropagation();
                if (openItem === li) openItem = null;
                li.remove();
                refreshTabBadge();
              });
            };

            // 给初始已有的项打标（现在初始为空，这里保留以兼容未来扩展）
            $$('#chatList .item').forEach(function (li) {
              li.__rmqqBound = true;
            });

            // 暴露给外部使用（Data 或其它地方会来调用）
            if (!this.root.__rmqq) this.root.__rmqq = {};
            this.root.__rmqq.attachSwipe = attachSwipe;
            this.root.__rmqq.refreshTabBadge = refreshTabBadge;

            // resize 同步已展开条目的按钮宽度（保存引用 + 卸载解绑）
            this._onResize = () => {
              const open =
                this.root.querySelector('#chatList > .item .row[style*="--reveal"]')?.closest('.item') || null;
              const target = open || null;
              if (!target) return;
              const r = target.querySelector('.row');
              const a = target.querySelector('.actions');
              const c = target.querySelector('.cell');
              if (!r || !a || !c) return;
              const w = a.offsetWidth;
              r.style.setProperty('--reveal', `${w}px`);
              c.style.transform = `translateX(${-w}px)`;
            };
            window.addEventListener('resize', this._onResize);

            // 搜索条状态
            const markSearchbarState = box => {
              const input = box.querySelector('input');
              const update = () => box.classList.toggle('not-empty', !!input.value.trim());
              input.addEventListener('focus', () => box.classList.add('focused'));
              input.addEventListener('blur', () => box.classList.remove('focused'));
              input.addEventListener('input', update);
              update();
            };
            $$('.searchbar').forEach(markSearchbarState);

            const makeFilter = (container, itemSelector, textGetter) => {
              const items =
                typeof itemSelector === 'string'
                  ? () => Array.from(container.querySelectorAll(itemSelector))
                  : itemSelector;
              return kw => {
                const key = String(kw || '')
                  .trim()
                  .toLowerCase();
                items().forEach(el => {
                  const txt = (textGetter ? textGetter(el) : el.textContent).toLowerCase();
                  el.style.display = key ? (txt.includes(key) ? '' : 'none') : '';
                });
              };
            };

            const chatFilter = makeFilter(
              this.root,
              '#chatList > .item',
              el =>
                (el.querySelector('.title')?.textContent || '') + ' ' + (el.querySelector('.row2')?.textContent || ''),
            );
            this.root.querySelector('.page--chats .searchbar input')?.addEventListener('input', e => {
              chatFilter(e.target.value);
            });

            const ctTabs = $('#ctTabs');
            const ctContainer = $('#ctContainer');

            ctTabs.addEventListener('click', e => {
              const btn = e.target.closest('.ct-tab');
              if (!btn) return;
              const t = btn.dataset.type;
              if (t === 'friends') {
                renderContactsFromWB('friends');
              } else if (t === 'groupchats' || t === 'groups') {
                renderContactsFromWB('groups');
              } else {
                ctContainer.innerHTML = '';
              }
              contactFilter(currentContactKw);
            });

            let currentContactKw = '';
            const contactFilter = kw => {
              currentContactKw = kw || '';
              const f1 = makeFilter($('#ctTop'), '.item', el => el.textContent);
              const f2 = makeFilter(
                $('#ctContainer'),
                '.item',
                el =>
                  (el.querySelector('.title')?.textContent || '') +
                  ' ' +
                  (el.querySelector('.row2')?.textContent || ''),
              );
              f1(kw);
              f2(kw);
            };
            this.root.querySelector('.page--contacts .searchbar input')?.addEventListener('input', e => {
              contactFilter(e.target.value);
            });
            // 让联系人/群聊项点击后进入聊天
            ctContainer.addEventListener('click', e => {
              const li = e.target.closest('.item');
              if (!li) return;
              const name = li.querySelector('.title')?.textContent?.trim();
              if (!name) return;
              // 通过当前 tab 判断是好友还是群聊
              const activeTab = ctTabs.querySelector('.ct-tab.active')?.dataset?.type || 'friends';
              const kind = activeTab === 'groupchats' || activeTab === 'groups' ? 'group' : 'dm';
              this.onOpenChat?.({ kind, peer: name, login: this.login });
            });
            // —— 头像更新后，刷新消息列表/联系人列表的头像 —— //
            const updateAvatarInLists = ({ kind, peer, url }) => {
              // 1）消息页列表
              const ul1 = this.root.querySelector('.page--chats #chatList');
              if (ul1) {
                const li = Array.from(ul1.children).find(x => x.querySelector('.title')?.textContent?.trim() === peer);
                if (li) {
                  const ava = li.querySelector('.ava');
                  if (ava) {
                    ava.style.backgroundImage = `url('${url}')`;
                    ava.style.backgroundPosition = 'center';
                    ava.style.backgroundSize = 'cover';
                    ava.style.backgroundRepeat = 'no-repeat';
                  }
                }
              }
              // 2）联系人页
              const li2 = Array.from(ctContainer.querySelectorAll('.item')).find(
                x => x.querySelector('.title')?.textContent?.trim() === peer,
              );
              if (li2) {
                const ava2 = li2.querySelector('.ava');
                if (ava2) {
                  ava2.style.backgroundImage = `url('${url}')`;
                  ava2.style.backgroundPosition = 'center';
                  ava2.style.backgroundSize = 'cover';
                  ava2.style.backgroundRepeat = 'no-repeat';
                }
              }
            };

            // 监听 ChatView 发出的头像更新事件
            const onPeerAvatarUpdated = e => {
              const d = e.detail || {};
              if (!d.login || d.login !== this.login) return;
              if (d.kind !== 'dm') return; // 本次只做私聊
              // 刷新内存头像字典（给后续新项用）
              this._avatarMap?.set(`${this.login}|dm|${d.peer}`, d.avatar);
              // 立即把屏幕上已经渲染的头像同步
              updateAvatarInLists({ kind: 'dm', peer: d.peer, url: d.avatar });
            };
            window.addEventListener('rmqq:peer-avatar-updated', onPeerAvatarUpdated, { passive: true });
            // 记住处理函数，方便卸载时移除监听
            this._onPeerAvatarUpdated = onPeerAvatarUpdated;

            // 监听 ChatView 发出的“删除好友/解散群聊”事件
            const onChatDeleted = async e => {
              const d = e.detail || {};
              if (!d.login || d.login !== this.login) return;
              // 先拿最新世界书与头像映射，避免用旧缓存渲染联系人
              try {
                const { wb, amap } = await syncWBFromDataAndBuildAvatarMap(this.login);
                this._wbQQ = wb;
                this._avatarMap = amap;
              } catch {}

              // 1) 从“消息”页列表中移除该条会话
              const ul = this.root.querySelector('.page--chats #chatList');
              if (ul) {
                const li = Array.from(ul.children).find(x => {
                  const name = x.querySelector('.title')?.textContent?.trim();
                  const isGroup = x.dataset.kind === 'group';
                  return name === d.peer && (d.kind === 'group' ? isGroup : !isGroup);
                });
                li?.remove();
                this.root.__rmqq?.refreshTabBadge?.();
              }

              // 2) 刷新联系人页（根据类型刷新对应 tab）
              typeof renderContactsFromWB === 'function' &&
                renderContactsFromWB(d.kind === 'group' ? 'groups' : 'friends');
            };
            window.addEventListener('rmqq:chat-deleted', onChatDeleted, { passive: true });
            this._onChatDeleted = onChatDeleted;

            // 动态入口
            $('#openSpaceEntry')?.addEventListener('click', () => this.onOpenSpace?.());

            /* ================= 右上角“+”弹出菜单 ================= */
            const chatsTopbar = this.root.querySelector('.page--chats .topbar');
            const addBtn = this.root.querySelector('.page--chats .topbar .topline .top-btn');
            if (chatsTopbar && addBtn) {
              const qaMenu = this.root.querySelector('.page--chats .qa-menu');
              const showMenu = () => {
                qaMenu.classList.add('show');
                addBtn.setAttribute('aria-expanded', 'true');
                this.root.addEventListener('pointerdown', onOutside, true);
                this.root.querySelector('.page--chats .list')?.addEventListener('scroll', hideMenu, { passive: true });
              };
              const hideMenu = () => {
                qaMenu.classList.remove('show');
                addBtn.setAttribute('aria-expanded', 'false');
                this.root.removeEventListener('pointerdown', onOutside, true);
                this.root.querySelector('.page--chats .list')?.removeEventListener('scroll', hideMenu);
              };
              const onOutside = e => {
                if (qaMenu.contains(e.target) || e.target === addBtn || e.target.closest('.top-btn') === addBtn) return;
                hideMenu();
              };
              const onToggle = e => {
                e.stopPropagation();
                qaMenu.classList.contains('show') ? hideMenu() : showMenu();
              };
              addBtn.addEventListener('click', onToggle);
              qaMenu.addEventListener('click', e => {
                const btn = e.target.closest('.qa-item');
                if (!btn) return;
                const act = btn.dataset.act || '';
                hideMenu();
                if (act === 'create-group') {
                  openCreateGroupDialog();
                } else if (act === 'add-friend') {
                  openAddFriendDialog();
                }
              });
              // 联系人页右上角“加好友”按钮，也打开同一个弹窗
              const ctAddBtn = this.root.querySelector('.page--contacts .topbar .topline .top-btn');
              if (ctAddBtn) {
                ctAddBtn.addEventListener('click', () => openAddFriendDialog());
              }
              // 加好友弹窗脚本
              const dlgFr = this.root.querySelector('#dlgAddFriend');
              const frName = this.root.querySelector('#frAddName');
              const frAva = this.root.querySelector('#frAddAvatar');
              const frErr = this.root.querySelector('#frAddErr');
              const frOK = this.root.querySelector('#frAddOK');
              const frCancel = this.root.querySelector('#frAddCancel');
              const showMask = el => {
                el.classList.add('show');
                el.setAttribute('aria-hidden', 'false');
              };
              const hideMask = el => {
                el.classList.remove('show');
                el.setAttribute('aria-hidden', 'true');
              };

              const openAddFriendDialog = () => {
                frErr.textContent = '';
                frName.value = '';
                frAva.value = '';
                showMask(dlgFr);
              };

              const doAddFriend = async () => {
                const name = (frName.value || '').trim();
                const url = (frAva.value || '').trim();
                if (!name) {
                  frErr.textContent = '请输入好友名字';
                  return;
                }

                // 1) 世界书：写入当前登录用户的好友
                const wb = (await RMPhoneToWorldBook.getApp('qq').catch(() => ({}))) || {};
                wb.login ||= {};
                wb.login[this.login] ||= {
                  avatar: 'https://files.catbox.moe/pcwffp.jpg',
                  contacts: { friends: {}, groups: {} },
                };
                wb.login[this.login].contacts ||= { friends: {}, groups: {} };
                wb.login[this.login].contacts.friends[name] = { avatar: url || 'https://files.catbox.moe/pcwffp.jpg' };
                await RMPhoneToWorldBook.saveApp('qq', wb);
                this._wbQQ = wb;

                // 2) 更新本地头像字典 + 立即刷新联系人列表
                this._avatarMap.set(`${this.login}|dm|${name}`, url || 'https://files.catbox.moe/pcwffp.jpg');
                typeof renderContactsFromWB === 'function' && renderContactsFromWB('friends');

                hideMask(dlgFr);
              };

              frCancel?.addEventListener('click', () => hideMask(dlgFr));
              frOK?.addEventListener('click', doAddFriend);

              // Esc 关闭（复用上面已有的 keydown 监听也可）
              this.root.addEventListener('keydown', e => {
                if (e.key === 'Escape') hideMask(dlgFr);
              });

              // ===== 创建群聊：弹窗逻辑 =====
              const dlgGrp = this.root.querySelector('#dlgCreateGroup');
              const iptGrpName = this.root.querySelector('#grpName');
              const iptGrpAva = this.root.querySelector('#grpAvatar');
              const iptGrpSearch = this.root.querySelector('#grpSearch');
              const boxGrpList = this.root.querySelector('#grpFriendList');
              const txtGrpErr = this.root.querySelector('#grpErr');
              const btnGrpOK = this.root.querySelector('#grpOK');
              const btnGrpCancel = this.root.querySelector('#grpCancel');

              const FALLBACK = 'https://files.catbox.moe/pcwffp.jpg'; // 本地兜底头像

              // 渲染单个可选好友
              function makePickItem({ name, avatar }) {
                const li = document.createElement('div');
                li.className = 'grp-item';
                li.dataset.name = name;
                li.style.cssText =
                  'display:flex;align-items:center;gap:8px;padding:6px;border-radius:8px;cursor:pointer;';
                li.innerHTML = `
    <i class="fi fi-rr-check-circle tick" style="font-size:18px;color:#9aa3ad;"></i>
    <div class="ava" style="width:28px;height:28px;border-radius:999px;background:#e9eef6 center/cover no-repeat;"></div>
    <div class="name" style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"></div>
  `;
                li.querySelector('.name').textContent = name;
                const ava = li.querySelector('.ava');
                ava.style.backgroundImage = `url('${avatar || FALLBACK}')`;

                const toggle = () => {
                  const picked = li.classList.toggle('selected');
                  li.querySelector('.tick').style.color = picked ? '#2b84ff' : '#9aa3ad';
                };
                li.addEventListener('click', toggle);
                return li;
              }

              // 根据世界书加载好友并渲染
              const renderGroupFriends = async () => {
                boxGrpList.innerHTML = '';
                try {
                  const wb = await RMPhoneToWorldBook.getApp('qq');
                  const node = wb?.login?.[this.login];
                  const friends = Object.entries(node?.contacts?.friends || {}).map(([n, meta]) => ({
                    name: n,
                    avatar: meta?.avatar || FALLBACK,
                  }));

                  if (!friends.length) {
                    boxGrpList.innerHTML = `<div style="color:#6b7280;padding:8px;">还没有好友哦</div>`;
                    return;
                  }

                  friends.forEach(f => boxGrpList.appendChild(makePickItem(f)));

                  // 搜索过滤（输入即筛）
                  iptGrpSearch?.addEventListener(
                    'input',
                    e => {
                      const key = String(e.target.value || '')
                        .trim()
                        .toLowerCase();
                      Array.from(boxGrpList.children).forEach(el => {
                        const ok = el.dataset.name.toLowerCase().includes(key);
                        el.style.display = ok ? '' : 'none';
                      });
                    },
                    { passive: true },
                  );
                } catch (e) {
                  console.error('[创建群聊] 好友列表读取失败：', e);
                  boxGrpList.innerHTML = `<div style="color:#ef4444;padding:8px;">好友列表读取失败</div>`;
                }
              };
              // 打开弹窗
              const openCreateGroupDialog = async () => {
                txtGrpErr.textContent = '';
                iptGrpName.value = '';
                iptGrpAva.value = '';
                iptGrpSearch.value = '';
                await renderGroupFriends();
                showMask(dlgGrp); // 你现有的 showMask/hideMask 工具直接复用
              };

              // 取消
              btnGrpCancel?.addEventListener('click', () => hideMask(dlgGrp));

              // 确定：写 世界书（条目+联系人里登记头像）、建群会话、发一条提示
              btnGrpOK?.addEventListener('click', async () => {
                const name = (iptGrpName.value || '').trim();
                if (!name) {
                  txtGrpErr.textContent = '请填写群聊名';
                  return;
                }

                // 收集选择的好友
                const picks = Array.from(boxGrpList.querySelectorAll('.grp-item.selected'))
                  .map(el => el.dataset.name)
                  .filter(Boolean);
                if (!picks.length) {
                  txtGrpErr.textContent = '至少选择 1 位好友';
                  return;
                }

                const avatar = (iptGrpAva.value || '').trim() || FALLBACK;

                // 1) 世界书 apps：把群头像 + 成员记到 qq 分区，供联系人/头像用
                const wb = (await RMPhoneToWorldBook.getApp('qq').catch(() => ({}))) || {};
                wb.login ||= {};
                wb.login[this.login] ||= { avatar: FALLBACK, contacts: { friends: {}, groups: {} } };
                wb.login[this.login].contacts ||= { friends: {}, groups: {} };
                const meta = (wb.login[this.login].contacts.groups[name] ||= {});
                meta.avatar = avatar;
                meta.members = [this.login, ...picks];
                await RMPhoneToWorldBook.saveApp('qq', wb);
                this._wbQQ = wb; // 让联系人视图能立刻看到
                this._avatarMap?.set?.(`${this.login}|group|${name}`, avatar); // 列表/消息头像用
                // 你的联系人渲染 & 聊天列表补头像就是读这个结构的。:contentReference[oaicite:5]{index=5}

                // 3) 世界书 主世界：新增条目 `RMPhoneQQ群聊.<群名>`
                const content = `${this.login}、${picks.join('、')}在群聊${name}中。`;
                await RMPhoneToWorldBook.createQQGroupEntry?.(name, content);

                hideMask(dlgGrp);
              });

              // Esc 关闭
              this.root.addEventListener('keydown', e => {
                if (e.key === 'Escape') hideMask(dlgGrp);
              });

              this._qa = { addBtn, onToggle, onOutside, hideMenu, qaMenu };
            }

            // 列表点击打开聊天（保留你的原行为）
            const chatList = this.root.querySelector('.page--chats #chatList');
            if (chatList && !chatList.__rmqqDelegated) {
              chatList.__rmqqDelegated = true;
              chatList.addEventListener('click', e => {
                const li = e.target.closest('li.item');
                if (!li) return;
                if (e.target.closest('.actions')) return; // 避免点到右侧按钮
                const title = li.querySelector('.title')?.textContent?.trim();
                const kind = li.dataset.kind === 'group' ? 'group' : 'dm';
                this.onOpenChat?.({ kind, peer: title, login: this.login });
              });
            }

            /* ====== RMPhone 世界书同步 + 头像字典 ====== */
            const DEFAULT_AVATAR = 'https://files.catbox.moe/pcwffp.jpg';

            // 简单深合并
            function deepMerge(base, patch) {
              if (!base || typeof base !== 'object') return JSON.parse(JSON.stringify(patch || {}));
              const out = Array.isArray(base) ? base.slice() : { ...base };
              if (patch && typeof patch === 'object') {
                for (const [k, v] of Object.entries(patch)) {
                  if (Array.isArray(v)) {
                    if (k === 'members') {
                      const cur = Array.isArray(out[k]) ? out[k] : [];
                      out[k] = Array.from(new Set([...cur, ...v])); // 成员去重合并
                    } else {
                      out[k] = v; // 其它数组直接覆盖
                    }
                  } else if (v && typeof v === 'object') {
                    out[k] = deepMerge(out[k] || {}, v); // 对象递归合并
                  } else {
                    if (out[k] === undefined) out[k] = v; // 原来没有就写入；已有的不覆盖
                  }
                }
              }
              return out;
            }

            // 从 _data 把 DM / GROUP 同步到世界书 apps.qq.login[<login>].contacts
            const syncWBFromDataAndBuildAvatarMap = async loginName => {
              RMQQ.Data.init?.();

              const state = RMQQ.Data.getState(); // ← 这里就是 QQ 分区
              const wbQQ = (await RMPhoneToWorldBook.getApp('qq')) || {};
              const patch = { login: {} };

              const accounts = Array.isArray(state.accounts) ? state.accounts : [];
              const fallbackLogin = (loginName && String(loginName).trim()) || '{{user}}';

              if (!accounts.length) {
                // 没账号也给一个兜底节点，避免 login:{}
                patch.login[fallbackLogin] = { avatar: DEFAULT_AVATAR, contacts: { friends: {}, groups: {} } };
              } else {
                for (const acc of accounts) {
                  const login = acc?.login || fallbackLogin;
                  const node = (patch.login[login] ||= {
                    avatar: DEFAULT_AVATAR,
                    contacts: { friends: {}, groups: {} },
                  });

                  for (const s of acc.sessions || []) {
                    const peer = String(s?.peer || '').trim();
                    if (!peer) continue;
                    if (s.kind === 'group') {
                      // 1) 确保群节点存在
                      const g = (node.contacts.groups[peer] ||= { avatar: DEFAULT_AVATAR });

                      // 2) 从该群会话的 items 里收集发言人
                      const speakers = new Set(
                        Array.isArray(s.items)
                          ? s.items.map(it => String(it?.speaker || '').trim()).filter(Boolean)
                          : [],
                      );

                      // 3) 群成员 = 登录用户 + 其他发言人（去重、可累计）
                      speakers.add(login);
                      const mem = new Set(Array.isArray(g.members) ? g.members : []);
                      for (const name of speakers) mem.add(name);
                      g.members = Array.from(mem);

                      // 4) 发言人也登记到“好友”（排除自己）
                      for (const name of speakers) {
                        if (name && name !== login) {
                          node.contacts.friends[name] ||= { avatar: DEFAULT_AVATAR };
                        }
                      }
                    } else {
                      // DM：对端入好友
                      node.contacts.friends[peer] ||= { avatar: DEFAULT_AVATAR };
                    }
                  }
                }
              }

              const merged = deepMerge(wbQQ, patch);
              await RMPhoneToWorldBook.saveApp('qq', merged);

              // 头像索引
              const amap = new Map();
              for (const [login, info] of Object.entries(merged.login || {})) {
                amap.set(`${login}|__self__`, info.avatar || DEFAULT_AVATAR);
                for (const [n, o] of Object.entries(info.contacts?.friends || {})) {
                  amap.set(`${login}|dm|${n}`, o?.avatar || DEFAULT_AVATAR);
                }
                for (const [n, o] of Object.entries(info.contacts?.groups || {})) {
                  amap.set(`${login}|group|${n}`, o?.avatar || DEFAULT_AVATAR);
                }
              }
              return { wb: merged, amap };
            };

            // 存一下，后面渲染会用
            this._wbQQ = null;
            this._avatarMap = new Map();

            const renderContactsFromWB = (which = 'friends') => {
              const loginNode = this._wbQQ?.login?.[this.login];
              const store = loginNode?.contacts || { friends: {}, groups: {} };

              const ctContainer = this.root.querySelector('#ctContainer');
              if (!ctContainer) return;

              // 切 tab 的高亮
              const ctTabs = this.root.querySelector('#ctTabs');
              if (ctTabs) {
                ctTabs.querySelectorAll('.ct-tab').forEach(b => b.classList.remove('active'));
                const key = which === 'groups' ? 'groupchats' : 'friends';
                ctTabs.querySelector(`.ct-tab[data-type="${key}"]`)?.classList.add('active');
              }

              const listObj = which === 'groups' ? store.groups || {} : store.friends || {};
              const entries = Object.entries(listObj);

              if (!entries.length) {
                ctContainer.innerHTML = '';
                return;
              }

              ctContainer.innerHTML = entries
                .map(([name, meta]) => {
                  const url = meta && meta.avatar ? meta.avatar : DEFAULT_AVATAR;
                  return `
      <li class="item">
        <div class="row" style="--action-frac:0">
          <div class="cell">
            <div class="ava" style="background:#e9eef6; background-image:url('${url}'); background-position:center; background-size:cover; background-repeat:no-repeat;"></div>
            <div class="meta">
              <div class="row1"><div class="title">${name}</div></div>
              <div class="row2">${which === 'groups' ? '群聊' : '好友'}</div>
            </div>
          </div>
          <div class="actions" aria-hidden="true"></div>
        </div>
      </li>`;
                })
                .join('');
            };

            /* ================= 订阅 _data 摘要：渲染/增量更新 ================= */
            const makeChatRow = (title, kind, preview) => {
              const li = document.createElement('li');
              li.className = 'item';
              if (kind === 'group') li.dataset.kind = 'group'; // 关键：让 li 带上 data-kind
              li.innerHTML = `
    <div class="row" style="--action-frac:.56">
      <div class="cell">
        <div class="ava"></div>
        <div class="meta">
          <div class="row1"><div class="title"></div><time class="time">刚刚</time></div>
          <div class="row2"></div>
        </div>
      </div>
      <div class="actions">
        <button class="action pin">置顶</button>
        <button class="action unread">标为未读</button>
        <button class="action del">删除</button>
      </div>
    </div>`;
              li.querySelector('.title').textContent = title || '';
              li.querySelector('.row2').textContent = preview || (kind === 'group' ? '群聊' : '好友');

              // 头像：优先世界书；否则默认
              const ava = li.querySelector('.ava');
              if (ava) {
                const key = `${this.login}|${kind === 'group' ? 'group' : 'dm'}|${title || ''}`;
                const url = this._avatarMap?.get(key) || DEFAULT_AVATAR;
                ava.style.background = '#e9eef6';
                ava.style.backgroundImage = `url('${url}')`;
                ava.style.backgroundPosition = 'center';
                ava.style.backgroundSize = 'cover';
                ava.style.backgroundRepeat = 'no-repeat';
              }
              return li;
            };

            this._unsubTabs = RMQQ.Data.subscribeTabsSummaries({ login: this.login }, e => {
              const ul = this.root.querySelector('.page--chats #chatList');
              if (!ul) return;

              if (e.type === 'init') {
                // 初始化：清空并渲染所有会话
                ul.innerHTML = '';
                for (const s of e.summaries) {
                  const li = makeChatRow(s.peer, s.kind, s.preview || (s.kind === 'group' ? '群聊' : '好友'));
                  ul.appendChild(li);
                  setUnreadCount(li, s.unreadCount || 0);
                }

                // 左滑绑定（有就绑）
                const binder = this.root.__rmqq?.attachSwipe;
                if (typeof binder === 'function') {
                  ul.querySelectorAll('.item').forEach(li => {
                    if (!li.__rmqqBound) {
                      binder(li);
                      li.__rmqqBound = true;
                    }
                  });
                }

                // 刷新角标
                this.root.__rmqq?.refreshTabBadge?.();

                // ✅ 初始化后：同步世界书 & 头像映射，并刷新联系人/头像
                (async () => {
                  const { wb, amap } = await syncWBFromDataAndBuildAvatarMap(this.login);
                  this._wbQQ = wb;
                  this._avatarMap = amap;

                  // 用最新头像表批量补一次头像（可选但推荐）
                  try {
                    ul.querySelectorAll('.item').forEach(li => {
                      const title = li.querySelector('.title')?.textContent?.trim();
                      // 如果 makeChatRow 有写 data-kind 这里更稳：const kind = li.dataset.kind;
                      const kind = li.dataset?.kind || (title && (title.includes('群') ? 'group' : 'dm'));
                      if (!title) return;
                      const key = `${this.login}|${kind === 'group' ? 'group' : 'dm'}|${title}`;
                      const url = this._avatarMap?.get(key) || DEFAULT_AVATAR;
                      const ava = li.querySelector('.ava');
                      if (ava) {
                        ava.style.background = '#e9eef6';
                        ava.style.backgroundImage = `url('${url}')`;
                        ava.style.backgroundPosition = 'center';
                        ava.style.backgroundSize = 'cover';
                        ava.style.backgroundRepeat = 'no-repeat';
                      }
                    });
                  } catch {}

                  typeof renderContactsFromWB === 'function' && renderContactsFromWB('friends');
                })();
              } else if (e.type === 'patch') {
                // patch：新增或更新单个会话
                let li = Array.from(ul.children).find(
                  x => x.querySelector('.title')?.textContent?.trim() === e.summary.peer,
                );

                if (!li) {
                  // 新增一行
                  li = makeChatRow(
                    e.summary.peer,
                    e.summary.kind,
                    e.summary.preview || (e.summary.kind === 'group' ? '群聊' : '好友'),
                  );
                  ul.appendChild(li);
                  setUnreadCount(li, (e.summary && e.summary.unreadCount) || 0);

                  // 兜底先设一次头像（可能是旧映射；稍后 IIFE 会再补一次）
                  const key0 = `${this.login}|${e.summary.kind === 'group' ? 'group' : 'dm'}|${e.summary.peer}`;
                  const url0 = this._avatarMap?.get(key0) || DEFAULT_AVATAR;
                  const ava0 = li.querySelector('.ava');
                  if (ava0) {
                    ava0.style.background = '#e9eef6';
                    ava0.style.backgroundImage = `url('${url0}')`;
                    ava0.style.backgroundPosition = 'center';
                    ava0.style.backgroundSize = 'cover';
                    ava0.style.backgroundRepeat = 'no-repeat';
                  }

                  // 左滑绑定（有就绑）
                  const binder = this.root.__rmqq?.attachSwipe;
                  if (typeof binder === 'function') {
                    if (!li.__rmqqBound) {
                      binder(li);
                      li.__rmqqBound = true;
                    }
                  }
                } else {
                  // 更新预览与时间
                  li.querySelector('.row2').textContent = e.summary.preview || '';
                  const t = li.querySelector('.time');
                  if (t) t.textContent = '刚刚';
                }
                setUnreadCount(li, (e.summary && e.summary.unreadCount) || 0);

                // 刷新角标
                this.root.__rmqq?.refreshTabBadge?.();

                // ✅ 追加消息后：同步世界书 & 头像映射；刷新群设置/联系人；再补一次该行头像
                (async () => {
                  const { wb, amap } = await syncWBFromDataAndBuildAvatarMap(this.login);
                  this._wbQQ = wb;
                  this._avatarMap = amap;

                  // 如果正打开的就是该群的“群聊设置”，刷新成员区域
                  try {
                    if (this.kind === 'group' && this.peerName === e.summary.peer) {
                      const body = this.root.querySelector('#cvSetBody');
                      if (body) body.innerHTML = renderGroup();
                    }
                  } catch {}

                  // 用最新头像映射再补一次对应行（此时映射已更新）
                  const key = `${this.login}|${e.summary.kind === 'group' ? 'group' : 'dm'}|${e.summary.peer}`;
                  const url = this._avatarMap?.get(key) || DEFAULT_AVATAR;
                  const li2 = Array.from(ul.children).find(
                    x => x.querySelector('.title')?.textContent?.trim() === e.summary.peer,
                  );
                  const ava = li2?.querySelector('.ava');
                  if (ava) {
                    ava.style.background = '#e9eef6';
                    ava.style.backgroundImage = `url('${url}')`;
                    ava.style.backgroundPosition = 'center';
                    ava.style.backgroundSize = 'cover';
                    ava.style.backgroundRepeat = 'no-repeat';
                  }

                  // 联系人视图也跟进
                  typeof renderContactsFromWB === 'function' && renderContactsFromWB('friends');
                })();
              } else if (e.type === 'remove') {
                // 找到标题匹配的行并移除
                const li = Array.from(ul.children).find(
                  x => x.querySelector('.title')?.textContent?.trim() === e.summary.peer,
                );
                if (li) li.remove();
                // 刷新底部角标
                this.root.__rmqq?.refreshTabBadge?.();
                // 联系人视图也可同步刷新（保险起见）
                typeof renderContactsFromWB === 'function' && renderContactsFromWB('friends');
              }
            });
            // 先把世界书同步好，再渲染联系人 & 给消息列表补头像
            (async () => {
              const { wb, amap } = await syncWBFromDataAndBuildAvatarMap(this.login);
              this._wbQQ = wb;
              this._avatarMap = amap;
              // wb 到了后，刷新一次“群聊设置”的成员（避免先渲染成空）
              try {
                if (this.kind === 'group') {
                  const body = this.root.querySelector('#cvSetBody');
                  if (body) body.innerHTML = renderGroup();
                }
              } catch {}
              // === 新增：把“当前登录用户”的头像，灌到顶栏&抽屉 ===
              const selfUrl = this._avatarMap.get(`${this.login}|__self__`) || DEFAULT_AVATAR;
              [
                this.root.querySelector('#avatar'), // 抽屉名片头像
                this.root.querySelector('#tbarAvatar'), // 消息页 顶栏头像
                this.root.querySelector('.page--contacts .topbar .avatar'), // 联系人 顶栏头像
                this.root.querySelector('.page--feed .topbar .avatar'), // 动态 顶栏头像
              ]
                .filter(Boolean)
                .forEach(el => {
                  el.style.background = '#e9eef6';
                  el.style.backgroundImage = `url('${selfUrl}')`;
                  el.style.backgroundPosition = 'center';
                  el.style.backgroundSize = 'cover';
                  el.style.backgroundRepeat = 'no-repeat';
                });

                const tbar = this.root.querySelector('#tbarAvatar');
const applyOtherLoginDot = flag => {
  if (!tbar) return;
  let dot = tbar.querySelector('.badge');
  if (flag) {
    if (!dot) {
      dot = document.createElement('span');
      dot.className = 'badge show';
      dot.setAttribute('aria-label', '其他账号有未读');
      tbar.appendChild(dot);
    } else {
      dot.classList.add('show');
    }
  } else if (dot) {
    dot.classList.remove('show');
  }
};
this._offOtherUnread?.();
this._offOtherUnread = RMQQ.Data.subscribeAnyUnreadExceptLogin?.(
  { login: this.login },
  flag => applyOtherLoginDot(!!flag)
);

              // 初始化联系人视图（从世界书）
              const ctTabs = this.root.querySelector('#ctTabs');
              const type = ctTabs?.querySelector('.ct-tab.active')?.dataset.type;
              renderContactsFromWB(type === 'groupchats' ? 'groups' : 'friends');

              // 给已存在的消息项补头像
              this.root.querySelectorAll('#chatList > .item').forEach(li => {
                const kind = li.dataset.kind === 'group' ? 'group' : 'dm';
                const title = li.querySelector('.title')?.textContent?.trim() || '';
                const key = `${this.login}|${kind}|${title}`;
                const url = this._avatarMap.get(key) || DEFAULT_AVATAR;
                const ava = li.querySelector('.ava');
                if (ava) {
                  ava.style.background = '#e9eef6';
                  ava.style.backgroundImage = `url('${url}')`;
                  ava.style.backgroundPosition = 'center';
                  ava.style.backgroundSize = 'cover';
                  ava.style.backgroundRepeat = 'no-repeat';
                }
              });
              // —— 新增：WB 就绪后，让“切换账号”列表也刷新一次（不需要用户点开才渲染）
              await this._accSwitch?.refreshFromWB?.();
            })();
          }

          onShow() {
            /* 根屏显现 */
          }
          onHide() {
            /* 根屏被遮，keepAlive=true，啥都不做 */
          }

          unmount() {
            this._unsubTabs?.();
            this._unsubTabs = null;

            if (this._onResize) {
              window.removeEventListener('resize', this._onResize);
              this._onResize = null;
            }

            if (this._qa) {
              this._qa.addBtn?.removeEventListener('click', this._qa.onToggle);
              this.root?.removeEventListener?.('pointerdown', this._qa.onOutside, true);
              this._qa.hideMenu?.();
              this._qa.qaMenu?.remove?.();
              this._qa = null;
            }

            if (this._accSwitch) {
              const { switchBtn, accList, accNewBtn, onToggle, onListClick, onNewClick, onEsc, hideAcc } =
                this._accSwitch;
              try {
                hideAcc?.();
              } catch {}
              switchBtn?.removeEventListener('click', onToggle);
              accList?.removeEventListener('click', onListClick);
              accNewBtn?.removeEventListener('click', onNewClick);
              this.root?.removeEventListener?.('keydown', onEsc);
              this._accSwitch = null;
            }

            if (this._edgeReflow) {
              window.removeEventListener('resize', this._edgeReflow);
              this._edgeReflow = null;
            }

            if (this._onPeerAvatarUpdated) {
              window.removeEventListener('rmqq:peer-avatar-updated', this._onPeerAvatarUpdated, { passive: true });
              this._onPeerAvatarUpdated = null;
            }

            if (this._onChatDeleted) {
              window.removeEventListener('rmqq:chat-deleted', this._onChatDeleted, { passive: true });
              this._onChatDeleted = null;
            }

            this.root = null;
          }
        }

        // ===================== ChatView（数据驱动，保留你所有样式与交互） =====================
        class ChatView {
          constructor({ login, kind = 'dm', peerName = '聊天', onBack, leftAvatar = null, rightAvatar = null } = {}) {
            this.key = 'chat';
            this.keepAlive = false;
            this.login = login; // 当前账号
            this.kind = kind; // 'dm' | 'group'
            this.peerName = peerName;
            this.onBack = onBack;
            this.leftAvatar = leftAvatar;
            this.rightAvatar = rightAvatar;
            this.root = null;
            this._handlers = [];
            this._offHdrUnread = null; // 顶部“其它会话未读总数”订阅
          }

          mount(container) {
            this.root = container;
            this.root.innerHTML = `
      <link rel="stylesheet" href="https://cdn-uicons.flaticon.com/3.0.0/uicons-regular-rounded/css/uicons-regular-rounded.css">
      <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css"
        crossorigin="anonymous" referrerpolicy="no-referrer">
      <style>
        .chat-wrap{
          --accent:#0099ff;
          --bg:#f2f4f7;
          --line:#e8ecf2;
          --topbot-alpha:.82;         /* 顶/底栏透明度 */
          --island-clearance:10%;
          position:absolute; inset:0; display:flex; flex-direction:column; background:var(--bg); color:#111;
          font:12px/1.35 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;
          -webkit-user-select:none; user-select:none;
        }
        .chat-wrap *{ -webkit-tap-highlight-color: transparent; }

        /* 顶部栏 */
        .chat-topbar{
          position:sticky; top:0; z-index:5;
          background:rgba(242,244,247,var(--topbot-alpha));
          backdrop-filter:saturate(160%) blur(10px);
          border-bottom:1px solid var(--line);
          padding: calc(env(safe-area-inset-top, 0px) + var(--island-clearance)) 8px 6px;
          display:flex; align-items:center; justify-content:space-between; gap:8px;
        }
        .chat-left{ display:flex; align-items:center; min-width:0; }
        .chat-back{
          width:24px; height:24px; border:0; background:transparent; border-radius:8px;
          display:grid; place-items:center; flex:0 0 auto;
        }
        .chat-back i{ font-size:16px; transform:translateX(-0.3em); }
        .chat-back:active{ background:rgba(0,0,0,.06); }
        .chat-center{ display:flex; flex-direction:column; min-width:0; }
        .chat-name{ font-weight:700; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
        .chat-status{ font-size:10.5px; color:#6b7280; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
        .cv-hdr-unread{
  margin:0 6px 0 0;
  min-width:16px; height:16px;
  border-radius:999px;
  background:#ff3b30; color:#fff;
  font-size:10px; line-height:16px;
  padding:0 4px;
  display:none; align-items:center; justify-content:center;
}
.cv-hdr-unread.show{ display:inline-flex; }
        .chat-right .chat-more{
          font-size:16px; width:28px; height:28px; border:0; background:transparent; border-radius:8px; display:grid; place-items:center;
        }
        .chat-right .chat-more:active{ background:rgba(0,0,0,.06); }

        /* 消息列表 */
        .chat-main{ flex:1; overflow:auto; padding:10px 10px 12px; background:transparent; }
        .chat-main::-webkit-scrollbar{ width:0; height:0; }

        /* 行、头像、气泡 */
        .cv-row{ width:100%; margin:6px 0; display:flex; align-items:flex-start; gap:6px; }
        .cv-row--left{ justify-content:flex-start; }
        .cv-row--right{ justify-content:flex-end; }

        .cv-txt{
          --fz:13px; --lh:1.35; --vpad:8px;
          max-width:76%;
          padding: var(--vpad) 10px;
          line-height: var(--lh);
          font-size: var(--fz);
          border-radius:12px;
          word-break:break-word;
        }
        .cv-row--left  .cv-txt{ background:#fff; color:#111; border:1px solid #eef1f5; }
        .cv-row--right .cv-txt{ background:var(--accent); color:#fff; }
        /* 群聊：名字标签 + 一个竖向包裹容器 */
.cv-name{ font-size:11px; color:#6b7280; margin:0 0 2px 6px; }
.cv-wrap{ display:flex; flex-direction:column; align-items:flex-start; max-width:100%; flex:1 1 auto; min-width:0; }

        .chat-ava{
          width:  calc(2*var(--vpad,8px) + var(--fz,13px)*var(--lh,1.35));
          height: calc(2*var(--vpad,8px) + var(--fz,13px)*var(--lh,1.35));
          border-radius:999px; flex:0 0 auto;
          background:#dfe3ea center/cover no-repeat;
        }

        /* ===== 表情包（去 stack） ===== */
        .cv-bqb{ max-width:40%; border-radius:12px; overflow:hidden; padding:0; border:0; background:transparent; }
        .cv-bqb img{ display:block; width:100%; height:auto; object-fit:contain; -webkit-user-drag:none; user-select:none; }

        /* ===== 语音（仅语音有自带 wrap，控制转文字宽度） ===== */
        .cv-voice-wrap{
          display:flex; flex-direction:column; gap:4px; max-width:76%;
        }
        .cv-row--left  .cv-voice-wrap{ align-items:flex-start; }
        .cv-row--right .cv-voice-wrap{ align-items:flex-end; }

        .cv-voice{
          display:flex; align-items:center; gap:6px;
          padding:8px 10px; border-radius:12px;
          box-sizing:border-box; white-space:nowrap; cursor:pointer; user-select:none;
          max-width:100%;
        }
        .cv-voice i{ font-size:14px; transform:translateY(1px); opacity:.9; }
        .cv-voice::after{
          content: attr(data-dur) "''";
          display:inline-block;
          flex:0 0 auto;
          line-height:1; font-weight:600; letter-spacing:.2px;
        }
        .cv-row--left  .cv-voice{ background:#fff; color:#111; border:1px solid #eef1f5; }
        .cv-row--right .cv-voice{ background:var(--accent); color:#fff; }

        .cv-voice-text{ max-width:100%; }
        .cv-hidden{ display:none !important; }

        /* ===== dmt（去 stack） ===== */
        .cv-dmt{
          position:relative; overflow:hidden; border-radius:12px;
          border:1px solid #eef1f5; background:#eceff3;
          width: clamp(200px, 66%, 320px);
          max-width:76%;
          min-height:140px;
          cursor:pointer; user-select:none;
        }
        .cv-dmt-mask{
          position:absolute; inset:0; background:#e5e9f0;
          display:grid; place-items:center; color:#6b7280; font-size:22px;
          transition: opacity .18s ease;
        }
        .cv-dmt.is-open .cv-dmt-mask{ opacity:0; pointer-events:none; }
        .cv-dmt-text{
          position:absolute; inset:0; padding:10px 12px; box-sizing:border-box;
          color:#111; background:transparent; overflow:auto; opacity:0; transition:opacity .18s ease;
          scrollbar-width:none; -ms-overflow-style:none;
        }
        .cv-dmt-text::-webkit-scrollbar{ width:0; height:0; display:none; }
        .cv-dmt.is-open .cv-dmt-text{ opacity:1; }

        /* ===== file（文件气泡） ===== */
.cv-file{
  display:flex; align-items:center; gap:10px;
  background:#fff; color:#111;
  border:1px solid #eef1f5;
  border-radius:12px;
  padding:10px 10px 10px 12px;
  max-width:76%;
  width: clamp(220px, 70%, 360px);
  box-sizing:border-box;
  user-select:none; cursor:pointer;
}
.cv-file:active{ transform:scale(.995); }

/* 左边文字区 */
.cv-file-info{ flex:1; min-width:0; }
.cv-file-name{
  font-size:13px; font-weight:600;
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}
.cv-file-meta{
  margin-top:2px; font-size:11.5px; color:#6b7280;
}

/* 右侧深蓝方块 + 图标 */
.cv-file-ico{
  flex:0 0 auto;
  width:44px; height:44px; border-radius:12px;
  background:#0069cd;
  display:grid; place-items:center;
}
.cv-file-ico i{ color:#fff; font-size:20px; line-height:1; }

/* 放在左右两边都好看（这里不改变左右配色，仍保持白底卡片） */
.cv-row--right .cv-file{ }

        /* 底部输入区 */
        .chat-bottom{
          position:relative;
          background:rgba(242,244,247,var(--topbot-alpha));
          border-top:1px solid var(--line);
          backdrop-filter:saturate(160%) blur(10px);
          padding:6px 8px calc(env(safe-area-inset-bottom, 0px) + var(--pad) * 1);
        }
        .cv-input-row{ display:flex; gap:8px; align-items:center; margin-bottom:2px; }
        .cv-input{
          flex:1; height:34px; border:1px solid #eef1f5; border-radius:10px; padding:0 10px; outline:none; font-size:13px; background:#fff; color:#111;
        }
        .cv-send{
          border:0; padding:0 12px; height:34px; border-radius:10px; background:var(--accent); color:#fff; font-weight:700; font-size:12px;
        }

        .cv-tools{ display:flex; align-items:center; justify-content:space-between; gap:10px; padding:2px 2px 0; }
        .cv-tool-btn{ border:0; background:transparent; padding:6px; border-radius:10px; outline:none; }
        .cv-tool-btn img{ width:22px; height:22px; display:block; }
        /* plus 展开区 */
.cv-expand{
  height:0;
  overflow:hidden;
  background:rgba(242,244,247,var(--topbot-alpha)); /* 与底栏同色 */
  transition:height .22s cubic-bezier(.4,0,.2,1);
}
.cv-expand.show{
  height: var(--cv-expand-h, 40vh);
  border-top:1px solid var(--line);
  margin-top:6px;
} /* 用变量承接，JS 会写 px 进去 */
/* 展开区里的“内容框” */
.cv-panel{
  height:100%;
  margin:10px 6px 0;
  background:transparent;
  border:0;
  border-radius:14px;
  box-shadow:none;
  overflow:hidden;
  display:flex;
}
.cv-panel .body{
  flex:1; overflow:auto; padding:12px;
  scrollbar-width:none; -ms-overflow-style:none;
}
.cv-panel .body::-webkit-scrollbar{ width:0; height:0; display:none; }
.cv-expand-scroll{
  height:100%;
  overflow-y:auto;
  padding:10px 6px calc(env(safe-area-inset-bottom,0px) + 28px);
  scrollbar-width:none; -ms-overflow-style:none;
}
.cv-expand-scroll::-webkit-scrollbar{ width:0; height:0; display:none; }
.cv-ext-grid{ display:grid; grid-template-columns:repeat(4,1fr); gap:12px; }

.cv-ext-item{
  display:flex; flex-direction:column; align-items:center;gap:2px;
  background:transparent; padding:0; text-align:center; border:0;
}
.cv-ext-item .box{
  width:100%; aspect-ratio:1;
  background:#fff; border:1px solid var(--line); border-radius:12px;
  display:grid; place-items:center;
}
/* 让表情缩略图在格子里自适应、不溢出 */
.cv-ext-item .box img{
  width: 100%;
  height: 100%;
  object-fit: contain;
  display: block;
}
/* 第一格「添加表情」的虚线卡片样式 */
.cv-ext-item.add .box{
background: transparent;
border: 1px dashed var(--line);
}
.cv-ext-item.add .box i{ opacity: .6; }
.cv-ext-item i{ font-size:20px; color:#666; transform: translateY(0.1em);}
.cv-ext-item .label{ font-size:10px; color:#666;}
                /* 触发生成：范围菜单 */
        .gen-menu{
          position:absolute; right:8px; bottom:58px; z-index:20;
          background:#fff; border:1px solid var(--line); border-radius:12px;
          box-shadow:0 6px 20px rgba(0,0,0,.08);
          transform: translateY(6px) scale(.98);
          opacity:0; visibility:hidden;
          transition: transform .18s cubic-bezier(.4,0,.2,1), opacity .18s, visibility .18s steps(1,end);
        }
        .gen-menu.show{ transform: translateY(0) scale(1); opacity:1; visibility:visible; }
        .gen-item{
          display:flex; align-items:center; gap:10px; padding:10px 12px;
          font-size:13px; border:0; background:transparent; width:180px; text-align:left;
        }
        .gen-item:active{ background:#f6f7fa; }
        .gen-mark{ margin-left:auto; color:#2b84ff; visibility:hidden; }
        .gen-item.checked .gen-mark{ visibility:visible; }

        .cv-empty{ color:#9aa3ad; text-align:center; margin:12px 0; font-size:12px; }

        /* 兜底进入动效（当外层没加 qq-enter-* 时） */
        .chat-fallback-enter-from{
          transform:translate3d(24px,0,0); opacity:.001;
          transition: transform .28s cubic-bezier(.4,0,.2,1), opacity .28s cubic-bezier(.4,0,.2,1);
        }
        .chat-fallback-enter-to{ transform:translate3d(0,0,0); opacity:1; }

        /* ============ 设置子页面（覆盖在 ChatView 内） ============ */
        .cvset{
          position:absolute; inset:0; z-index:6;
          display:flex; flex-direction:column;
          background:var(--bg);
          transform: translate3d(100%,0,0);
          transition: transform .28s cubic-bezier(.4,0,.2,1);
          pointer-events:none;
          will-change: transform;
        }
        .cvset.show{ transform: translate3d(0,0,0); pointer-events:auto; }

        .cvset-top{
          position:sticky; top:0; z-index:2;
          background:rgba(255,255,255,.96);
          border-bottom:1px solid var(--line);
          backdrop-filter:saturate(160%) blur(10px);
          padding: calc(env(safe-area-inset-top, 0px) + var(--island-clearance)) 8px 6px;
          display:flex; align-items:center; justify-content:space-between;
        }
        .cvset-back{ width:28px; height:28px; border:0; background:transparent; border-radius:8px; display:grid; place-items:center; }
        .cvset-back:active{ background:rgba(0,0,0,.06); }
        .cvset-title{ font-weight:700; font-size:14px; margin-left:2px; }

        .cvset-body{ flex:1; overflow:auto; padding:10px; }
        .cvset-body::-webkit-scrollbar{ width:0; height:0; }

        .cvset-card{
          background:#fff; border:1px solid var(--line); border-radius:14px; overflow:hidden; margin-bottom:10px;
        }
        .cvset-row{
          display:flex; align-items:center; gap:10px; padding:12px; font-size:13px; color:#111;
        }
        .cvset-row + .cvset-row{ border-top:1px solid #f0f2f5; }
        .cvset-row .label{ flex:1; min-width:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
        .cvset-row .sub{ font-size:11px; color:#6b7280; }
        .cvset-row .chev{ color:#9aa3ad; }
        .cvset-row.center{ justify-content:center; gap:0; }
        .cvset-danger{ color:#ff4d4f; font-weight:700; }
        .cvset-plus{ background:#eef1f5; color:#6b7280; display:grid; place-items:center; }
        .cvset-plus i{ font-size:28px; transform:translateY(0.08em);}

        .cvset-avatar{ width:44px; height:44px; border-radius:999px; background:#e9eef6 center/cover no-repeat; flex:0 0 auto; }
        .cvset-name{ font-weight:700; }

        /* 群成员栅格 */
        .cvset-grid{ display:grid; grid-template-columns:repeat(5, minmax(0,1fr)); gap:10px 8px; padding:10px 10px 12px; }
        .cvset-mem{ display:flex; flex-direction:column; align-items:center; gap:6px; }
        .cvset-mem .head{ width:42px; height:42px; border-radius:999px; background:#eef2f7 center/cover no-repeat; }
        .cvset-mem .name{ font-size:11px; max-width:56px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color:#374151; }
        .cvset-invite .head{ display:grid; place-items:center; font-size:28px; color:#6b7280; }
        .cvset-invite i{ transform:translateY(0.08em);} 
        .muted{ color:#6b7280; font-size:11.5px; }
        /* —— ChatView 内通用弹窗 —— */
.cv-modal-mask{ position:absolute; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:99; }
.cv-modal-mask.show{ display:flex; }
.cv-modal{ width:86%; max-width:340px; background:#fff; border:1px solid #e8ecf2; border-radius:14px; box-shadow:0 10px 24px rgba(0,0,0,.2); padding:12px; color:#111; }
.cv-modal .title{ font-weight:700; font-size:14px; margin-bottom:8px; }
.cv-field{ display:flex; flex-direction:column; gap:6px; margin:8px 0; }
.cv-field label{ font-size:12px; color:#6b7280; }
.cv-field input{ height:32px; border:1px solid #eef1f5; border-radius:8px; padding:0 10px; outline:none; font-size:13px; background:#fff; color:#111; }
.cv-actions{ display:flex; justify-content:flex-end; gap:8px; margin-top:10px; }
.cv-btn{ border:1px solid #e8ecf2; background:#fff; border-radius:10px; padding:6px 10px; font-size:12px; }
.cv-btn.primary{ background:#2b84ff; color:#fff; border-color:#2b84ff; }
.cv-error{ color:#ff4d4f; font-size:12px; min-height:1.2em; }
.cv-preview{ width:56px; height:56px; border-radius:999px; background:#e9eef6 center/cover no-repeat; border:1px solid #eef1f5; }

      </style>

      <div class="chat-wrap" role="dialog" aria-label="聊天窗口">
        <!-- 顶部栏 -->
        <header class="chat-topbar">
          <div class="chat-left">
            <button class="chat-back" aria-label="返回"><i class="fa-solid fa-angle-left"></i></button>
            <div class="cv-hdr-unread" id="cvHdrUnread" aria-label="其他会话未读"></div>
            <div class="chat-center">
              <div class="chat-name" id="chatTitle">${this.peerName}</div>
              <div class="chat-status" id="chatStatus">在线 · 网络良好</div>
            </div>
          </div>
          <div class="chat-right">
            <button class="chat-more" aria-label="更多"><i class="fi fi-rr-menu-burger"></i></button>
          </div>
        </header>

        <!-- 消息区 -->
        <main class="chat-main" id="cvMain">
          <div class="cv-empty">（示例）与「${this.peerName}」的聊天开始了</div>
        </main>

        <!-- 底部栏 -->
        <footer class="chat-bottom">
          <div class="cv-input-row">
            <input id="cvInput" class="cv-input" placeholder="发个消息…" />
            <button id="cvSend" class="cv-send">发送</button>
          </div>
          <div class="cv-tools" id="cvTools" aria-label="快捷工具">
            <button class="cv-tool-btn" data-key="micro"><img alt="microphone" src="https://i.postimg.cc/dVM9xnDD/micro1.png"></button>
            <button class="cv-tool-btn" data-key="image"><img alt="image" src="https://i.postimg.cc/VvdF3Vj0/image1.png"></button>
            <button class="cv-tool-btn" data-key="camera"><img alt="camera" src="https://i.postimg.cc/sDbnRsHj/camera1.png"></button>
            <button class="cv-tool-btn" data-key="hongbao"><img alt="redpack" src="https://i.postimg.cc/RZfgSy2c/hongbao1.png"></button>
            <button class="cv-tool-btn" data-key="emoji"><img alt="emoji" src="https://i.postimg.cc/cHDmkS8N/emoji1.png"></button>
            <button class="cv-tool-btn" data-key="plus"><img alt="plus" src="https://i.postimg.cc/Bv4Bq6T0/plus1.png"></button>
          </div>
          <div class="cv-expand" id="cvExpand" aria-hidden="true">
  <div class="cv-panel" id="cvPanel" role="region" aria-label="展开区内容"></div>
</div>

        </footer>
                <!-- 触发生成：范围菜单 -->
        <div id="genMenu" class="gen-menu" aria-hidden="true">
          <button class="gen-item" data-scope="all">触发生成（全部会话）<span class="gen-mark">✔︎</span></button>
          <button class="gen-item" data-scope="current">触发生成（仅本会话）<span class="gen-mark">✔︎</span></button>
        </div>

        <!-- 设置子页面（默认隐藏，显示时从右滑入） -->
        <section class="cvset" id="cvSet" aria-label="聊天设置" aria-hidden="true">
          <div class="cvset-top">
            <button class="cvset-back" aria-label="返回"><i class="fa-solid fa-angle-left"></i></button>
            <div class="cvset-title" id="cvSetTitle">${this.kind === 'group' ? '群聊设置' : '聊天设置'}</div>
            <div style="width:28px;height:28px;"></div>
          </div>
          <div class="cvset-body" id="cvSetBody"><!-- 动态填充 --></div>
        </section>
        <!-- 设置对方头像（名字不可编辑） -->
<div class="cv-modal-mask" id="dlgPeerAvatar" aria-hidden="true">
  <div class="cv-modal" role="dialog" aria-label="设置角色头像">
    <div class="title">设置角色头像</div>
    <div class="cv-field">
      <label>联系人名字（不可编辑）</label>
      <input id="peerNameFixed" disabled>
    </div>
    <div class="cv-field">
      <label>头像 URL</label>
      <input id="peerAvatarUrl" placeholder="https://...">
    </div>
    <div style="display:flex; align-items:center; gap:10px;">
      <div class="cv-preview" id="peerAvatarPreview"></div>
      <div class="cv-error" id="peerAvatarErr"></div>
    </div>
    <div class="cv-actions">
      <button class="cv-btn" id="peerAvatarCancel">取消</button>
      <button class="cv-btn primary" id="peerAvatarOK">确定</button>
    </div>
  </div>
</div>

<!-- 设置当前聊天背景（仅作用于本会话） -->
<div class="cv-modal-mask" id="dlgChatBg" aria-hidden="true">
  <div class="cv-modal" role="dialog" aria-label="设置聊天背景">
    <div class="title">设置当前聊天背景</div>
    <div class="cv-field">
      <label>背景图 URL</label>
      <input id="chatBgUrl" placeholder="https://...">
    </div>
    <div class="cv-error" id="chatBgErr"></div>
    <div class="cv-actions">
      <button class="cv-btn" id="chatBgCancel">取消</button>
      <button class="cv-btn primary" id="chatBgOK">确定</button>
    </div>
  </div>
</div>
<!-- 确认：清空聊天记录 -->
<div class="cv-modal-mask" id="dlgConfirmClear" aria-hidden="true">
  <div class="cv-modal" role="dialog" aria-label="确认删除聊天记录">
    <div class="title">确认操作</div>
    <div class="cv-field"><div id="confirmClearText">你确认删除所有聊天记录吗？</div></div>
    <div class="cv-actions">
      <button class="cv-btn" id="confirmClearCancel">取消</button>
      <button class="cv-btn primary" id="confirmClearOK">确定</button>
    </div>
  </div>
</div>

<!-- 确认：删除好友 / 解散群聊（并清空聊天） -->
<div class="cv-modal-mask" id="dlgConfirmDelete" aria-hidden="true">
  <div class="cv-modal" role="dialog" aria-label="确认删除联系人或解散群聊">
    <div class="title">确认操作</div>
    <div class="cv-field"><div id="confirmDeleteText">你确认删除好友/解散群聊（同时清空聊天记录）吗？</div></div>
    <div class="cv-actions">
      <button class="cv-btn" id="confirmDeleteCancel">取消</button>
      <button class="cv-btn primary" id="confirmDeleteOK">确定</button>
    </div>
  </div>
</div>

<!-- 生成返回值解析失败 -->
<div class="cv-modal-mask" id="dlgGenError" aria-hidden="true">
  <div class="cv-modal" role="alertdialog" aria-label="返回值解析失败">
    <div class="title">返回值解析失败</div>
    <div class="cv-field">
      <textarea id="genErrorText" readonly style="height:160px; width:100%; box-sizing:border-box;"></textarea>
    </div>
    <div class="cv-actions">
      <button class="cv-btn" id="genErrorCopy">复制</button>
      <button class="cv-btn primary" id="genErrorOK">确认</button>
    </div>
  </div>
</div>

      </div>
    `;

            // 禁止底部工具栏里的 img 被拖动
            const tools = this.root.querySelector('#cvTools');
            this.root.querySelectorAll('.cv-tool-btn img').forEach(img => {
              img.setAttribute('draggable', 'false');
              img.addEventListener('dragstart', e => e.preventDefault());
            });
            tools.addEventListener('dragstart', e => {
              if (e.target && e.target.tagName === 'IMG') e.preventDefault();
            });

            const $ = sel => this.root.querySelector(sel);

            // === 新增：准备左右两边头像（优先用传入的，没传就从世界书取）===
            const FALLBACK_AVATAR = 'https://files.catbox.moe/pcwffp.jpg';
            let selfAvatar = this.rightAvatar || '';
            let peerAvatar = this.leftAvatar || '';

            (async () => {
              try {
                const wb = await RMPhoneToWorldBook.getApp('qq');
                const node = wb?.login?.[this.login];
                this._wbQQ = wb; // 设置页要用
                this._friendMap = node?.contacts?.friends || {};

                // 我方头像（右边）
                selfAvatar = selfAvatar || node?.avatar || FALLBACK_AVATAR;

                // 对方头像（左边）
                const peerNode =
                  this.kind === 'group'
                    ? node?.contacts?.groups?.[this.peerName]
                    : node?.contacts?.friends?.[this.peerName];
                peerAvatar = peerAvatar || peerNode?.avatar || FALLBACK_AVATAR;

                // 如果消息已渲染过，补刷一下头像
                this.root.querySelectorAll('.cv-row').forEach(row => {
                  const isRight = row.classList.contains('cv-row--right');
                  const ava = row.querySelector('.chat-ava');
                  if (ava) {
                    const url = isRight ? selfAvatar : peerAvatar;
                    ava.style.backgroundImage = `url('${url}')`;
                    ava.style.backgroundPosition = 'center';
                    ava.style.backgroundSize = 'cover';
                    ava.style.backgroundRepeat = 'no-repeat';
                  }
                });

                // 也存回去，供“聊天设置”页用
                this.rightAvatar = selfAvatar;
                this.leftAvatar = peerAvatar;
                // 同步聊天设置页里的头像（私聊）
                const cvAva = this.root.querySelector('#cvSet .cvset-avatar');
                if (cvAva) {
                  cvAva.style.backgroundImage = `url('${peerAvatar}')`;
                  cvAva.style.backgroundPosition = 'center';
                  cvAva.style.backgroundSize = 'cover';
                  cvAva.style.backgroundRepeat = 'no-repeat';
                }
              } catch {}
            })();

            /* 返回 */
            const onBack = () => this.onBack?.();
            $('.chat-back')?.addEventListener('click', onBack);
            this._handlers.push(['.chat-back', 'click', onBack]);

            /* 状态文案（群聊/私聊不同） */
            const chatStatus = $('#chatStatus');
            if (chatStatus) {
              if (this.kind === 'group') {
                chatStatus.textContent = '群聊 · 可 @所有人';
              } else {
                const pool = [
                  '在线 · 今天宜聊天，宜发红包',
                  '手机在线 · 5G 满格',
                  '在线 · 正在敲前端代码',
                  '在线 · 电量 100%',
                  '刚刚活跃',
                ];
                chatStatus.textContent = pool[Math.floor(Math.random() * pool.length)];
              }
            }

            /* 发送消息 → 统一走 Data */
            const main = $('#cvMain');
            // 保持用户体验：如果用户本来就在底部，就继续贴底；否则只把当前元素“尽量滚进视口”，不跳到底
            const keepAtBottomIfUserWasThere = anchorEl => {
              const nearBottom = main.scrollHeight - main.scrollTop - main.clientHeight < 4; // 距离底部 < 4px 视为“贴底”
              requestAnimationFrame(() => {
                if (nearBottom) {
                  main.scrollTop = main.scrollHeight; // 继续贴底
                } else {
                  anchorEl?.scrollIntoView({ block: 'nearest' }); // 轻微滚动，让当前卡片露出来即可
                }
              });
            };
            const input = $('#cvInput');
            const send = $('#cvSend');
            // 进入聊天时：若世界书里有为该会话保存的背景，则应用
            (async () => {
              try {
                const wb = await RMPhoneToWorldBook.getApp('qq');
                const node = wb?.login?.[this.login];
                const friend =
                  this.kind === 'group'
                    ? node?.contacts?.groups?.[this.peerName]
                    : node?.contacts?.friends?.[this.peerName];
                const bg = friend?.chatBg || '';
                if (bg && wrap) {
                  wrap.style.backgroundImage = `url('${bg}')`;
                  wrap.style.backgroundSize = 'cover';
                  wrap.style.backgroundPosition = 'center';
                  wrap.style.backgroundRepeat = 'no-repeat';
                }
              } catch {}
            })();
            const scrollToBottom = () => {
              main.scrollTop = main.scrollHeight + 999;
            };
                const sendNow = ()=>{
      const txt = (input.value||'').trim();
      if(!txt) return;
      RMQQ.Data.pushMsg({ login: this.login, kind: this.kind, peer: this.peerName, type:'txt', args:[txt] });
      input.value=''; scrollToBottom();
    };

    /* —— 新增：生成错误弹窗引用 —— */
const dlgGenError  = this.root.querySelector('#dlgGenError');
const genErrorText = this.root.querySelector('#genErrorText');
const genErrorCopy = this.root.querySelector('#genErrorCopy');
const genErrorOK   = this.root.querySelector('#genErrorOK');

genErrorCopy?.addEventListener('click', ()=> navigator.clipboard?.writeText(genErrorText.value||''));
genErrorOK  ?.addEventListener('click', ()=>{ hideMask(dlgGenError); genErrorText.value=''; });

    // ========= 触发生成：范围菜单 =========
    const genMenu   = $('#genMenu');
    const menuItems = Array.from(genMenu?.querySelectorAll('.gen-item')||[]);
    const getScope = ()=> getGenScope();
    const setScope = (v)=> setGenScope(v);   // 注意：这是 async，调用处不等也没关系
    const refreshMenu = ()=>{
      const cur = getScope();
      menuItems.forEach(it=>{
        const isCur = it.dataset.scope === cur;
        it.classList.toggle('checked', isCur);
      });
    };
    const showGenMenu = ()=>{
      if(!genMenu) return;
      refreshMenu();
      genMenu.classList.add('show');
      genMenu.setAttribute('aria-hidden','false');
      const onOutside = (e)=>{
        if (genMenu.contains(e.target)) return;
        hideGenMenu();
      };
      setTimeout(()=>document.addEventListener('mousedown', onOutside, { once:true }), 0);
      genMenu._off = ()=> document.removeEventListener('mousedown', onOutside);
    };
    const hideGenMenu = ()=>{
      if(!genMenu) return;
      genMenu.classList.remove('show');
      genMenu.setAttribute('aria-hidden','true');
      genMenu._off?.(); genMenu._off=null;
    };
    genMenu?.addEventListener('click', (e)=>{
      const btn = e.target.closest('.gen-item'); if (!btn) return;
      const v = btn.dataset.scope === 'current' ? 'current' : 'all';
      setScope(v); hideGenMenu();
    });

    // ========= 只取“未被回复”的尾巴，拼成 fragment =========
    const collectTail = (scope)=>{
      const data = RMQQ.Data.getState(); // 只读快照
      const accounts = [];
      const addSession = (login, sess)=>{
        if(!sess || !Array.isArray(sess.items)) return;
        const tail=[], arr=sess.items;
        for(let i=arr.length-1;i>=0;i--){
          const it = arr[i];
          if(!it || it.out!==true) break; // 遇到对方消息就停
          tail.push({
            type: it.type,
            speaker: login,                                  // 协议里要显式写发出方
            args: Array.isArray(it.args) ? it.args.map(String) : [],
            content: it.content || ''
          });
        }
        if(!tail.length) return;
        tail.reverse(); // 保持时间顺序
        let acc = accounts.find(a=>a.login===login);
        if(!acc){ acc = { login, sessions: [] }; accounts.push(acc); }
        acc.sessions.push({ kind:sess.kind, peer:sess.peer, items: tail });
      };

      if (scope==='current'){
        const login = this.login, kind = this.kind, peer = this.peerName;
        const acc = (data.accounts||[]).find(a=>a.login===login) || {};
        const sess = (acc.sessions||[]).find(s=>s.kind===kind && s.peer===peer);
        addSession(login, sess);
      } else {
        for (const acc of (data.accounts||[])){
          for (const sess of (acc.sessions||[])){
            if (sess && (sess.kind==='dm' || sess.kind==='group')){
              addSession(acc.login, sess);
            }
          }
        }
      }
      return { qq:{ accounts } };
    };

    // ========= 真正触发 generate =========
    async function triggerGenerate(scope){
      const prevTxt = send.textContent;
      send.disabled = true; send.textContent = '生成中…';
      let raw = '';
      try{
        const fragment   = collectTail(scope);
        const user_input = RMPhoneToChatMessage.buildRaw(fragment);
        if (!user_input.trim()) throw new Error('没有可用的“我方未被回复的尾巴消息”。');

        raw = await generate({ user_input });          // 只用 user_input，其他默认
        const changed = RMQQ.Data.applyRaw(raw);       // 解析→补丁→入库
        if (!changed) throw new Error('返回值为空或未产生任何可入库的消息。');

        scrollToBottom();
      }catch(err){
        console.warn('generate 失败：', err);
        // 把 raw 或错误信息塞进弹窗
        genErrorText.value = String(raw || (err?.message || ''));
        showMask(dlgGenError);
      }finally{
        send.disabled = false; send.textContent = prevTxt;
      }
    }

    // ========= 单击/双击/长按分流器 =========
    const onEnter = (e)=>{ if(e.key==='Enter'){ e.preventDefault(); sendNow(); } };

    let clickTimer = null; const CLICK_GAP = 280;
    let pressTimer = null; const PRESS_MS  = 520;

    function onSendClick(){
      if (clickTimer){
        clearTimeout(clickTimer); clickTimer = null;
        // 双击 → 触发生成（按设置的范围）
        triggerGenerate(getScope());
        return;
      }
      clickTimer = setTimeout(()=>{
        clickTimer = null;
        sendNow(); // 单击 → 发文本
      }, CLICK_GAP);
    }
    function onPressStart(){ if (pressTimer) clearTimeout(pressTimer); pressTimer = setTimeout(()=> showGenMenu(), PRESS_MS); }
    function onPressEnd(){ if (pressTimer){ clearTimeout(pressTimer); pressTimer=null; } }
    function onContext(e){ e.preventDefault(); showGenMenu(); }

    send?.addEventListener('click', onSendClick);
    send?.addEventListener('mousedown', onPressStart);
    send?.addEventListener('mouseup', onPressEnd);
    send?.addEventListener('mouseleave', onPressEnd);
    send?.addEventListener('touchstart', onPressStart, { passive:true });
    send?.addEventListener('touchend', onPressEnd);
    send?.addEventListener('contextmenu', onContext);
    input?.addEventListener('keydown', onEnter);

    this._handlers.push(
      ['#cvSend','click',onSendClick],
      ['#cvSend','mousedown',onPressStart],
      ['#cvSend','mouseup',onPressEnd],
      ['#cvSend','mouseleave',onPressEnd],
      ['#cvSend','touchstart',onPressStart],
      ['#cvSend','touchend',onPressEnd],
      ['#cvSend','contextmenu',onContext],
      ['#cvInput','keydown',onEnter]
    );

            /* 语音/多媒体 切换 */
            main.addEventListener('click', e => {
              const voice = e.target.closest('.cv-voice');
              if (voice) {
                const wrap = voice.parentElement?.classList.contains('cv-voice-wrap') ? voice.parentElement : null;
                const text = wrap?.querySelector('.cv-voice-text');
                if (text) {
                  const open = voice.getAttribute('aria-expanded') === 'true';
                  voice.setAttribute('aria-expanded', open ? 'false' : 'true');
                  text.classList.toggle('cv-hidden', open);
                  keepAtBottomIfUserWasThere(voice);
                }
                return;
              }
              const box = e.target.closest('.cv-dmt');
              if (box) {
                box.classList.toggle('is-open');
                keepAtBottomIfUserWasThere(box);
              }
            });

            /* 工具图标切换（保留你原交互） */
            const iconMap = {
              micro: ['https://i.postimg.cc/dVM9xnDD/micro1.png', 'https://i.postimg.cc/FFBpjh4y/micro2.png'],
              image: ['https://i.postimg.cc/VvdF3Vj0/image1.png', 'https://i.postimg.cc/QxKbmv8R/image2.png'],
              camera: ['https://i.postimg.cc/sDbnRsHj/camera1.png', 'https://i.postimg.cc/tgj2YDH8/camera2.png'],
              hongbao: ['https://i.postimg.cc/RZfgSy2c/hongbao1.png', 'https://i.postimg.cc/76P9N6hV/hongbao2.png'],
              emoji: ['https://i.postimg.cc/cHDmkS8N/emoji1.png', 'https://i.postimg.cc/wBQFJJqM/emoji2.png'],
              plus: ['https://i.postimg.cc/Bv4Bq6T0/plus1.png', 'https://i.postimg.cc/Nj1xqTrD/plus2.png'],
            };
            const expand = $('#cvExpand');
const panel  = $('#cvPanel');

const openAddEmojiDialog = () => {
  let dlg = this.root.querySelector('#dlgAddEmoji');
  if (!dlg){
    dlg = document.createElement('div');
    dlg.id = 'dlgAddEmoji';
    dlg.className = 'cv-modal-mask';
    dlg.setAttribute('aria-hidden', 'true');
    dlg.innerHTML = `
      <div class="cv-modal" role="dialog" aria-label="添加表情">
        <div class="title">添加表情</div>
        <div class="cv-field">
          <label>表情描述</label>
          <input id="aeLabel" placeholder="比如：楚楚可怜" maxlength="20" />
        </div>
        <div class="cv-field">
          <label>表情图片 URL</label>
          <input id="aeUrl" placeholder="完整或短链接，如 ls7328.jpg" />
        </div>
        <div class="cv-error" id="aeErr"></div>
        <div class="cv-actions">
          <button class="cv-btn" id="aeCancel">取消</button>
          <button class="cv-btn primary" id="aeOK">确认</button>
        </div>
      </div>`;
    this.root.querySelector('.chat-wrap')?.appendChild(dlg);

    const CATBOX = 'https://files.catbox.moe/';
    const isFull = s => /^https?:\/\//i.test(String(s || ''));

    const $ = sel => dlg.querySelector(sel);
    $('#aeCancel')?.addEventListener('click', () => {
      dlg.classList.remove('show');
      dlg.setAttribute('aria-hidden', 'true');
    });
    $('#aeOK')?.addEventListener('click', async () => {
      const labelInput = $('#aeLabel');
      const urlInput = $('#aeUrl');
      const err = $('#aeErr');
      const label = (labelInput?.value || '').trim();
      let url = (urlInput?.value || '').trim();
      if (!label || !url){ if (err) err.textContent = '请把描述和 URL 填完整'; return; }
      if (!isFull(url)) url = CATBOX + url;   // 短链接补前缀
      try{
        await RMPhoneToWorldBook.addEmojiToStore?.(label, url);
        dlg.classList.remove('show');
        dlg.setAttribute('aria-hidden', 'true');
        // 写回后刷新 emoji 面板
        renderPanel('emoji');
      }catch(e){
        if (err) err.textContent = '保存失败，请重试';
      }
    });
    // 点击蒙层关闭
    dlg.addEventListener('click', e => { if (e.target === dlg) { dlg.classList.remove('show'); dlg.setAttribute('aria-hidden','true'); } });
  }
  dlg.classList.add('show');
  dlg.setAttribute('aria-hidden', 'false');
}

const renderPanel = (key) => {
  if (!panel) return;

  // 小工具：包一层可滚动 body，让内容在“内容框”里滚动
  const wrap = (html) => `<div class="body cv-expand-scroll">${html}</div>`;

  if (key === 'plus') {
    panel.innerHTML = wrap(`
      <div class="cv-ext-grid">
        <button class="cv-ext-item">
          <div class="box"><i class="fi fi-sr-phone-flip"></i></div><div class="label">语音通话</div>
        </button>
        <button class="cv-ext-item">
          <div class="box"><i class="fi fi-sr-video-camera-alt"></i></div><div class="label">视频通话</div>
        </button>
        <button class="cv-ext-item">
          <div class="box"><i class="fi fi-sr-marker"></i></div><div class="label">位置</div>
        </button>
        <button class="cv-ext-item">
          <div class="box"><i class="fi fi-sr-folder"></i></div><div class="label">文件</div>
        </button>

        <button class="cv-ext-item">
          <div class="box"><i class="fi fi-sr-wishlist-star"></i></div><div class="label">收藏</div>
        </button>
        <button class="cv-ext-item">
          <div class="box"><i class="fi fi-sr-wallet-change"></i></div><div class="label">转账</div>
        </button>
        <button class="cv-ext-item">
          <div class="box"><i class="fi fi-sr-screen-share"></i></div><div class="label">屏幕分享</div>
        </button>
        <button class="cv-ext-item">
          <div class="box"><i class="fi fi-sr-hand-back-point-left"></i></div><div class="label">戳一戳</div>
        </button>

        <button class="cv-ext-item">
          <div class="box"><i class="fi fi-sr-id-card"></i></div><div class="label">名片</div>
        </button>
        <button class="cv-ext-item">
          <div class="box"><i class="fi fi-sr-gift"></i></div><div class="label">礼物</div>
        </button>
        <button class="cv-ext-item">
          <div class="box"><i class="fi fi-sr-earbuds"></i></div><div class="label">一起听歌</div>
        </button>
        <button class="cv-ext-item">
          <div class="box"><i class="fi fi-ss-sack-dollar"></i></div><div class="label">收款</div>
        </button>
      </div>
    `);
    return;
  }

  if (key === 'emoji') {
// 先画出一个空格子容器 + 首格“添加”按钮
panel.innerHTML = wrap(`<div class="cv-ext-grid" id="cvEmojiGrid"></div>`);
const grid = panel.querySelector('#cvEmojiGrid');


// 工具：URL 是否完整 + 规范化（不完整就补 https://files.catbox.moe/）
const CATBOX = 'https://files.catbox.moe/';
const isFull = s => /^https?:\/\//i.test(String(s || ''));
const normUrl = s => (s ? (isFull(s) ? s : CATBOX + s) : '');


// ① 首格：添加表情
const addBtn = document.createElement('button');
addBtn.className = 'cv-ext-item add';
addBtn.innerHTML = '<div class="box"><i class="fi fi-rr-add"></i></div><div class="label">添加表情</div>';
addBtn.addEventListener('click', () => openAddEmojiDialog());
grid.appendChild(addBtn);


// ② 从世界书读取 <bqb>…</bqb> 内容，解析 [描述|url]
(async () => {
try {
await RMPhoneToWorldBook.ensureQQEmojiStore?.();
const txt = (await RMPhoneToWorldBook.readQQEmojiStore?.()) || '';
const m = txt.match(/<bqb>([\s\S]*?)<\/bqb>/i);
const body = m ? m[1] : '';
const lines = body.split(/\r?\n/).map(s => s.trim()).filter(Boolean);


for (const line of lines) {
const mm = line.match(/\[([^|\]]+)\|([^\]]+)\]/); // [label|url]
if (!mm) continue;
const label = mm[1].trim();
const rawUrl = mm[2].trim();
const url = normUrl(rawUrl);


const btn = document.createElement('button');
btn.className = 'cv-ext-item';
btn.innerHTML = `
<div class="box"><img alt="${label}"></div>
<div class="label"></div>`;
btn.querySelector('img').src = url;
btn.querySelector('.label').textContent = label;
btn.addEventListener('click', () => {
// 直接作为“我方消息”发送到聊天里（type:'bqb'）
RMQQ.Data.pushMsg({
login: this.login,
kind: this.kind,
peer: this.peerName,
type: 'bqb',
args: [label, url]
});
});
grid.appendChild(btn);
}
} catch (e) {
console.warn('读取表情库失败：', e);
}
})();


return; // 这里必须 return；保持和其它分支一致
}

  if (key === 'micro') {
    // 语音：中间一个“按住说话”大圆钮
    panel.innerHTML = wrap(`
      <div style="height:100%;display:grid;place-items:center;">
        <button style="width:66%;aspect-ratio:1;border-radius:999px;border:1px solid var(--line);background:#fff;font-size:16px;">
          按住 说话
        </button>
      </div>
    `);
    return;
  }

  if (key === 'hongbao') {
    // 红包相关的快捷键
    panel.innerHTML = wrap(`
      <div class="cv-ext-grid">
        <button class="cv-ext-item"><div class="box"><i class="fi fi-ss-sack-dollar"></i></div><div class="label">发红包</div></button>
        <button class="cv-ext-item"><div class="box"><i class="fi fi-rr-wallet"></i></div><div class="label">转账</div></button>
        <button class="cv-ext-item"><div class="box"><i class="fi fi-rr-barcode-scan"></i></div><div class="label">收款码</div></button>
        <button class="cv-ext-item"><div class="box"><i class="fi fi-rr-move-to-folder-2"></i></div><div class="label">文件</div></button>
      </div>
    `);
    return;
  }

  // 其它键不渲染
  panel.innerHTML = '';
}

function setExpand(open, key){
  const wasOpen = expand.classList.contains('show');
  expand.classList.toggle('show', open);
  expand.setAttribute('aria-hidden', open ? 'false' : 'true');

  if (open) {
  // 只在“从收起 → 展开”的那一刻计算一次；切 panel 不重复算
  if (!wasOpen) {
    const ref = $('.chat-wrap')?.clientHeight || window.innerHeight;
    const h = Math.round(ref * 0.3); // 想改比例就改 0.38
    expand.style.setProperty('--cv-expand-h', h + 'px');
  }
  renderPanel(key);
  keepAtBottomIfUserWasThere(expand);
} else {
  // 关闭时清理变量，回到 0 或下次重新计算
  expand.style.removeProperty('--cv-expand-h');
}
}

const onToolClick = e => {
  const btn = e.target.closest('.cv-tool-btn[data-key]');
  if (!btn) return;
  const key = btn.dataset.key;

  // 工具图标“1/2 态”保持你的原逻辑
  const img = btn.querySelector('img');
  if (img && iconMap[key]) {
    const cur = btn.dataset.state === '2' ? 2 : 1;
    const next = cur === 1 ? 2 : 1;
    img.src = iconMap[key][next - 1];
    btn.dataset.state = String(next);
  }

  // 这四个键共用展开区；点相同的键 = 收起；点不同键 = 切换内容
  const keys = ['plus','emoji','micro','hongbao'];
  if (keys.includes(key)) {
    const isOpen = expand.classList.contains('show');
    const same   = btn.classList.contains('is-active');

    // 先清除其它键的激活态
    this.root.querySelectorAll('.cv-tool-btn.is-active').forEach(b => b.classList.remove('is-active'));
    // 同时把其它键的图标复原到第1态
this.root.querySelectorAll('.cv-tool-btn[data-key]').forEach(b => {
  if (b !== btn) {
    b.dataset.state = '1';
    const k = b.dataset.key;
    const im = b.querySelector('img');
    if (im && iconMap[k]) im.src = iconMap[k][0];
  }
});

    if (isOpen && same) {
      setExpand(false);
      return;
    }
    btn.classList.add('is-active');
    setExpand(true, key);
    return;
  }

  // 其它键：收起
  if (expand.classList.contains('show')) setExpand(false);
};

            $('#cvTools')?.addEventListener('click', onToolClick);
            this._handlers.push(['#cvTools', 'click', onToolClick]);

            /* 兜底进入动效 */
            const hostScreen = this.root.closest('.qq-screen');
            const needFallback =
              !hostScreen ||
              (!hostScreen.classList.contains('qq-enter-from') && !hostScreen.classList.contains('qq-enter-to'));
            if (needFallback) {
              const cw = this.root.querySelector('.chat-wrap');
              cw.classList.add('chat-fallback-enter-from');
              requestAnimationFrame(() => {
                void cw.offsetWidth;
                cw.classList.add('chat-fallback-enter-to');
                const done = () => cw.classList.remove('chat-fallback-enter-from', 'chat-fallback-enter-to');
                cw.addEventListener('transitionend', done, { once: true });
              });
            }

            /* ===== 设置子页面：渲染 + 打开/返回（保留原交互） ===== */
            const cvSet = $('#cvSet');
            const cvSetBody = $('#cvSetBody');
            const cvSetTitle = $('#cvSetTitle');

            const renderDM = () => {
              const ava = this.leftAvatar ? `style="background-image:url('${this.leftAvatar}')" ` : '';
              return `
        <div class="cvset-card">
          <div class="cvset-row">
            <div class="cvset-avatar" ${ava}></div>
            <div class="label">
              <div class="cvset-name">${this.peerName}</div>
            </div>
            <i class="fi fi-rr-angle-small-right chev"></i>
          </div>
          <div class="cvset-row">
            <div class="cvset-avatar cvset-plus"><i class="fi fi-rr-plus-small"></i></div>
            <div class="label">发起群聊</div>
          </div>
        </div>
        <div class="cvset-card">
          <div class="cvset-row" data-act="set-peer-avatar"><div class="label">设置角色头像（对方的）</div><i class="fi fi-rr-angle-small-right chev"></i></div>
          <div class="cvset-row" data-act="set-chat-bg"><div class="label">设置当前聊天背景</div><i class="fi fi-rr-angle-small-right chev"></i></div>
          <div class="cvset-row"><div class="label">设置聊天页面缩放</div><i class="fi fi-rr-angle-small-right chev"></i></div>
          <div class="cvset-row" data-act="clear-chat"><div class="label">删除所有聊天记录</div><i class="fi fi-rr-angle-small-right chev"></i></div>
        </div>
        <div class="cvset-card"><div class="cvset-row center cvset-danger" data-act="delete-friend">删除好友</div></div>
      `;
            };

            const renderGroup = () => {
              const wb = this._wbQQ || {};
              const node = wb?.login?.[this.login] || {};
              const g = node?.contacts?.groups?.[this.peerName] || {};

              // 1) 优先用世界书里记的 members
              let names = Array.isArray(g.members) ? g.members.slice(0) : [];

              // 2) 如果没记 members，就从聊天记录里扫描 speaker
              if (!names.length) {
                try {
                  const st = RMQQ.Data.getState();
                  const acc = (st.accounts || []).find(a => a.login === this.login) || (st.accounts || [])[0] || {};
                  const sess = (acc.sessions || []).find(s => s.kind === 'group' && s.peer === this.peerName) || {};
                  const set = new Set();
                  for (const m of sess.items || []) {
                    if (m && m.speaker) set.add(m.speaker);
                  }
                  names = Array.from(set);
                } catch {}
              }

              // 3) 把自己也放进去（去重）
              if (this.login && !names.includes(this.login)) names.unshift(this.login);

              // 头像：自己=账号头像；其他=好友头像；都没有用默认
              const fallback = 'https://files.catbox.moe/pcwffp.jpg';
              const memHTML =
                names
                  .map(n => {
                    const ava =
                      n === this.login ? node?.avatar || fallback : node?.contacts?.friends?.[n]?.avatar || fallback;
                    return `
      <div class="cvset-mem">
        <div class="head" style="background-image:url('${ava}');"></div>
        <div class="name">${n}</div>
      </div>`;
                  })
                  .join('') +
                `
    <div class="cvset-mem cvset-invite">
      <div class="head"><i class="fi fi-rr-plus-small"></i></div>
      <div class="name">邀请</div>
    </div>`;

              const grpAva = g?.avatar || fallback;

              return `
    <div class="cvset-card">
      <div class="cvset-row">
        <div class="cvset-avatar" style="background-image:url('${grpAva}');"></div>
        <div class="label">
          <div class="cvset-name">${this.peerName}</div>
          <div class="muted">群聊介绍：在这里，发现更多~</div>
        </div>
        <i class="fi fi-rr-angle-small-right chev"></i>
      </div>
    </div>

    <div class="cvset-card">
      <div class="cvset-row">
        <div class="label">群聊成员</div>
        <div class="muted">查看${names.length}名群成员</div>
        <i class="fi fi-rr-angle-small-right chev"></i>
      </div>
      <div class="cvset-grid">${memHTML}</div>
    </div>

    <div class="cvset-card">
      <div class="cvset-row" data-act="set-group-avatar"><div class="label">设置群聊头像</div><i class="fi fi-rr-angle-small-right chev"></i></div>
      <div class="cvset-row" data-act="set-chat-bg"><div class="label">设置当前聊天背景</div><i class="fi fi-rr-angle-small-right chev"></i></div>
      <div class="cvset-row"><div class="label">设置聊天页面缩放</div><i class="fi fi-rr-angle-small-right chev"></i></div>
      <div class="cvset-row" data-act="clear-chat"><div class="label">删除所有聊天记录</div><i class="fi fi-rr-angle-small-right chev"></i></div>
    </div>
    <div class="cvset-card"><div class="cvset-row center cvset-danger" data-act="disband-group">解散群聊</div></div>
    <div class="cvset-card"><div class="cvset-row center cvset-danger">退出群聊</div></div>
  `;
            };

            const renderSettings = () => {
              cvSetTitle.textContent = this.kind === 'group' ? '群聊设置' : '聊天设置';
              cvSetBody.innerHTML = this.kind === 'group' ? renderGroup() : renderDM();
            };
            renderSettings();

            const openSettings = () => {
              cvSet.classList.add('show');
              cvSet.setAttribute('aria-hidden', 'false');
            };
            const closeSettings = () => {
              cvSet.classList.remove('show');
              cvSet.setAttribute('aria-hidden', 'true');
            };

            const onMore = () => {
              renderSettings();
              openSettings();
            };
            const onSetBack = () => closeSettings();
            $('.chat-more')?.addEventListener('click', onMore);
            $('#cvSet .cvset-back')?.addEventListener('click', onSetBack);
            this._handlers.push(['.chat-more', 'click', onMore], ['#cvSet .cvset-back', 'click', onSetBack]);
            // 打开“设置角色头像 / 聊天背景”的弹窗（只在私聊生效）
            cvSetBody.addEventListener('click', e => {
              const row = e.target.closest('.cvset-row');
              if (!row) return;
              const act = row.dataset.act || '';
              if (act === 'set-peer-avatar' && this.kind === 'dm') openPeerAvatarDialog(); // 私聊：对方头像
              if (act === 'set-group-avatar' && this.kind === 'group') openGroupAvatarDialog(); // 群聊：群头像
              if (act === 'set-chat-bg') openChatBgDialog(); // 两边都可以
              // —— 新增：清空聊天记录（DM 和群都可以）——
              if (act === 'clear-chat') {
                // 第4步里会加 showMask/hideMask，这里先调用即可
                showMask(this.root.querySelector('#dlgConfirmClear'));
              }

              // —— 新增：删除好友（只在私聊生效）——
              if (act === 'delete-friend' && this.kind === 'dm') {
                const box = this.root.querySelector('#dlgConfirmDelete');
                box.querySelector('#confirmDeleteText').textContent = '你确认删除好友（同时清空聊天记录）吗？';
                showMask(box);
              }

              // —— 新增：解散群聊（只在群聊生效）——
              if (act === 'disband-group' && this.kind === 'group') {
                const box = this.root.querySelector('#dlgConfirmDelete');
                box.querySelector('#confirmDeleteText').textContent = '你确认解散群聊（同时清空聊天记录）吗？';
                showMask(box);
              }
            });

            // —— 共用小工具 —— //
            const showMask = el => {
              el.classList.add('show');
              el.setAttribute('aria-hidden', 'false');
            };
            const hideMask = el => {
              el.classList.remove('show');
              el.setAttribute('aria-hidden', 'true');
            };

            /* —— 触发生成：范围读写（世界书） —— */
const getGenScope = () => (this._wbQQ?.prefs?.generateScope) || 'all';

const setGenScope = async (v) => {
  const scope = (v === 'current') ? 'current' : 'all';
  // 1) 取世界书里 QQ 的对象（this._wbQQ 若无，就从世界书读）
  let wb = (this._wbQQ && typeof this._wbQQ==='object') ? this._wbQQ : await RMPhoneToWorldBook.getApp('qq').catch(()=>({})) || {};
  (wb.prefs ||= {}).generateScope = scope;

  // 2) 保存回世界书，并把内存里的 this._wbQQ 更新为保存后的对象
  this._wbQQ = await RMPhoneToWorldBook.saveApp('qq', wb);

  // 3) 刷新菜单勾选（如果菜单存在）
  this.root.querySelectorAll('#genMenu .gen-item').forEach(btn=>{
    btn.classList.toggle('checked', btn.dataset.scope === getGenScope());
  });
};

            // —— 设置“对方头像” —— //
            const dlgAva = $('#dlgPeerAvatar');
            const iptNameFixed = $('#peerNameFixed');
            const iptAva = $('#peerAvatarUrl');
            const preAva = $('#peerAvatarPreview');
            const errAva = $('#peerAvatarErr');
            const btnAvaOK = $('#peerAvatarOK');
            const btnAvaCancel = $('#peerAvatarCancel');

            const openPeerAvatarDialog = async () => {
              iptNameFixed.value = this.peerName; // 名字不可编辑
              errAva.textContent = '';
              try {
                const wb = await RMPhoneToWorldBook.getApp('qq');
                const node = wb?.login?.[this.login];
                const friend = node?.contacts?.friends?.[this.peerName];
                const curUrl = friend?.avatar || this.leftAvatar || 'https://files.catbox.moe/pcwffp.jpg';
                iptAva.value = curUrl;
                preAva.style.backgroundImage = `url('${curUrl}')`;
              } catch {
                iptAva.value = '';
                preAva.style.backgroundImage = 'none';
              }
              showMask(dlgAva);
            };

            iptAva?.addEventListener('input', () => {
              const u = (iptAva.value || '').trim();
              preAva.style.backgroundImage = u ? `url('${u}')` : 'none';
            });

            btnAvaCancel?.addEventListener('click', () => hideMask(dlgAva));
            btnAvaOK?.addEventListener('click', async () => {
              const url = (iptAva.value || '').trim();
              if (!url) {
                errAva.textContent = '请输入头像 URL';
                return;
              }

              // 写入世界书
              const wb = (await RMPhoneToWorldBook.getApp('qq').catch(() => ({}))) || {};
              wb.login ||= {};
              wb.login[this.login] ||= {
                avatar: 'https://files.catbox.moe/pcwffp.jpg',
                contacts: { friends: {}, groups: {} },
              };
              wb.login[this.login].contacts ||= { friends: {}, groups: {} };

              if (this.kind === 'group') {
                wb.login[this.login].contacts.groups ||= {};
                wb.login[this.login].contacts.groups[this.peerName] ||= {};
                wb.login[this.login].contacts.groups[this.peerName].avatar = url;
              } else {
                wb.login[this.login].contacts.friends ||= {};
                wb.login[this.login].contacts.friends[this.peerName] ||= {};
                wb.login[this.login].contacts.friends[this.peerName].avatar = url;
              }
              await RMPhoneToWorldBook.saveApp('qq', wb);

              // 本视图即时刷新：左侧头像 + 设置页头像
              this.leftAvatar = url;
              this.root.querySelectorAll('.cv-row--left .chat-ava').forEach(ava => {
                ava.style.backgroundImage = `url('${url}')`;
                ava.style.backgroundPosition = 'center';
                ava.style.backgroundSize = 'cover';
                ava.style.backgroundRepeat = 'no-repeat';
              });
              const cvAva = this.root.querySelector('#cvSet .cvset-avatar');
              if (cvAva) {
                cvAva.style.backgroundImage = `url('${url}')`;
                cvAva.style.backgroundPosition = 'center';
                cvAva.style.backgroundSize = 'cover';
                cvAva.style.backgroundRepeat = 'no-repeat';
              }

              // 通知外层（消息列表、联系人列表等）同步：TabsView 会监听这个事件
              window.dispatchEvent(
                new CustomEvent('rmqq:peer-avatar-updated', {
                  detail: { login: this.login, kind: 'dm', peer: this.peerName, avatar: url },
                }),
              );

              if (this.kind === 'group') {
                const cvAva = this.root.querySelector('#cvSet .cvset-avatar');
                if (cvAva) {
                  cvAva.style.backgroundImage = `url('${url}')`;
                  cvAva.style.backgroundPosition = 'center';
                  cvAva.style.backgroundSize = 'cover';
                  cvAva.style.backgroundRepeat = 'no-repeat';
                }
              }

              hideMask(dlgAva);
            });

            // —— 设置“群聊头像” —— //
            const openGroupAvatarDialog = async () => {
              iptNameFixed.value = this.peerName; // 标题里显示群名
              errAva.textContent = '';
              try {
                const wb = await RMPhoneToWorldBook.getApp('qq');
                const node = wb?.login?.[this.login];
                const group = node?.contacts?.groups?.[this.peerName];
                const curUrl = group?.avatar || 'https://files.catbox.moe/pcwffp.jpg';
                iptAva.value = curUrl;
                preAva.style.backgroundImage = `url('${curUrl}')`;
              } catch {
                iptAva.value = '';
                preAva.style.backgroundImage = 'none';
              }
              showMask(dlgAva);
            };

            // —— 设置“当前聊天背景” —— //
            const dlgBg = $('#dlgChatBg');
            const iptBg = $('#chatBgUrl');
            const errBg = $('#chatBgErr');
            const btnBgOK = $('#chatBgOK');
            const btnBgCancel = $('#chatBgCancel');
            /* —— 新增：删除/清空 弹窗元素引用 —— */
            const dlgClear = $('#dlgConfirmClear');
            const btnClearOK = $('#confirmClearOK');
            const btnClearCancel = $('#confirmClearCancel');

            const dlgDel = $('#dlgConfirmDelete');
            const btnDelOK = $('#confirmDeleteOK');
            const btnDelCancel = $('#confirmDeleteCancel');

            const applyChatBg = url => {
              const wrap = this.root.querySelector('.chat-wrap');
              if (!wrap) return;
              if (url) {
                wrap.style.backgroundImage = `url('${url}')`;
                wrap.style.backgroundSize = 'cover';
                wrap.style.backgroundPosition = 'center';
                wrap.style.backgroundRepeat = 'no-repeat';
              } else {
                wrap.style.removeProperty('background-image');
              }
            };

            const openChatBgDialog = async () => {
              errBg.textContent = '';
              try {
                const wb = await RMPhoneToWorldBook.getApp('qq');
                const node = wb?.login?.[this.login];
                const friend =
                  this.kind === 'group'
                    ? node?.contacts?.groups?.[this.peerName]
                    : node?.contacts?.friends?.[this.peerName];
                iptBg.value = friend?.chatBg || '';
              } catch {
                iptBg.value = '';
              }
              showMask(dlgBg);
            };

            btnBgCancel?.addEventListener('click', () => hideMask(dlgBg));
            btnBgOK?.addEventListener('click', async () => {
              const url = (iptBg.value || '').trim();
              // 保存到世界书（挂在该联系人的节点下）
              const wb = (await RMPhoneToWorldBook.getApp('qq').catch(() => ({}))) || {};
              wb.login ||= {};
              wb.login[this.login] ||= {
                avatar: 'https://files.catbox.moe/pcwffp.jpg',
                contacts: { friends: {}, groups: {} },
              };
              wb.login[this.login].contacts ||= { friends: {}, groups: {} };
              const bag =
                this.kind === 'group'
                  ? (wb.login[this.login].contacts.groups ||= {})
                  : (wb.login[this.login].contacts.friends ||= {});
              bag[this.peerName] ||= {};
              bag[this.peerName].chatBg = url;
              await RMPhoneToWorldBook.saveApp('qq', wb);

              // 本视图即时应用
              applyChatBg(url);

              hideMask(dlgBg);
            });

            /* —— 新增：执行动作 —— */
            const doClearChat = async () => {
              try {
                RMQQ.Data.deleteSession?.({ login: this.login, kind: this.kind, peer: this.peerName });
                const main = this.root.querySelector('#cvMain');
                if (main)
                  main.innerHTML =
                    '<div class="cv-empty" style="color:#9aa3ad;text-align:center;padding:24px;">已清空</div>';
                // —— 广播：通知 TabsView 把该聊天行移除 + 刷新联系人 —— //
                window.dispatchEvent(
                  new CustomEvent('rmqq:chat-deleted', {
                    detail: { login: this.login, kind: this.kind, peer: this.peerName },
                  }),
                );
              } finally {
                hideMask(dlgClear);
              }
            };

            const doDeleteContact = async () => {
              try {
                // 1) 世界书里删联系人/群
                const wb = (await RMPhoneToWorldBook.getApp('qq').catch(() => ({}))) || {};
                wb.login ||= {};
                wb.login[this.login] ||= {
                  avatar: 'https://files.catbox.moe/pcwffp.jpg',
                  contacts: { friends: {}, groups: {} },
                };
                wb.login[this.login].contacts ||= { friends: {}, groups: {} };

                if (this.kind === 'group') {
                  delete (wb.login[this.login].contacts.groups || {})[this.peerName];
                } else {
                  delete (wb.login[this.login].contacts.friends || {})[this.peerName];
                }
                await RMPhoneToWorldBook.saveApp('qq', wb);
                this._wbQQ = wb;

                // 2) 本地头像索引也去掉（有就删）
                const key = `${this.login}|${this.kind === 'group' ? 'group' : 'dm'}|${this.peerName}`;
                this._avatarMap?.delete?.(key);

                // 3) 删会话（同步把写回里的 [DM]/[GROUP] 整块移除）
                RMQQ.Data.deleteSession?.({ login: this.login, kind: this.kind, peer: this.peerName });
                // —— 广播：通知 TabsView 同步 WB 并刷新联系人 —— //
                window.dispatchEvent(
                  new CustomEvent('rmqq:chat-deleted', {
                    detail: { login: this.login, kind: this.kind, peer: this.peerName },
                  }),
                );

                // 4) 刷新联系人视图
                if (typeof renderContactsFromWB === 'function') {
                  renderContactsFromWB(this.kind === 'group' ? 'groups' : 'friends');
                }

                // 5) 清空当前聊天画面
                const main = this.root.querySelector('#cvMain');
                if (main)
                  main.innerHTML =
                    '<div class="cv-empty" style="color:#9aa3ad;text-align:center;padding:24px;">已清空</div>';
              } finally {
                hideMask(dlgDel); // 关“确认”弹窗
                closeSettings(); // 关“聊天设置”抽屉（就是有返回箭头的那块）
                this.onBack?.(); // 退出 ChatView，回到列表页
              }
            };

            /* —— 新增：确认弹窗按钮绑定 —— */
            btnClearCancel?.addEventListener('click', () => hideMask(dlgClear));
            btnClearOK?.addEventListener('click', doClearChat);

            btnDelCancel?.addEventListener('click', () => hideMask(dlgDel));
            btnDelOK?.addEventListener('click', doDeleteContact);

            /* 初始滚动到底（数据渲染后也会滚动） */
            const scrollToBottomInit = () => {
              main.scrollTop = main.scrollHeight + 999;
            };
            scrollToBottomInit();

            /* ============== 数据订阅：渲染历史 + 追加新消息 ============== */
            // 替换 ChatView.mount 里的 renderOne：
            const renderOne = it => {
              const row = document.createElement('div');
              row.className = 'cv-row ' + (it.out ? 'cv-row--right' : 'cv-row--left');

              const args = Array.isArray(it.args) ? it.args : [];
              const friendMap = this._friendMap || {};
              const makeAvatar = () => {
                const a = document.createElement('div');
                a.className = 'chat-ava';
                let url;
                if (it.out) {
                  url = selfAvatar || FALLBACK_AVATAR;
                } else if (this.kind === 'group') {
                  // 群聊：按发言人拿头像（优先好友头像）
                  url = friendMap?.[it.speaker]?.avatar || FALLBACK_AVATAR;
                } else {
                  // 私聊：仍用对方头像
                  url = peerAvatar || FALLBACK_AVATAR;
                }
                a.style.backgroundImage = `url('${url}')`;
                a.style.backgroundPosition = 'center';
                a.style.backgroundSize = 'cover';
                a.style.backgroundRepeat = 'no-repeat';
                return a;
              };
              const appendLR = node => {
                let payload = node;
                if (!it.out && this.kind === 'group') {
                  const box = document.createElement('div');
                  box.className = 'cv-wrap';
                  const name = document.createElement('div');
                  name.className = 'cv-name';
                  name.textContent = it.speaker || '';
                  box.appendChild(name);
                  box.appendChild(node);
                  payload = box;
                }
                it.out
                  ? (row.appendChild(payload), row.appendChild(makeAvatar()))
                  : (row.appendChild(makeAvatar()), row.appendChild(payload));
              };
              const isUrl = s => /^https?:\/\/\S+/.test(String(s || ''));
              const pickUrl = s => {
                const m = String(s || '').match(/https?:\/\/\S+/);
                return m ? m[0] : '';
              };

              if (it.type === 'bqb') {
  // args: [描述, 图片URL]
  const desc = args[0] ?? '表情包';

  // 规则：完整 http(s) 则直用；否则补 https://files.catbox.moe/
  const CATBOX = 'https://files.catbox.moe/';
  const isFull = s => /^https?:\/\//i.test(String(s || ''));
  const normUrl = s => (s ? (isFull(s) ? s : CATBOX + s) : '');

  // 1) 优先用 args[1]；2) 不完整就补前缀；
  // 3) 实在没有就从文本里挑一个 http 链接；
  // 4) 如果文本里只有类似 ls7328.jpg 这样的“短链接”，也识别并补前缀；
  // 5) 最后兜底用占位图。
  const raw = (args[1] || '').trim() || (args[0] || it.content || '').trim();

  // 抓“文件名.后缀”这种短链接（不带 http）
  const fileLike = raw.match(/\S+\.(?:png|jpe?g|gif|webp|svg)/i)?.[0] || '';

  // isUrl / pickUrl 是你文件里原有的小函数（保持不动）
  const candidate = isUrl(raw) ? raw : (fileLike || pickUrl(raw));
  const url = candidate ? normUrl(candidate) : 'https://i.postimg.cc/7P4Qj0sS/emoji-demo.png';

  const box = document.createElement('div');
  box.className = 'cv-bqb';
  const img = document.createElement('img');
  img.src = url;
  img.alt = String(desc);
  box.appendChild(img);
  appendLR(box);
} else if (it.type === 'voice') {
                // args: [秒数, 转文字]
                const dur = (args[0] ?? '').toString().trim();
                const text = args[1] ?? '';
                const wrap = document.createElement('div');
                wrap.className = 'cv-voice-wrap';
                const voice = document.createElement('div');
                voice.className = 'cv-voice';
                voice.setAttribute('role', 'button');
                voice.setAttribute('aria-expanded', 'false');
                if (dur) voice.setAttribute('data-dur', dur);
                const ico = document.createElement('i');
                ico.className = 'fi fi-rr-feedback-cycle-loop';
                voice.appendChild(ico);
                const t = document.createElement('div');
                t.className = 'cv-voice-text cv-txt cv-hidden';
                t.textContent = text;
                wrap.appendChild(voice);
                wrap.appendChild(t);
                appendLR(wrap);
              } else if (it.type === 'dmt') {
                // args: [说明文本]
                const txt = args[0] ?? '';
                const box = document.createElement('div');
                box.className = 'cv-dmt';
                box.title = '点击展开/收起';
                const mask = document.createElement('div');
                mask.className = 'cv-dmt-mask';
                const icon = document.createElement('i');
                icon.className = 'fi fi-rr-screen-play';
                mask.appendChild(icon);
                const body = document.createElement('div');
                body.className = 'cv-dmt-text';
                body.textContent = txt;
                box.appendChild(mask);
                box.appendChild(body);
                appendLR(box);
              } else if (it.type === 'file') {
                // args: [文件名, 大小]
                const fname = args[0] ?? '未命名文件';
                const fsize = args[1] ?? '';
                const card = document.createElement('div');
                card.className = 'cv-file';
                const info = document.createElement('div');
                info.className = 'cv-file-info';
                const name = document.createElement('div');
                name.className = 'cv-file-name';
                name.textContent = fname;
                const meta = document.createElement('div');
                meta.className = 'cv-file-meta';
                meta.textContent = fsize;
                info.appendChild(name);
                info.appendChild(meta);
                const ico = document.createElement('div');
                ico.className = 'cv-file-ico';
                const ii = document.createElement('i');
                ii.className = 'fi fi-sr-file';
                ico.appendChild(ii);
                card.appendChild(info);
                card.appendChild(ico);
                appendLR(card);
              } else {
                // txt / 其他：args[0] 作为文本
                const bubble = document.createElement('div');
                bubble.className = 'cv-txt';
                bubble.textContent = args[0] ?? '';
                appendLR(bubble);
              }

              main.appendChild(row);
            };

            this._unsubChat = RMQQ.Data.subscribeChat(
              { login: this.login, kind: this.kind, peer: this.peerName },
              e => {
                if (e.type === 'init') {
                  main.innerHTML = '';
                  e.items.forEach(renderOne);
                  scrollToBottom();
                } else if (e.type === 'append') {
                  e.items.forEach(renderOne);
                  scrollToBottom();
                }
              },
            );

            RMQQ.Data.setActiveChat?.({ login: this.login, kind: this.kind, peer: this.peerName });
RMQQ.Data.markRead?.({ login: this.login, kind: this.kind, peer: this.peerName });

const hdr = this.root.querySelector('#cvHdrUnread');
this._offHdrUnread?.();
this._offHdrUnread = RMQQ.Data.subscribeUnreadOfLogin?.(
  { login: this.login, exclude: { kind: this.kind, peer: this.peerName } },
  total => {
    if (!hdr) return;
    const n = Math.max(0, parseInt(total || 0, 10) || 0);
    if (n > 0) {
      hdr.textContent = n > 99 ? '99+' : String(n);
      hdr.classList.add('show');
    } else {
      hdr.classList.remove('show');
    }
  }
);

            // 下面两段保留（与 Tabs 的点击打开行为一致，防止重复绑定）
            const chatList = this.root.querySelector('.page--chats #chatList');
            if (chatList && !chatList.__rmqqDelegated) {
              chatList.__rmqqDelegated = true;
              chatList.addEventListener('click', e => {
                const li = e.target.closest('li.item');
                if (!li) return;
                if (e.target.closest('.actions')) return;
                const title = li.querySelector('.title')?.textContent?.trim();
                const kind = li.dataset.kind === 'group' ? 'group' : 'dm';
                if (title) this.onOpenChat?.({ kind, peer: title, login: this.login });
              });
            }
          }

          onShow() {}

          unmount() {
            this._unsubChat?.();
            this._unsubChat = null;
            this._offHdrUnread?.(); this._offHdrUnread = null;
            RMQQ.Data.clearActiveChat?.();
            for (const [sel, type, fn] of this._handlers) {
              try {
                this.root.querySelector(sel)?.removeEventListener(type, fn);
              } catch {}
            }
            this._handlers.length = 0;
            this.root = null;
          }
        }

        /* ----------------- SpaceView ----------------- */
        class SpaceView {
          constructor({ onBack } = {}) {
            this.key = 'space';
            this.keepAlive = false;
            this.onBack = onBack;
            this.root = null;
          }

          mount(container) {
            this.root = container;
            this.root.innerHTML = `
      <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css"
        crossorigin="anonymous" referrerpolicy="no-referrer">
      <style>
        .space-wrap{ position:absolute; inset:0; background:#fff; display:flex; flex-direction:column; color:#111; }
        .space-top{
          position:sticky; top:0; z-index:5; background:rgba(255,255,255,.96);
          backdrop-filter:saturate(160%) blur(10px);
          border-bottom:1px solid #e8ecf2; display:flex; align-items:center; gap:8px;
          padding: calc(env(safe-area-inset-top, 0px) + 10px) 8px 8px;
        }
        .space-top .back{ border:0; background:transparent; width:32px; height:32px; border-radius:10px; display:grid; place-items:center; }
        .space-top .back:active{ background:rgba(0,0,0,.06); }
        .space-title{ font-weight:700; font-size:14px; }
        .space-body{ flex:1; overflow:auto; padding:12px; }
        .space-body::-webkit-scrollbar{ width:0; height:0; }
        .card{
          border:1px solid #eef1f5; border-radius:14px; padding:12px; margin-bottom:12px; background:#fafbfc;
        }
        .muted{ color:#6b7280; font-size:12px; }
      </style>
      <div class="space-wrap" role="dialog" aria-label="空间">
        <div class="space-top">
          <button class="back" aria-label="返回"><i class="fa-solid fa-angle-left"></i></button>
          <div class="space-title">QQ 空间</div>
        </div>
        <div class="space-body">
          <div class="card">
            <div class="muted">（占位）这里放空间动态入口/卡片…</div>
          </div>
          <div class="card">
            <div class="muted">你可以后续把真实数据塞进来</div>
          </div>
        </div>
      </div>
      `;
            this.root.querySelector('.back')?.addEventListener('click', () => this.onBack?.());
          }

          onShow() {
            /* 返回空间时 */
          }
          unmount() {
            this.root = null;
          }
        }

        // =============================================================================
        // RMQQ.Data（数据处理包）使用说明 · 避坑简版
        // 放置位置：把本注释放在  const Data = (() => {  前面，长期保留。
        // 【2】模板字符串怎么用（错 vs 对）
        // - ❌ 易翻车：在 innerHTML 的模板里拼“外部数据”，例如：
        //       style="background-image:url('${url}')"
        //       <div>${任意外部文本}</div>
        // - ✅ 稳定：先插“干净骨架”，再用 DOM 赋值：
        //       li.innerHTML = '...<div class="ava"></div><div class="title"></div>...';
        //       li.querySelector('.title').textContent = name;
        //       const ava = li.querySelector('.ava');
        //       ava.style.background = '#e9eef6';
        //       ava.style.backgroundImage =
        //         "url('" + String((url || DEFAULT_AVATAR)).replace(/'/g, "\\'") + "')";
        // 【3】innerHTML 与 DOM API 的分工
        // - innerHTML：只放“固定结构、不含变量”的静态骨架。
        // - 所有来自数据的内容，统一用 textContent / setAttribute / style.xxx
        // =============================================================================

        /* ============================================================
         * RMQQ.Data —— 只做数据，不碰 DOM
         * - 所有 QQ 数据改动都从这里走（初始化 / 新增消息 / 批量更新）
         * - 视图（TabsView / ChatView）只需要订阅它的事件来更新自己的 DOM
         * - 可选持久化：把 _data 序列化回 <RMPhone>…</RMPhone> （refresh:'none'）
         * ============================================================ */
        const Data = (() => {
          /* ---------------- 基础引用与小工具 ---------------- */
          const getQQ = () => RMPhoneToChatMessage.getApp('qq'); // _data.qq 的引用（就地修改）
          const getDefaultLogin = qq => qq?.accounts?.[0]?.login || null;
          const now = () => Date.now();
          const genId = () => now().toString(36) + Math.random().toString(36).slice(2, 8);

          // 简单事件总线
          const subs = Object.create(null);
          const on = (evt, fn) => {
            (subs[evt] ||= new Set()).add(fn);
            return () => off(evt, fn);
          };
          const off = (evt, fn) => {
            subs[evt]?.delete(fn);
          };
          const emit = (evt, payload) => {
            subs[evt]?.forEach(fn => {
              try {
                fn(payload);
              } catch (_) {}
            });
          };

          // 预览文本（最后一条非空）
          function lastPreview(sess) {
            const arr = Array.isArray(sess?.items) ? sess.items : [];
            for (let i = arr.length - 1; i >= 0; i--) {
              const it = arr[i];
              if (!it) continue;
              const a0 = Array.isArray(it.args) ? it.args[0] ?? '' : '';
              if (it.type === 'txt') {
                const t = String(a0).trim();
                if (t) return t.length > 42 ? t.slice(0, 42) + '…' : t;
              }
              if (it.type === 'bqb') return '[表情包] ' + String(a0 || '');
              if (it.type === 'voice')
                return `[语音 ${String(Array.isArray(it.args) ? it.args[0] || '' : '')}'' ]`.replace(" ''", "''");
              if (it.type === 'dmt') return '[多媒体] ' + String(a0 || '');
              if (it.type === 'file') return `[文件] ${String(a0 || '')}`.trim();
            }
            return '';
          }

          // 索引：login -> Map("kind|peer", session)
          const index = {
            map: new Map(),
            key: (k, p) => `${k}|${p}`,
            build() {
              this.map.clear();
              const qq = getQQ();
              for (const acc of qq.accounts || []) {
                const m = new Map();
                for (const s of acc.sessions || []) m.set(this.key(s.kind, s.peer), s);
                this.map.set(acc.login, m);
              }
            },
            get(login, kind, peer) {
              return this.map.get(login)?.get(this.key(kind, peer)) || null;
            },
            set(login, sess) {
              let m = this.map.get(login);
              if (!m) {
                m = new Map();
                this.map.set(login, m);
              }
              m.set(this.key(sess.kind, sess.peer), sess);
            },
          };

          /* ---------------- 生命周期 ---------------- */
          let inited = false;
          let activeChat = null; // { login, kind, peer } | null
          function init() {
            if (inited) return true;
            const qq = getQQ();
            qq.accounts ||= [];
            qq.schemaVersion ||= 1;

            // NEW: 如果完全没有账号，就创建一个默认账号 {{user}}
            if (!Array.isArray(qq.accounts) || qq.accounts.length === 0) {
              qq.accounts = [{ login: '{{user}}', sessions: [] }];
            }

            // 防止出现空 login 的脏数据（可选但安全）
            qq.accounts = qq.accounts
              .filter(a => a && typeof a.login === 'string' && a.login.trim() !== '')
              .map(a => ({ login: a.login.trim(), sessions: Array.isArray(a.sessions) ? a.sessions : [] }));

            index.build();
            inited = true;
            emit('init', { logins: (qq.accounts || []).map(a => a.login), defaultLogin: getDefaultLogin(qq) });
            return true;
          }

          function getState() {
            // 返回浅拷贝，避免外部误改原始引用
            const qq = getQQ();
            return JSON.parse(JSON.stringify(qq));
          }

          /* ---------------- 确保账号/会话存在 ---------------- */
          function ensureAccount(login) {
            init();
            const qq = getQQ();
            let acc = (qq.accounts || []).find(a => a.login === login);
            if (!acc) {
              acc = { login, sessions: [] };
              (qq.accounts ||= []).push(acc);
              // 给新账号也建一个空索引
              if (!index.map.has(login)) index.map.set(login, new Map());
              emit('account:created', { login });
            }
            return acc;
          }

          function ensureSession(accOrLogin, kind = 'dm', peer = '') {
            const login = typeof accOrLogin === 'string' ? accOrLogin : accOrLogin.login;
            const acc = typeof accOrLogin === 'string' ? ensureAccount(accOrLogin) : accOrLogin;
            let sess = index.get(login, kind, peer);
            if (!sess) {
              sess = { kind, peer, items: [] };
              (acc.sessions ||= []).push(sess);
              index.set(login, sess);
              sess.unreadCount = Number(sess.unreadCount) || 0;
              emit('session:created', { login, kind, peer });
            }
            return sess;
          }

          function findSession(login, kind, peer) {
            init();
            return index.get(login, kind, peer);
          }

          /* ---------------- 动作：新增消息（我方 / 对方） ---------------- */
          function _appendItem(login, kind, peer, item) {
            const acc = ensureAccount(login);
            const sess = ensureSession(acc, kind, peer);
            (sess.items ||= []).push(item);
            if (item.out === false) {
  const isActive = !!(activeChat &&
    activeChat.login === login &&
    activeChat.kind === kind &&
    activeChat.peer === peer);
  if (!isActive) sess.unreadCount = (Number(sess.unreadCount) || 0) + 1;
}
            const payload = {
              login,
              kind,
              peer,
              change: { type: 'append', count: 1, last: item },
              preview: lastPreview(sess),
              unreadCount: Number(sess.unreadCount) || 0,
              lastTs: item.ts || now(),
            };
            emit('session:changed', payload);
            _autoPersistTick();
            return item;
          }

          function pushMsg({ login, kind = 'dm', peer, type = 'txt', args = [] }) {
            login ||= getDefaultLogin(getQQ()) || `guest@${now()}`;
            const item = {
              id: genId(),
              type,
              speaker: login,
              out: true,
              args: Array.isArray(args) ? args.map(x => String(x)) : [],
              // 便利字段：给个 content = args[0]（便于少量地方取）
              content: Array.isArray(args) && args[0] != null ? String(args[0]) : '',
            };
            return _appendItem(login, kind, peer, item);
          }

          function pushInMsg({ login, kind = 'dm', peer, speaker, type = 'txt', args = [] }) {
            login ||= getDefaultLogin(getQQ()) || `guest@${now()}`;
            const item = {
              id: genId(),
              type,
              speaker: String(speaker || peer || '对方'),
              out: false,
              args: Array.isArray(args) ? args.map(x => String(x)) : [],
              content: Array.isArray(args) && args[0] != null ? String(args[0]) : '',
            };
            return _appendItem(login, kind, peer, item);
          }

          /* ---------------- 批量更新（回放 / 导入） ---------------- */
          // patch = { upserts: [{ login, kind, peer, items:[ {type, speaker?, out?, content, params?, ts?} ] }] }
          function applyPatch(patch) {
            init();
            const upserts = Array.isArray(patch?.upserts) ? patch.upserts : [];
            let changed = 0;
            for (const u of upserts) {
              const login = u.login || getDefaultLogin(getQQ()) || `guest@${now()}`;
              const kind = u.kind || 'dm';
              const peer = u.peer || '';
              const acc = ensureAccount(login);
              const sess = ensureSession(acc, kind, peer);
              const add = Array.isArray(u.items) ? u.items : [];
              for (const it of add) {
                const item = {
                  id: it.id || genId(),
                  type: it.type || 'txt',
                  speaker: it.speaker || (it.out ? login : peer || '对方'),
                  out: !!it.out,
                  args: Array.isArray(it.args) ? it.args.map(String) : [],
                  content: Array.isArray(it.args) && it.args[0] != null ? String(it.args[0]) : '',
                };

                (sess.items ||= []).push(item);
                changed++;
              }
              emit('session:changed', {
                login,
                kind,
                peer,
                change: { type: 'append', count: add.length, last: sess.items[sess.items.length - 1] || null },
                preview: lastPreview(sess),
                unreadCount: Number(sess.unreadCount) || 0,
                lastTs: sess.items.length ? sess.items[sess.items.length - 1].ts : now(),
              });
            }
            if (changed) _autoPersistTick();
            return changed;
          }

          // 直接吃 raw 文本，转 patch 后增量入库
          function applyRaw(raw) {
            const mini = RMPhoneToChatMessage?.safeParse?.(raw);
            if (!mini || !mini.qq) return 0;

            const upserts = [];
            for (const acc of mini.qq.accounts || []) {
              const login = acc.login || getDefaultLogin(getQQ()) || `guest@${now()}`;
              const sessions = acc.sessions || [];
              for (const s of sessions) {
                if (!s || !s.kind || !s.peer) continue;
                const items = Array.isArray(s.items)
                  ? s.items.map(it => ({
                      type: it.type || 'txt',
                      speaker: it.speaker || undefined,
                      // 规则：若有 speaker，则 out = (speaker === login)；否则沿用 it.out
                      out: it.speaker ? String(it.speaker) === String(login) : !!it.out,
                      args: Array.isArray(it.args) ? it.args.map(String) : [],
                    }))
                  : [];
                if (items.length) upserts.push({ login, kind: s.kind, peer: s.peer, items });
              }
            }
            if (!upserts.length) return 0;
            return applyPatch({ upserts });
          }

          /* ---------------- 删除会话（整块移除） ---------------- */
          // opts = { login, kind:'dm'|'group', peer }
          function deleteSession({ login, kind = 'dm', peer }) {
            init();
            const qq = getQQ();
            const acc = (qq.accounts || []).find(a => a.login === (login || getDefaultLogin(qq)));
            if (!acc) return false;

            const i = (acc.sessions || []).findIndex(s => s && s.kind === kind && s.peer === peer);
            if (i < 0) return false;

            // 从账号的 sessions 里移掉该会话
            acc.sessions.splice(i, 1);

            // 重建索引 + 广播删除事件
            index.build();
            emit('session:deleted', { login: acc.login, kind, peer });

            // 触发持久化（你的外壳已设 mode:'immediate'）
            _autoPersistTick();
            return true;
          }

          /* ---------------- 订阅（给视图用） ---------------- */
          // Chat 订阅：初次返回全部 items，后续只返回新增尾巴
          function subscribeChat({ login, kind = 'dm', peer }, cb) {
            init();
            const sess = findSession(login || getDefaultLogin(getQQ()) || `guest@${now()}`, kind, peer);
            let seen = (sess && sess.items.length) || 0;
            cb({ type: 'init', items: sess ? sess.items.slice(0) : [] }); // 首次

            const off1 = on('session:changed', e => {
              if (e.login !== login || e.kind !== kind || e.peer !== peer) return;
              const s = findSession(login || getDefaultLogin(getQQ()) || `guest@${now()}`, kind, peer);
const cur = s ? s.items.length : 0;
if (cur > seen) {
  cb({ type: 'append', items: s.items.slice(seen) });
  seen = cur;
}
            });

            // 返回取消订阅函数
            return () => off1();
          }

          // Tabs 摘要订阅：初次返回所有摘要，后续返回单条 patch
          // 摘要项：{ kind, peer, preview, lastTs }
          function subscribeTabsSummaries({ login }, cb) {
            init();
            const qq = getQQ();
            const acc = (qq.accounts || []).find(a => a.login === login) || ensureAccount(login);

            const summaries = (acc.sessions || []).map(s => ({
  kind: s.kind,
  peer: s.peer,
  preview: lastPreview(s),
  lastTs: s.items?.length ? s.items[s.items.length - 1].ts : 0,
  unreadCount: Number(s.unreadCount) || 0,
}));
            cb({ type: 'init', summaries });

            const offA = on('session:created', e => {
              if (e.login !== login) return;
              cb({ type: 'patch', summary: { kind: e.kind, peer: e.peer, preview: '', lastTs: 0 } });
            });

            const offB = on('session:changed', e => {
              if (e.login !== login) return;
              cb({ type: 'patch', summary: {
  kind: e.kind,
  peer: e.peer,
  preview: e.preview,
  lastTs: e.lastTs,
  unreadCount: Number(e.unreadCount) || 0
} });
            });

            const offC = on('session:deleted', e => {
              if (e.login !== login) return;
              cb({ type: 'remove', summary: { kind: e.kind, peer: e.peer } });
            });

            return () => {
              offA();
              offB();
              offC();
            };
          }

          /* ---------------- 持久化（楼层写回） ---------------- */
          // 模式：off | immediate | debounce
          let persistMode = 'off';
          let debMs = 600;
          let maxWaitMs = 5000;
          let debTimer = null;
          let maxTimer = null;
          let flushing = false;

          function setPersistMode({ mode = 'off', debounceMs = 600, maxWaitMs: mw = 5000 } = {}) {
            persistMode = mode;
            debMs = debounceMs;
            maxWaitMs = mw;
            if (debTimer) {
              clearTimeout(debTimer);
              debTimer = null;
            }
            if (maxTimer) {
              clearTimeout(maxTimer);
              maxTimer = null;
            }
          }

          async function commit({ immediate = false } = {}) {
            init();
            if (flushing && !immediate) return false;
            flushing = true;
            try {
              RMPhoneToChatMessage.toRaw?.(); // _data → _raw
              await RMPhoneToChatMessage.RMPhoneCommit?.(); // 写回顶楼，refresh:'none'
              emit('change', {});
              return true;
            } catch (e) {
              console.warn('RMQQ.Data.commit 失败：', e);
              return false;
            } finally {
              flushing = false;
            }
          }

          function _schedulePersist() {
            if (persistMode === 'immediate') {
              void commit({ immediate: true });
              return;
            }
            if (persistMode !== 'debounce') return;
            if (debTimer) clearTimeout(debTimer);
            debTimer = setTimeout(() => {
              debTimer = null;
              void commit({ immediate: true });
            }, debMs);
            if (!maxTimer && maxWaitMs > 0) {
              maxTimer = setTimeout(() => {
                maxTimer = null;
                if (debTimer) {
                  clearTimeout(debTimer);
                  debTimer = null;
                }
                void commit({ immediate: true });
              }, maxWaitMs);
            }
          }
          function _autoPersistTick() {
            if (persistMode !== 'off') _schedulePersist();
          }

          /* -------- 未读：工具与订阅 -------- */
function setActiveChat({ login, kind = 'dm', peer } = {}) {
  activeChat = login && peer ? { login, kind, peer } : null;
  if (activeChat) markRead(activeChat);
}

function clearActiveChat() { activeChat = null; }

function markRead({ login, kind = 'dm', peer }) {
  const sess = findSession(login, kind, peer);
  if (!sess) return false;
  if ((Number(sess.unreadCount) || 0) > 0) {
    sess.unreadCount = 0;
    emit('session:changed', {
      login, kind, peer,
      change: { type: 'unread', count: 0, last: sess.items?.[sess.items?.length - 1] || null },
      preview: lastPreview(sess),
      unreadCount: 0,
      lastTs: sess.items?.length ? sess.items[sess.items.length - 1].ts : now(),
    });
    _schedulePersist();
  }
  return true;
}

function markUnread({ login, kind = 'dm', peer, count = 1 }) {
  const sess = ensureSession(login, kind, peer);
  const cur = Number(sess.unreadCount) || 0;
  const next = Math.max(cur, Math.max(1, Number(count) || 1));
  if (next !== cur) {
    sess.unreadCount = next;
    emit('session:changed', {
      login, kind, peer,
      change: { type: 'unread', count: next, last: sess.items?.[sess.items?.length - 1] || null },
      preview: lastPreview(sess),
      unreadCount: next,
      lastTs: sess.items?.length ? sess.items[sess.items.length - 1].ts : now(),
    });
    _schedulePersist();
  }
  return true;
}

function getLoginUnreadTotal(login) {
  const acc = (getQQ()?.accounts || []).find(a => a.login === login);
  if (!acc) return 0;
  return (acc.sessions || []).reduce((sum, s) => sum + (Number(s.unreadCount) || 0), 0);
}

/* 订阅：某登录的“（可选排除当前会话的）未读总数” */
function subscribeUnreadOfLogin({ login, exclude } = {}, cb) {
  const calc = () => {
    const acc = (getQQ()?.accounts || []).find(a => a.login === login);
    if (!acc) return 0;
    return (acc.sessions || []).reduce((sum, s) => {
      if (exclude && s.kind === (exclude.kind || 'dm') && s.peer === exclude.peer) return sum;
      return sum + (Number(s.unreadCount) || 0);
    }, 0);
  };
  cb(calc());
  const off1 = on('session:changed', e => { if (e.login === login) cb(calc()); });
  const off2 = on('session:deleted', e => { if (e.login === login) cb(calc()); });
  return () => { off1(); off2(); };
}

/* 订阅：是否有“其它登录”的未读 */
function subscribeAnyUnreadExceptLogin({ login }, cb) {
  const calc = () => {
    const qq = getQQ();
    const list = (qq?.accounts || []).map(a => a.login).filter(Boolean);
    return list.some(lg => lg !== login && getLoginUnreadTotal(lg) > 0);
  };
  cb(calc());
  const off = on('session:changed', () => cb(calc()));
  const off2 = on('session:deleted', () => cb(calc()));
  return () => { off(); off2(); };
}

          /* ---------------- 导出 API ---------------- */
          return {
            // 生命周期
            init,
            getState,

            // 事件
            on,
            off,

            // 数据操作
            ensureAccount,
            ensureSession,
            findSession,
            pushMsg,
            pushInMsg,
            applyPatch,
            applyRaw,
            deleteSession,
            setActiveChat,
clearActiveChat,
markRead,
markUnread,
getLoginUnreadTotal,
subscribeUnreadOfLogin,
subscribeAnyUnreadExceptLogin,

            // 订阅（给视图挂载时用）
            subscribeChat,
            subscribeTabsSummaries,

            // 持久化
            setPersistMode,
            commit,
          };
        })();

        return { ScreenManager, TabsView, ChatView, SpaceView, Data };
      })();

      // ====================== QQ App（使用封包） ======================
      // ===========================================
      // RMPhone.Apps.QQ（数据驱动集成版；保留样式/动画契约）
      // ===========================================
      // ====================== RMPhone.Apps.QQ（数据驱动接入版） ======================
      // ====================== RMPhone.Apps.QQ（修正：使用 RMQQ.ScreenManager） ======================
      RMPhone.Apps.QQ = class extends RMPhone.Apps.Base {
        constructor(el) {
          super(el);
          this._manager = null;
          this._login = null;
        }

        // 兼容性更强：尽量从 RMQQ.Data 拿；拿不到就从 _data.qq 兜底
        _detectLogin() {
          try {
            if (RMQQ?.Data?.getActiveLogin) return RMQQ.Data.getActiveLogin();
            if (RMQQ?.Data?.getDefaultLogin) return RMQQ.Data.getDefaultLogin();
            // 兜底：直接读 RMPhoneToChatMessage（你的数据桥）
            const qq = RMPhoneToChatMessage?.getApp?.('qq');
            return qq?.accounts?.[0]?.login || null;
          } catch {
            return null;
          }
        }

        // --- 1. 将 mount 方法声明为 async ---
        async mount(viewport) { 
          super.mount(viewport);

          this.shadow.innerHTML = `
      <style>
        :host{ display:block; height:100%; }
        .qq-router{ position:absolute; inset:0; border-radius:inherit; overflow:hidden; background:transparent; }
        .qq-screen{
          position:absolute; inset:0; border-radius:inherit; overflow:hidden;
          transform:translate3d(0,0,0); opacity:1; will-change:transform,opacity; pointer-events:auto;
        }
        .qq-screen.hidden{ pointer-events:none; }
        .qq-anim{
          transition: transform .28s cubic-bezier(.4,0,.2,1), opacity .28s cubic-bezier(.4,0,.2,1);
        }
        .qq-enter-from{ transform:translate3d(100%,0,0); opacity:0.001; }
        .qq-enter-to  { transform:translate3d(0,0,0);    opacity:1; }
        .qq-leave-from{ transform:translate3d(0,0,0);    opacity:1; }
        .qq-leave-to  { transform:translate3d(100%,0,0); opacity:0.001; }
      </style>
      <div id="router" class="qq-router" aria-label="QQ Router"></div>
    `;



          // --- 2. 在所有逻辑之前，先等待数据模块初始化完成 ---
          await RMPhoneToChatMessage.initialize();

          const router = this.shadow.querySelector('#router');

          RMQQ.Data.init?.();
          RMQQ.Data.setPersistMode({ mode: 'immediate' });

          this._manager = new RMQQ.ScreenManager(router);

          this._login = this._detectLogin();

          const tabs = new RMQQ.TabsView({
            login: this._login,
            onOpenChat: info => this.openChat(info),
            onOpenSpace: () => this.openSpace(),
            onLoginChanged: login => {
              this._login = login;
            },
          });
          this._manager.push(tabs);
        }

        unmount() {
          try {
            this._manager?.destroy();
          } catch {}
          this._manager = null;
          super.unmount();
        }

        // 打开聊天：按 kind+peer 去重
        // 打开聊天：按 kind+peer 去重
        async openChat(info) {
          const payload = typeof info === 'string' ? { kind: 'dm', peer: info } : info || {};
          const kind = payload.kind === 'group' ? 'group' : 'dm';
          const peer = (payload.peer || '').trim();
          if (!peer) return;

          // 优先使用外部显式传入的 login
          this._login = payload.login || this._login || (RMQQ?.Data?.getDefaultLogin?.() ?? this._detectLogin());

          const idx = this._manager.findIndexReverse(
            it => it.screen?.key === 'chat' && it.screen.kind === kind && it.screen.peerName === peer,
          );
          const topIdx = this._manager.topIndex();

          if (idx === topIdx) {
            try {
              this._manager.top().screen.onShow?.();
            } catch {}
            return;
          }
          if (idx !== -1) {
            await this._manager.popTo(idx);
            try {
              this._manager.top().screen.onShow?.();
            } catch {}
            return;
          }

          const chat = new RMQQ.ChatView({
            login: this._login,
            kind,
            peerName: peer,
            onBack: () => this._manager.pop(),
          });
          this._manager.push(chat);
        }

        // 打开空间：只保留一个
        async openSpace() {
          const idx = this._manager.findIndexReverse(it => it.screen?.key === 'space');
          const topIdx = this._manager.topIndex();
          if (idx === topIdx) {
            try {
              this._manager.top().screen.onShow?.();
            } catch {}
            return;
          }
          if (idx !== -1) {
            await this._manager.popTo(idx);
            try {
              this._manager.top().screen.onShow?.();
            } catch {}
            return;
          }

          const space = new RMQQ.SpaceView({ onBack: () => this._manager.pop() });
          this._manager.push(space);
        }
      };

      RMPhone.Apps.YouTube = class extends RMPhone.Apps.Base {
        mount(viewport) {
          super.mount(viewport);
          this.shadow.innerHTML = `
        <style>
          :host{display:block;height:100%}
          .wrap{position:absolute; inset:0; background:#fff; color:#111; font:14px/1.4 system-ui; display:flex; align-items:center; justify-content:center}
          .close{ position:absolute; top:12px; right:12px; border:0; cursor:pointer; padding:.25rem .6rem; border-radius:.5rem; background:#f0f0f0; }
        </style>
        <div class="wrap">
          <button class="close">关闭</button>
          <div>YouTube（示例）</div>
        </div>`;
          this._onClose ??= () => RMPhone.toDesktop?.();
          this.shadow.querySelector('.close')?.addEventListener('click', this._onClose);
        }
        unmount() {
          const btn = this.shadow?.querySelector('.close');
          if (btn && this._onClose) {
            btn.removeEventListener('click', this._onClose);
          }
          this._onClose = null; // 推荐：把引用也置空
          super.unmount();
        }
      };

      RMPhone.Apps.Discord = class extends RMPhone.Apps.Base {
        mount(viewport) {
          super.mount(viewport);
          this.shadow.innerHTML = `
        <style>
          :host{display:block;height:100%}
          .wrap{position:absolute; inset:0; background:#fff; color:#111; font:14px/1.4 system-ui; display:flex; align-items:center; justify-content:center}
          .close{ position:absolute; top:12px; right:12px; border:0; cursor:pointer; padding:.25rem .6rem; border-radius:.5rem; background:#f0f0f0; }
        </style>
        <div class="wrap">
          <button class="close">关闭</button>
          <div>Discord（示例）</div>
        </div>`;
          this._onClose ??= () => RMPhone.toDesktop?.();
          this.shadow.querySelector('.close')?.addEventListener('click', this._onClose);
        }
        unmount() {
          const btn = this.shadow?.querySelector('.close');
          if (btn && this._onClose) {
            btn.removeEventListener('click', this._onClose);
          }
          this._onClose = null; // 推荐：把引用也置空
          super.unmount();
        }
      };

      /* 注册表 */
      RMPhone.Apps.registry = {
        settings: el => new RMPhone.Apps.Settings(el),
        qq: el => new RMPhone.Apps.QQ(el),
        youtube: el => new RMPhone.Apps.YouTube(el),
        discord: el => new RMPhone.Apps.Discord(el),
      };
    </script>
