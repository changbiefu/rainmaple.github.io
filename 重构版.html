<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>手机</title>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
  </head>

  <body>
    <div class="phone">
      <div class="buttons">
        <div class="left">
          <div class="button"></div>
          <div class="button"></div>
          <div class="button"></div>
        </div>
        <div class="right">
          <div class="button"></div>
        </div>
      </div>
      <div class="camera"></div>
      <div class="screen-container">
        <div class="bg">
          <div class="deep-purple">
            <div class="section">
              <div class="glow"></div>
            </div>
            <div class="section">
              <div class="glow"></div>
            </div>
          </div>
          <div class="gold">
            <div class="section">
              <div class="glow"></div>
            </div>
            <div class="section">
              <div class="glow"></div>
            </div>
          </div>
          <div class="space-black">
            <div class="section">
              <div class="glow"></div>
            </div>
            <div class="section">
              <div class="glow"></div>
            </div>
          </div>
          <div class="silver">
            <div class="section">
              <div class="glow"></div>
            </div>
            <div class="section">
              <div class="glow"></div>
            </div>
          </div>
        </div>
        <div class="notch-container" tabIndex="0">
          <div class="notch">
            <div class="content">
              <div class="left">
                <div class="tile"></div>
                <div class="text">
                    <span class="song-title"></span>
                    <span class="song-artist"></span>
                </div>
              </div>
              <div class="right"></div>
              <div class="player-controls">
                  <button class="player-button" id="playlist-btn"><img src="https://img.icons8.com/ios-glyphs/30/FFFFFF/list.png" alt="list"/></button>
                  <button class="player-button" id="pause-btn"><img src="https://img.icons8.com/ios-glyphs/30/FFFFFF/pause.png" alt="pause"/></button>
                  <button class="player-button" id="next-btn"><img src="https://img.icons8.com/ios-glyphs/30/FFFFFF/end.png" alt="next"/></button>
              </div>
            </div>
          </div>
        </div>
        <div class="notch-blur"></div>
        <div id="playlist-view" class="hidden" style="position: absolute; z-index: 11; top: calc(var(--pad) + var(--notch-radius) * 3 + 1em); left: 5%; right: 5%; background: rgba(0,0,0,0.7); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 1.5em; padding: 1em; color: white;">
            <h4 style="font-size: 1.5em; margin-top: 0; margin-bottom: 0.8em;">播放列表</h4>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 1.2em;">
                <!-- Populated by JS -->
            </ul>
        </div>
        <div class="screen" id="app-container">
          <div class="app grey" id="app-grey"><img src="https://i.postimg.cc/05fCzPV9/R.png" alt="gear"/></div>
          <div class="app white" id="app-white"><img src="https://img.icons8.com/external-tal-revivo-color-tal-revivo/96/external-tencent-qq-an-instant-messaging-software-service-and-web-portal-developed-logo-color-tal-revivo.png" alt="external-tencent-qq-an-instant-messaging-software-service-and-web-portal-developed-logo-color-tal-revivo"/></div>
		  <div style="flex-basis: 20%; margin: 0 2.5% var(--gutter);"></div>
		  <div style="flex-basis: 20%; margin: 0 2.5% var(--gutter);"></div>
        </div>
		<div class="view" id="view-contacts" style="display:none;">
			<div class="settings-page-header">
				<a href="#" class="back-button"><img src="https://img.icons8.com/ios-glyphs/30/back.png" alt="back"/></a>
				<span class="title">联系人</span>
                <div class="header-actions" style="justify-self: end;">
                    <button class="add-contact-button" style="background:none; border:none; cursor:pointer; padding:0;">
                        <img src="https://img.icons8.com/fluency-systems-regular/48/plus.png" alt="add" style="width:1.6em; height:1.6em;"/>
                    </button>
                    <button class="done-edit-button hidden" style="background:none; border:none; cursor:pointer; padding:0.5em 1em; font-size:1.4em; color:#007aff; font-weight:600;">
                        完成
                    </button>
                </div>
			</div>
			<div class="contacts-list" style="flex:1;"><!-- 动态填充联系人 --></div>
			<div id="create-contact-modal" class="modal-overlay hidden">
				<div class="modal-content">
					<h4>新建联系人</h4>
					<div>
						<p>类型</p>
					<select id="create-contact-type" class="settings-select" style="direction:ltr; width:100%; padding:0.6em 0.8em; border:1px solid #ddd; border-radius:0.6em; font-size:1.4em;">
							<option value="私聊">私聊</option>
							<option value="群聊">群聊</option>
						</select>
					</div>
					<div>
						<p>名称</p>
						<input type="text" id="create-contact-name" placeholder="输入角色名或群聊名" style="width:100%; padding:0.6em 0.8em; border:1px solid #ddd; border-radius:0.6em; font-size:1.4em;"/>
					</div>
					<div>
						<p>头像 URL</p>
						<input type="text" id="create-contact-avatar" placeholder="https://...（可留空）" style="width:100%; padding:0.6em 0.8em; border:1px solid #ddd; border-radius:0.6em; font-size:1.4em;"/>
					</div>
					<!-- 群聊可选成员 -->
					<div id="group-members-wrapper" class="hidden">
						<p>群聊成员（可选）：</p>
						<div id="group-members-container" style="display:flex; flex-wrap:wrap; gap:0.5em;"></div>
						<p>追加成员（自定义，逗号分隔）：</p>
						<input type="text" id="group-extra-input" placeholder="例：小红, 小明" class="th-input"/>
					</div>
					<div class="modal-buttons">
						<button id="create-contact-cancel">取消</button>
						<button id="create-contact-confirm">创建</button>
					</div>
				</div>
			</div>
			<!-- 删除联系人/群聊 确认弹窗 -->
			<div id="delete-contact-modal" class="modal-overlay hidden">
				<div class="modal-content">
					<h4>删除确认</h4>
					<p id="delete-contact-text">是否删除？</p>
					<div class="modal-buttons">
						<button id="delete-contact-cancel">取消</button>
						<button id="delete-contact-confirm">删除</button>
					</div>
				</div>
			</div>
        </div>
		<div class="view" id="view-grey">
			<div class="settings-page-header">
				<a href="#" class="back-button"><img src="https://img.icons8.com/ios-glyphs/30/back.png" alt="back"/></a>
				<span class="title">设置</span>
				<div></div> 
			</div>
			<div class="settings-content-area">
				<div class="settings-section">
					<div class="settings-item" id="about-entry" style="cursor: pointer;">
						<img src="https://img.icons8.com/ios-filled/50/808080/info.png" class="settings-icon" alt="about">
						<span class="label">关于</span>
						<span class="value">使用指南</span>
						<span class="chevron">></span>
					</div>
				</div>

				<div class="settings-section">
					<div class="settings-item">
						<img src="https://img.icons8.com/ios-glyphs/30/iphone-x.png" class="settings-icon" alt="dynamic island">
						<span class="label">灵动岛</span>
						<label class="toggle-switch">
							<input type="checkbox" id="dynamic-island-toggle" checked>
							<span class="slider"></span>
						</label>
					</div>
				</div>

				<div class="settings-section">
					<div class="settings-item" id="music-manager-entry" style="cursor: pointer;">
						<img src="https://img.icons8.com/ios-filled/50/40C057/music.png" class="settings-icon" alt="music">
						<span class="label">音乐播放器</span>
						<span class="chevron">></span>
					</div>
				</div>

				<div class="settings-section">
					<div class="settings-item">
						<img src="https://img.icons8.com/ios-glyphs/30/moon-symbol.png" class="settings-icon" alt="night mode">
						<span class="label">夜间模式</span>
						<label class="toggle-switch">
							<input type="checkbox" id="night-mode-toggle">
							<span class="slider"></span>
						</label>
					</div>
				</div>

				<div class="settings-section">
					<div class="settings-item">
						<img src="https://img.icons8.com/ios-glyphs/30/paint-palette.png" class="settings-icon" alt="border color">
						<span class="label">边框颜色</span>
						<input type="color" id="border-color-picker" value="#8A2BE2" style="margin-left: auto; border: none; background: transparent; width: 3em; height: 2em;">
					</div>
					<div class="settings-item">
						<img src="https://img.icons8.com/ios-glyphs/30/aspect-ratio.png" class="settings-icon" alt="aspect ratio">
						<span class="label">长宽比</span>
						<div style="margin-left: auto; display: flex; align-items: center; gap: 0.5em;">
							<input type="number" id="aspect-ratio-w" class="th-input" style="width: 4em; text-align: center; font-size: 1em; padding: 0.4em;">
							<span>:</span>
							<input type="number" id="aspect-ratio-h" class="th-input" style="width: 4em; text-align: center; font-size: 1em; padding: 0.4em;">
						</div>
					</div>
					<div class="settings-item">
						<img src="https://img.icons8.com/ios-glyphs/30/text-width.png" class="settings-icon" alt="font">
						<span class="label">字体</span>
						<select id="font-select" class="settings-select" style="direction: ltr; max-width: 12em; margin-left: auto;">
							<option value="chill">寒蝉圆黑体</option>
							<option value="noto">思源黑体</option>
							<option value="custom">自定义</option>
						</select>
					</div>
					<div class="settings-item hidden" id="custom-font-item">
						<img src="https://img.icons8.com/ios-glyphs/30/link.png" class="settings-icon" alt="custom font">
						<span class="label" style="flex-grow: 0; margin-right: 1em;">URL</span>
						<input type="text" id="custom-font-url" class="th-input" placeholder="@import url(...)" style="flex-grow: 1; min-width: 0;">
					</div>
				</div>

				<div class="settings-section">
					<div class="settings-item" id="summary-entry" style="cursor: pointer;">
						<img src="https://img.icons8.com/ios-glyphs/30/888888/overview-pages-3.png" class="settings-icon" alt="summary">
						<span class="label">总结</span>
						<span class="chevron">></span>
					</div>
				</div>
			</div>
		</div>
        <div class="view" id="music-manager-view" style="display:none; flex-direction: column; z-index: 10;">
			<div class="settings-page-header">
				<a href="#" class="back-button"><img src="https://img.icons8.com/ios-glyphs/30/back.png" alt="back"/></a>
				<span class="title">音乐管理</span>
				<button id="add-music-btn" style="justify-self:end; background:none; border:none; cursor:pointer; padding:0;">
					<img src="https://img.icons8.com/fluency-systems-regular/48/plus.png" alt="add" style="width:1.6em; height:1.6em;"/>
				</button>
			</div>
            <div class="settings-content-area">
                <ul id="music-list">
                    <!-- Music items will be populated here -->
                </ul>
            </div>
        </div>
        <div class="view" id="about-view" style="display:none; flex-direction: column; z-index: 10;">
			<div class="settings-page-header">
				<a href="#" class="back-button"><img src="https://img.icons8.com/ios-glyphs/30/back.png" alt="back"/></a>
				<span class="title">使用指南</span>
				<div></div>
			</div>
            <div class="settings-content-area">
                <div class="about-content">
                    <h1>使用指南</h1>
                    
                    <h2>设置界面</h2>
                    <ul>
                        <li>查看使用指南</li>
                        <li>开关灵动岛</li>
                        <li>音乐管理</li>
                        <li>总结功能</li>
                            <ul>
                                <li>点击确认总结当前楼层聊天记录</li>
                                <li>可在输入框修改总结内容</li>
                                <li>点击使用总结按钮</li>
                            </ul>
                    </ul>

                    <h2>灵动岛</h2>
                    <ul>
                        <li>鼠标悬浮（手机端长按）显示简略信息</li>
                        <li>单击后出现相关播放设置</li>
                    </ul>

                    <h2>联系人界面</h2>
                    <ul>
                        <li>可新建私聊/群聊</li>
                        <li>长按任意联系人进入编辑模式</li>
                        <li>编辑模式下：
                            <ul>
                                <li>点击拖拽按钮调整联系人顺序</li>
                                <li>点击红色按钮删除联系人</li>
                                <li>单击头像修改头像URL</li>
                            </ul>
                        </li>
                        <li>单击联系人进入聊天（非编辑模式）</li>
                    </ul>

                    <h2>聊天界面</h2>
                    <ul>
                        <li>双击我方头像修改头像url</li>
                        <li>双击聊天气泡进入编辑界面</li>
                        <li>单击发送键发送至聊天窗，双击响应</li>
                        <li>删除对方回复的消息之后，再次双击发送<b>重roll</b></li>
                        <li>底部笑脸是表情包列表</li>
                        <li>点击麦克风发送语音消息</li>
                        <li>点击图片发送多媒体消息</li>
                    </ul>

                    <h2>聊天界面设置面板</h2>
                    <ul>
                        <li>回复形式可选同层与不同层</li>
                        <li>”使用联系人“头像勾选可默认对方消息为联系人头像</li>
                        <li>”分享听歌状态“勾选后可以分享{{user}}当前听的歌的信息</li>
                    </ul>

                    <h2>表情包存放</h2>
                    <ul>
                        <li>在角色卡绑定的世界书“强健有力的表情包存放”条目存入表情包，格式为<code>{{中文名}}{{表情包url}}</code>即可，两两之间换行区分</li>
                    </ul>

                    <h2>额外内容</h2>
                    <ul>
                        <li>角色头像和表情包支持猫箱写法，会自动补全网址，其他图床的头像/表情包直接填完整网址即可</li>
                    </ul>

                    <h2>更新报告</h2>
                    <h3>08.15</h3>
                    <ul>
                        <li>修了一点bug</li>
                        <li>优化了夜间模式</li>
                        <li>优化了联系人和聊天窗口逻辑</li>
                    </ul>
                </div>
            </div>
        </div>
        <div class="view" id="summary-view" style="display:none; flex-direction: column; z-index: 10;">
            <div class="settings-page-header">
                <a href="#" class="back-button"><img src="https://img.icons8.com/ios-glyphs/30/back.png" alt="back"/></a>
                <span class="title">总结</span>
                <div></div>
            </div>
            <div class="settings-content-area" style="text-align: center; padding: 2em;">
                <p>确认总结本楼层所有手机消息嘛？</p>
                <button id="confirm-summary-btn" style="padding: 0.8em 1.5em; font-size: 1.6em; border-radius: 0.8em; border: none; background-color: #007aff; color: white; cursor: pointer;">确认</button>
                <div id="summary-result-container" style="margin-top: 2em; display: none;">
                    <div id="summary-result" contenteditable="true"></div>
                    <button id="use-summary-btn" style="margin-top: 1em; padding: 0.8em 1.5em; font-size: 1.6em; border-radius: 0.8em; border: none; background-color: #40C057; color: white; cursor: pointer;">使用总结</button>
                </div>
            </div>
        </div>
		<div id="add-music-modal" class="modal-overlay hidden">
			<div class="modal-content">
				<h4>添加歌曲</h4>
				<div>
					<p>歌曲名</p>
					<input type="text" id="add-music-title" placeholder="输入歌曲名" style="width:100%; padding:0.6em 0.8em; border:1px solid #ddd; border-radius:0.6em; font-size:1.4em; box-sizing: border-box;"/>
				</div>
				<div>
					<p>艺术家</p>
					<input type="text" id="add-music-artist" placeholder="输入艺术家名" style="width:100%; padding:0.6em 0.8em; border:1px solid #ddd; border-radius:0.6em; font-size:1.4em; box-sizing: border-box;"/>
				</div>
				<div>
					<p>封面 URL</p>
					<input type="text" id="add-music-cover" placeholder="https://..." style="width:100%; padding:0.6em 0.8em; border:1px solid #ddd; border-radius:0.6em; font-size:1.4em; box-sizing: border-box;"/>
				</div>
				<div>
					<p>音频 URL</p>
					<input type="text" id="add-music-audio" placeholder="https://..." style="width:100%; padding:0.6em 0.8em; border:1px solid #ddd; border-radius:0.6em; font-size:1.4em; box-sizing: border-box;"/>
				</div>
				<div class="modal-buttons">
					<button id="add-music-cancel">取消</button>
					<button id="add-music-confirm">确认</button>
				</div>
			</div>
		</div>
		<div id="edit-music-modal" class="modal-overlay hidden">
			<div class="modal-content">
				<h4>修改歌曲</h4>
				<div>
					<p>歌曲名</p>
					<input type="text" id="edit-music-title" placeholder="输入歌曲名" style="width:100%; padding:0.6em 0.8em; border:1px solid #ddd; border-radius:0.6em; font-size:1.4em; box-sizing: border-box;"/>
				</div>
				<div>
					<p>艺术家</p>
					<input type="text" id="edit-music-artist" placeholder="输入艺术家名" style="width:100%; padding:0.6em 0.8em; border:1px solid #ddd; border-radius:0.6em; font-size:1.4em; box-sizing: border-box;"/>
				</div>
				<div>
					<p>封面 URL</p>
					<input type="text" id="edit-music-cover" placeholder="https://..." style="width:100%; padding:0.6em 0.8em; border:1px solid #ddd; border-radius:0.6em; font-size:1.4em; box-sizing: border-box;"/>
				</div>
				<div>
					<p>音频 URL</p>
					<input type="text" id="edit-music-audio" placeholder="https://..." style="width:100%; padding:0.6em 0.8em; border:1px solid #ddd; border-radius:0.6em; font-size:1.4em; box-sizing: border-box;"/>
				</div>
				<div class="modal-buttons">
					<button id="edit-music-cancel">取消</button>
					<button id="edit-music-confirm">保存</button>
				</div>
			</div>
		</div>
		<div class="view" id="view-white">
			<div class="chat-header">
				<a href="#" class="back-button"><img src="https://img.icons8.com/ios-glyphs/30/back.png" alt="back"/><span class="unread-dot hidden">1</span></a>
				<span class="chat-name"></span>
				<button class="settings-button"><img src="https://img.icons8.com/fluency-systems-regular/48/menu--v1.png" alt="menu"/></button>
			</div>
			<div class="chat-messages"><!-- 待填充吧！（？） --></div>
			<div class="chat-input-area">
                <div class="input-wrapper">
				    <input type="text" class="message-input" placeholder="">
				    <button class="send-button">发送</button>
                </div>
                <div class="function-bar">
<button class="function-button mic-button"><img src="https://img.icons8.com/fluency-systems-regular/48/microphone--v1.png" alt="microphone"/></button>
					<button class="function-button image-button"><img src="https://img.icons8.com/fluency-systems-regular/48/image--v1.png" alt="image"/></button>
					<button class="function-button camera-button"><img src="https://img.icons8.com/fluency-systems-regular/48/camera.png" alt="camera"/></button>
					<button class="function-button pocket-button"><img src="https://img.icons8.com/fluency-systems-regular/48/pocket.png" alt="pocket"/></button>
					<button class="function-button emoji-button"><img src="https://img.icons8.com/fluency-systems-regular/48/happy.png" alt="happy"/></button>
					<button class="function-button more-button"><img src="https://img.icons8.com/fluency-systems-regular/48/plus.png" alt="plus"/></button>
				</div>
			</div>
			<div class="emoji-picker-container"></div>
            <div class="settings-panel hidden">
                <div class="settings-header">
					<h4>聊天设置</h4>
                    <button class="close-settings-button">&times;</button>
                </div>
                <div class="settings-content">
					<label>用户头像 URL</label>
					<input type="text" id="avatar-url-input" class="th-input" placeholder="https://..." />

					<label>回复形式</label>
					<select id="reply-format-select" class="settings-select th-input" style="direction:ltr;">
						<option value="same-level">同层回复</option>
						<option value="diff-level-no-trigger">不同层不触发</option>
						<option value="diff-level-trigger">不同层触发</option>
					</select>

					<label>消息缩放 <span id="message-size-value">100</span>%</label>
					<input type="range" id="message-size-slider" min="80" max="120" value="100">

					<label>当前聊天背景 URL</label>
					<input type="text" id="chat-bg-url-input" class="th-input" placeholder="https://..." />
					<div style="display: flex; align-items: center; gap: 0.8em; margin-top: 1em;">
						<input type="checkbox" id="use-contact-avatar-checkbox" style="width: 1.4em; height: 1.4em; margin: 0;">
						<label for="use-contact-avatar-checkbox" style="font-weight: 600; flex-grow: 1;">使用联系人头像</label>
					</div>
					<div style="display: flex; align-items: center; gap: 0.8em; margin-top: 1em;">
						<input type="checkbox" id="share-music-status-checkbox" style="width: 1.4em; height: 1.4em; margin: 0;">
						<label for="share-music-status-checkbox" style="font-weight: 600; flex-grow: 1;">分享听歌状态</label>
					</div>
                </div>
            </div>
			<!-- Voice Message Modal -->
			<div id="voice-message-modal" class="modal-overlay hidden">
				<div class="modal-content">
					<h4>请输入语音消息内容</h4>
					<div>
						<p>语音时长</p>
						<input type="text" id="voice-duration-input" placeholder="例如：0:05" style="width:100%; padding:0.6em 0.8em; border:1px solid #ddd; border-radius:0.6em; font-size:1.4em;"/>
					</div>
					<div>
						<p>语音内容</p>
						<input type="text" id="voice-content-input" placeholder="输入语音转写的文字" style="width:100%; padding:0.6em 0.8em; border:1px solid #ddd; border-radius:0.6em; font-size:1.4em;"/>
					</div>
					<div class="modal-buttons">
						<button id="voice-message-cancel">取消</button>
						<button id="voice-message-confirm">确定</button>
					</div>
				</div>
			</div>
			<!-- DMT Message Modal -->
			<div id="dmt-message-modal" class="modal-overlay hidden">
				<div class="modal-content">
					<h4>请输入多媒体消息内容</h4>
					<div>
						<p>多媒体描述</p>
						<input type="text" id="dmt-content-input" placeholder="输入多媒体描述" style="width:100%; padding:0.6em 0.8em; border:1px solid #ddd; border-radius:0.6em; font-size:1.4em;"/>
					</div>
					<div class="modal-buttons">
						<button id="dmt-message-cancel">取消</button>
						<button id="dmt-message-confirm">确定</button>
					</div>
				</div>
			</div>
		</div>
		</div>
      </div>
    </div>
</div>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui-touch-punch/0.2.3/jquery.ui.touch-punch.min.js"></script>
<script>
    const RMPhone = {
        async init() {
          this.desktop.init();
          this.ui.init();
          this.app.init();          // DOM 都就位
          await this.core.init();   // ← 等“强健有力的手机设置”和 chatData 解析完
          this.app.qq.populateContacts(); // ← 现在填，列表就会有


          if (this.core.state._needsSettingsSave) {
            this.core.saveSettings();
            this.core.state._needsSettingsSave = false;
          }
        },

        core: {
            state: {
                chatData: `$1`,
                settings: {},
                settingsEntryLocation: { book: null, uid: null },
                emojiEntryLocation: { book: null, uid: null },
                availableViews: [],
                currentViewIndex: 0,
                pendingOpenContact: null,
                userAvatarUrl: '{{userAvatarPath}}',
                chatAvatars: {},
                unreadStatus: {},
                emojiList: [],
            },

            async init() {
                await this.loadAndApplySettings();
                await this.loadAndApplyMessageSettings();
                this.state.emojiList = await this.loadEmojiList();
                this.parseAllViews();
            },

            getBoundLorebookNames() {
                if (typeof getCharLorebooks !== 'function') return [];
                const { primary, additional } = getCharLorebooks();
                return [primary, ...(additional || [])].filter(Boolean);
            },

            async readSettingsFromBoundLorebooks(entryComment) {
                if (typeof getLorebookEntries !== 'function') return null;
                const names = this.getBoundLorebookNames();
                if (names.length === 0) return null;
                for (const name of names) {
                    try {
                        const entries = await getLorebookEntries(name);
                        const entry = entries.find(e => e.comment === entryComment);
                        if (entry) {
                            let parsed = null;
                            try { parsed = entry.content ? JSON.parse(entry.content) : null; } catch {}
                            return { loaded: parsed, foundBook: name, foundUid: entry.uid };
                        }
                    } catch {}
                }
                return { loaded: null, foundBook: names[0], foundUid: null };
            },

            async saveSettings() {
                const newSettings = {
                    userAvatarUrl: RMPhone.app.qq.elements.avatarUrlInput?.value || this.state.userAvatarUrl,
                    messageSize: parseInt(RMPhone.app.qq.elements.messageSizeSlider?.value || (this.state.settings.messageSize || 100), 10),
                    replyFormat: RMPhone.app.qq.elements.replyFormatSelect?.value || this.state.settings.replyFormat || 'same-level',
                    avatars: this.state.chatAvatars,
                    musicPlaylist: RMPhone.app.music.playlist,
                    backgrounds: this.state.settings.backgrounds || {},
                    contactSpecificSettings: this.state.settings.contactSpecificSettings || {},
                    unreadStatus: this.state.unreadStatus || {},
                    contactOrder: this.state.settings.contactOrder || [],
                    dynamicIslandEnabled: RMPhone.app.settings.elements.dynamicIslandToggle.checked,
                    nightModeEnabled: RMPhone.app.settings.elements.nightModeToggle ? RMPhone.app.settings.elements.nightModeToggle.checked : false,
                    shareMusicStatus: document.getElementById('share-music-status-checkbox')?.checked || false,
                    borderColor: RMPhone.app.settings.elements.borderColorPicker?.value,
                    aspectRatioW: RMPhone.app.settings.elements.aspectRatioWInput?.value,
                    aspectRatioH: RMPhone.app.settings.elements.aspectRatioHInput?.value,
                    fontSelection: RMPhone.app.settings.elements.fontSelect?.value,
                    customFontUrl: RMPhone.app.settings.elements.customFontUrlInput?.value
                };
                this.state.settings = newSettings;
                const entryComment = '强健有力的手机设置';
                if (typeof setLorebookEntries !== 'function' || typeof createLorebookEntries !== 'function') return;
                try {
                    if (this.state.settingsEntryLocation.book && this.state.settingsEntryLocation.uid != null) {
                        await setLorebookEntries(this.state.settingsEntryLocation.book, [{ uid: this.state.settingsEntryLocation.uid, content: JSON.stringify(newSettings, null, 2) }]);
                        return;
                    }
                    const names = this.getBoundLorebookNames();
                    if (names.length === 0) return;
                    const targetBook = names[0];
                    const res = await createLorebookEntries(targetBook, [{ comment: entryComment, content: JSON.stringify(newSettings, null, 2), enabled: true, order: 1213 }]);
                    if (res && res.new_uids && res.new_uids.length) {
                        this.state.settingsEntryLocation = { book: targetBook, uid: res.new_uids[0] };
                    } else if (typeof getLorebookEntries === 'function') {
                        const entries = await getLorebookEntries(targetBook);
                        const created = entries.find(e => e.comment === entryComment);
                        if (created) this.state.settingsEntryLocation = { book: targetBook, uid: created.uid };
                    }
                } catch (err) { console.error(err); }
            },

            async loadAndApplySettings() {
                const defaults = {
                    userAvatarUrl: '{{userAvatarPath}}',
                    messageSize: 100,
                    replyFormat: 'same-level',
                    avatars: {},
                    backgrounds: {},
                    contactOrder: [],
                    contactSpecificSettings: {},
                    borderColor: '#8A2BE2',
                    aspectRatioW: 37,
                    aspectRatioH: 76,
                    fontSelection: 'chill',
                    customFontUrl: ''
                };
                let loaded = { ...defaults };
                const entryComment = '强健有力的手机设置';
                const result = await this.readSettingsFromBoundLorebooks(entryComment);
                if (result) {
                    const { loaded: parsed, foundBook, foundUid } = result;
                    if (parsed && typeof parsed === 'object') loaded = { ...defaults, ...parsed };
                    this.state.settingsEntryLocation = { book: foundBook, uid: foundUid };
                    if (parsed == null && foundBook && typeof createLorebookEntries === 'function') {
                        try {
                            const res = await createLorebookEntries(foundBook, [{ comment: entryComment, content: JSON.stringify(loaded, null, 2), enabled: true, order: 1213 }]);
                            if (res && res.new_uids && res.new_uids.length) this.state.settingsEntryLocation = { book: foundBook, uid: res.new_uids[0] };
                            else if (typeof getLorebookEntries === 'function') {
                                const entries = await getLorebookEntries(foundBook);
                                const created = entries.find(e => e.comment === entryComment);
                                if (created) this.state.settingsEntryLocation = { book: foundBook, uid: created.uid };
                            }
                        } catch (err) { console.error(err); }
                    }
                }
                this.applySettings(loaded);
            },
            
            applySettings(newSettings) {
                this.state.settings = newSettings;
                RMPhone.app.settings.applyPhoneAppearanceSettings(newSettings);

                if (newSettings.nightModeEnabled) {
                    document.body.classList.add('night-mode');
                    if (RMPhone.app.settings.elements.nightModeToggle) RMPhone.app.settings.elements.nightModeToggle.checked = true;
                } else {
                    document.body.classList.remove('night-mode');
                    if (RMPhone.app.settings.elements.nightModeToggle) RMPhone.app.settings.elements.nightModeToggle.checked = false;
                }

                this.state.userAvatarUrl = newSettings.userAvatarUrl || '{{userAvatarPath}}';
                this.state.chatAvatars = newSettings.avatars || {};
                RMPhone.app.music.playlist = newSettings.musicPlaylist || [];
                this.state.settings.backgrounds = newSettings.backgrounds || {};
                this.state.settings.contactSpecificSettings = newSettings.contactSpecificSettings || {};
                this.state.settings.replyFormat = newSettings.replyFormat || 'same-level';
                this.state.unreadStatus = newSettings.unreadStatus || {};
                this.state.settings.contactOrder = newSettings.contactOrder || [];

                const islandEnabled = typeof newSettings.dynamicIslandEnabled === 'boolean' ? newSettings.dynamicIslandEnabled : true;
                RMPhone.app.settings.elements.dynamicIslandToggle.checked = islandEnabled;
                RMPhone.app.music.elements.notchContainer.classList.toggle('disabled', !islandEnabled);
                if (!islandEnabled) {
                    RMPhone.app.music.elements.playerTile.style.backgroundImage = 'none';
                }

                const shareMusicStatusCheckbox = document.getElementById('share-music-status-checkbox');
                if (shareMusicStatusCheckbox) {
                    shareMusicStatusCheckbox.checked = typeof newSettings.shareMusicStatus === 'boolean' ? newSettings.shareMusicStatus : false;
                }

                const scale = (newSettings.messageSize || 100) / 100;
                RMPhone.app.qq.elements.chatView.style.setProperty('--chat-scale', scale);
                if (RMPhone.app.qq.elements.messageSizeValue) RMPhone.app.qq.elements.messageSizeValue.textContent = newSettings.messageSize || 100;
                if (RMPhone.app.qq.elements.replyFormatSelect) RMPhone.app.qq.elements.replyFormatSelect.value = newSettings.replyFormat;
                
                if (RMPhone.app.qq.elements.avatarUrlInput) RMPhone.app.qq.elements.avatarUrlInput.value = this.state.userAvatarUrl || '';
		        if (RMPhone.app.qq.elements.messageSizeSlider) RMPhone.app.qq.elements.messageSizeSlider.value = newSettings.messageSize;
		        if (RMPhone.app.qq.elements.replyFormatSelect) RMPhone.app.qq.elements.replyFormatSelect.value = newSettings.replyFormat;

                this.parseAllViews();
                RMPhone.app.qq.chat.renderChatView(this.state.currentViewIndex);
            },
                applySettings(newSettings) {

                  if (!Array.isArray(newSettings.musicPlaylist) || newSettings.musicPlaylist.length === 0) {
                    newSettings.musicPlaylist = [{
                      title: "august",
                      artist: "Taylor Swift",
                      cover: "https://files.catbox.moe/gbws8m.jpg",
                      audio: "https://files.catbox.moe/l0avcp.ogg"
                    }];
                  this.state._needsSettingsSave = true; // ← 首次需要保存
                  }

                  RMPhone.app.music.playlist = newSettings.musicPlaylist || [];

                },

            parseAllViews() {
                this.state.availableViews = [];
                const viewRegex = /\[(和(.+?)私聊内容|(.+?)群聊内容)\]([\s\S]*?)\[\/\1\]/g;
                let match;
                let needsSave = false;
                while ((match = viewRegex.exec(this.state.chatData)) !== null) {
                    const fullTag = match[1];
                    const privateName = match[2];
                    const groupName = match[3];
                    const content = match[4].trim();
                    const type = privateName ? '私聊' : '群聊';
                    const name = privateName || groupName;
                    const avatarKey = `${type}.${name}`;
                    if (!this.state.chatAvatars[avatarKey]) {
                        this.state.chatAvatars[avatarKey] = 'https://files.catbox.moe/pcwffp.jpg';
                        needsSave = true;
                    }
                    const avatar = this.state.chatAvatars[avatarKey];
                    this.state.availableViews.push({ id: `[${fullTag}]`, type, name, avatar, content, rawBlock: match[0], key: avatarKey });
                }
                if (needsSave) this.saveSettings();
            },

            async updateTavernFloor() {
                if (typeof getChatMessages !== 'function' || typeof setChatMessages !== 'function') return;
                const lastMessage = getChatMessages(-1)?.[0];
                if (!lastMessage || typeof lastMessage.message !== 'string') return;
                const original = lastMessage.message;
                const phoneRegex = /<phone>[\s\S]*<\/phone>/;
                if (phoneRegex.test(original)) {
                    const newMsg = original.replace(phoneRegex, `<phone>${this.state.chatData}</phone>`);
                    await setChatMessages([{ message_id: lastMessage.message_id, message: newMsg }], { refresh: 'none' });
                } else {
                    await setChatMessages([{ message_id: lastMessage.message_id, message: this.state.chatData }], { refresh: 'none' });
                }
            },

            async loadEmojiList() {
                if (typeof getLorebookEntries !== 'function' || typeof createLorebookEntries !== 'function') {
                    return [];
                }
                const names = this.getBoundLorebookNames();
                if (!names || names.length === 0) return [];
                const entryComment = '强健有力的表情包存放';
                for (const name of names) {
                    try {
                        const entries = await getLorebookEntries(name);
                        const entry = entries.find(e => e.comment === entryComment);
                        if (entry) {
                            this.state.emojiEntryLocation = { book: name, uid: entry.uid };
                            const bqbContentMatch = (entry.content || '').match(/<bqb>([\s\S]*)<\/bqb>/);
                            const contentInsideBqb = bqbContentMatch ? bqbContentMatch[1] : '';
                            const lines = contentInsideBqb.split('\n');
                            const list = lines.map(line => {
                                const l = line.trim();
                                if (!l) return null;
                                const httpIndex = l.indexOf('http');
                                if (httpIndex >= 0) {
                                    const cname = l.slice(0, httpIndex);
                                    const url = l.slice(httpIndex);
                                    return { name: cname, messageTag: url, url: url };
                                } else {
                                    let idx = l.length;
                                    for (let i = l.length - 1; i >= 0; i--) {
                                        const code = l.charCodeAt(i);
                                        if (code <= 127) {
                                            idx = i;
                                        } else {
                                            break;
                                        }
                                    }
                                    const cname = l.slice(0, idx);
                                    const file = l.slice(idx);
                                    const fullUrl = 'https://files.catbox.moe/' + file;
                                    return { name: cname, messageTag: file, url: fullUrl };
                                }
                            }).filter(Boolean);
                            return list;
                        }
                    } catch (err) { console.error(err); }
                }

                const targetBook = names[0];
                try {
                    const entryData = {
                        comment: entryComment,
                        content: '<bqb>\n打坐https://files.catbox.moe/qzr8yo.jpg\n楚楚可怜ls7328.jpg\n</bqb>',
                        keys: ['<bqb>'],
                        enabled: true,
                        type: 'selective',
                        position: 'at_depth_as_system',
                        depth: 4,
                        prevent_recursion: true,
                        exclude_recursion: false,
                        order: 1213,
                    };
                    const res = await createLorebookEntries(targetBook, [entryData]);
                    if (res && res.new_uids && res.new_uids.length) {
                        this.state.emojiEntryLocation = { book: targetBook, uid: res.new_uids[0] };
                    } else if (typeof getLorebookEntries === 'function') {
                        const entries = await getLorebookEntries(targetBook);
                        const created = entries.find(e => e.comment === entryComment);
                        if (created) this.state.emojiEntryLocation = { book: targetBook, uid: created.uid };
                    }
                } catch (err) { console.error(err); }
                return [];
            },
            
            async loadAndApplyMessageSettings() {
                const entryComment = '强健有力的消息设置';
                if (typeof getLorebookEntries !== 'function' || typeof createLorebookEntries !== 'function') return;
                const names = this.getBoundLorebookNames();
                if (names.length === 0) return;

                for (const name of names) {
                    try {
                        const entries = await getLorebookEntries(name);
                        if (entries.some(e => e.comment === entryComment)) {
                            return;
                        }
                    } catch (err) { console.error(err); }
                }

                const targetBook = names[0];
                try {
                    const entryData = {
                        comment: entryComment,
                        content: `当user输入"[我方消息|{{消息内容}}|{{消息时间}}]"或"查看xxx发来的消息"时，AI必须强制使用该格式进行回复。严格禁止与其他回复格式同时使用：

        <phone>
        [和{{角色名}}私聊内容]
        <!-- 此处放置群聊内角色的消息 -->
        [/和{{角色名}}私聊内容]
        [{{群聊名}}群聊内容]
        <!-- 此处放置群聊内角色的消息 -->
        [/{{群聊名}}群聊内容]
        </phone>

        格式规范：
        - 禁止遗漏<phone>标签
        - [和{{角色名}}私聊内容]与[{{群聊名}}群聊内容]为固定格式，仅{{}}内容可以修改。
        - 无群聊需求时，无需在<phone>中添加[{{群聊名}}群聊内容]
        - 每一条消息格式都为[{{角色名}消息|{{头像URL}}|{{消息内容}}|{{消息时间}}]
          - {{角色名}}消息: 你所扮演角色的名字，结尾必须带“消息”二字。例如 游骁野消息。
          - {{头像URL}}: 角色的头像图片链接。此链接应保持稳定，不要在对话中频繁更换。更换头像时，无需任何系统提示，直接使用新URL即可。
          - {{消息内容}}: 消息的具体文本。这里可以包含纯文本，也可以使用下述的“特殊内容格式”。
          - {{消息时间}}: 消息的发送时间，格式应为 小时:分钟 (如 14:35)。时间应随对话自然推进，避免时间跳跃过大或停滞不变。
        - 严禁扮演用户: 绝对禁止生成任何 [我方消息|...] 格式的内容。你只能扮演你自己的角色。
        - 消息数量: 根据对话情景，每次回复3到7条消息。避免每次都只回一条或固定数量，要模拟真实聊天的打字和发送习惯。
        - 内容多样性: 不要总是以固定的方式（如表情、语气词）开头。让对话内容自然、生动，既要符合网络聊天习惯，又要符合角色性格。
        - 特殊内容格式 (在{{消息内容}}中使用，每个特殊格式独占一条回复消息格式)
          - 1. 表情包/贴纸 (<bqb>)：用于发送类似QQ/微信的大尺寸表情贴纸。格式: <bqb>{{表情包名}}{{表情包完整或部分url}}</bqb>。（仅可使用<bqb></bqb>中提供的{{表情包名}}{{表情包完整或部分url}}）
          - 2.语音消息 (<voice>)：模拟发送一段语音。格式: <voice>{{语音时长}}*{{语音转写的文字内容}}</voice>
          - 3. 多媒体 (<dmt>)：模拟发送多媒体图片、视频或文件。格式: <dmt>{{多媒体信息，如：一张照片，照片内容为...}}</dmt>
        - 你可以同时在多个窗口中回复消息。如果当前场景暗示了可能有多个对话正在进行，你的<phone>标签内就应该包含多个对应的聊天窗口。你甚至可以通过创建一个新的聊天窗口来主动开启与一个新角色的对话。
          
        示例：
        <phone>
        [生活分享群群聊内容]
        [游骁野消息|https://example.com/avatar.png|我刚拍的，今天天气真不错。|14:30]
        [游骁野消息|https://example.com/avatar.png|<dmt>一张天空的照片，云彩像棉花糖一样。</dmt>|14:30]
        [游骁野消息|https://example.com/avatar.png|<bqb>开心https://files.catbox.moe/happy.png</bqb>|14:31]
        [/生活分享群群聊内容]
        [和游骁野私聊内容]
        [游骁野消息|https://example.com/avatar.png|刚看到你的消息，会议刚结束，有点累。|14:32]
        [游骁野消息|https://example.com/avatar.png|<voice>0:05|晚点我们再聊吧。</voice>|14:33]
        [/和游骁野私聊内容]
        </phone>`,
                        keys: ['我方消息|', '查看'],
                        enabled: true,
                        type: 'selective',
                        position: 'at_depth_as_system',
                        depth: 0,
                        exclude_recursion: true,
                        order: 1213
                    };
                    await createLorebookEntries(targetBook, [entryData]);
                } catch (err) {
                    console.error('Failed to create message settings lorebook entry:', err);
                }
            }
        },

        desktop: {
            elements: {
                appContainer: null,
                greyApp: null,
                whiteApp: null,
            },
            init() {
                this.elements.appContainer = document.getElementById('app-container');
                this.elements.greyApp = document.getElementById('app-grey');
                this.elements.whiteApp = document.getElementById('app-white');

                this.elements.greyApp.addEventListener('click', () => RMPhone.ui.openView(RMPhone.app.settings.elements.settingsView));
                this.elements.whiteApp.addEventListener('click', () => {
                    RMPhone.app.qq.populateContacts();
                    RMPhone.ui.openView(RMPhone.app.qq.elements.contactsView);
                });
            }
        },

        ui: {
            elements: {
                backButtons: null,
            },
            animationDuration: 200,
            init() {
                this.elements.backButtons = document.querySelectorAll('.back-button');
                this.elements.backButtons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.preventDefault();
                        const viewToClose = button.closest('.view');
                        if (viewToClose) this.closeView(viewToClose);
                    });
                });
            },
            openView(view) {
                const appContainer = RMPhone.desktop.elements.appContainer;
                appContainer.classList.add('animate-zoom-out');
                setTimeout(() => {
                    appContainer.style.display = 'none';
                    appContainer.classList.remove('animate-zoom-out');
                    view.style.display = 'flex';
                    view.classList.add('animate-zoom-in');
                    setTimeout(() => view.classList.remove('animate-zoom-in'), this.animationDuration);
                }, this.animationDuration);
            },
            closeView(view) {
                const appContainer = RMPhone.desktop.elements.appContainer;
                view.classList.add('animate-zoom-out');
                setTimeout(() => {
                    view.style.display = 'none';
                    view.classList.remove('animate-zoom-out');
                    appContainer.style.display = 'flex';
                    appContainer.classList.add('animate-zoom-in');
                    setTimeout(() => appContainer.classList.remove('animate-zoom-in'), this.animationDuration);
                }, this.animationDuration);
            },
            showUrlEditModal(title, currentUrl, callback) {
                const modalId = 'url-edit-modal';
                let existingModal = document.getElementById(modalId);
                if (existingModal) existingModal.remove();

                const modalOverlay = document.createElement('div');
                modalOverlay.id = modalId;
                modalOverlay.className = 'modal-overlay';

                modalOverlay.innerHTML = `
                    <div class="modal-content">
                        <h4>${title}</h4>
                        <div>
                            <p>新的 URL</p>
                            <input type="text" id="url-edit-input" value="${currentUrl}" placeholder="https://..." style="width:100%; padding:0.6em 0.8em; border:1px solid #ddd; border-radius:0.6em; font-size:1.4em; box-sizing: border-box;"/>
                        </div>
                        <div class="modal-buttons">
                            <button id="url-edit-cancel">取消</button>
                            <button id="url-edit-confirm">确认</button>
                        </div>
                    </div>
                `;

                const screenContainer = document.querySelector('.screen-container');
                if (screenContainer) {
                    screenContainer.appendChild(modalOverlay);
                } else {
                    document.body.appendChild(modalOverlay);
                }

                modalOverlay.classList.remove('hidden');

                const input = modalOverlay.querySelector('#url-edit-input');
                const confirmBtn = modalOverlay.querySelector('#url-edit-confirm');
                const cancelBtn = modalOverlay.querySelector('#url-edit-cancel');

                const closeModal = () => {
                    modalOverlay.remove();
                };

                confirmBtn.addEventListener('click', () => {
                    callback(input.value.trim());
                    closeModal();
                });
                cancelBtn.addEventListener('click', closeModal);
                modalOverlay.addEventListener('click', (e) => {
                    if (e.target === modalOverlay) closeModal();
                });
            },
            updateUnreadIndicators() {
                document.querySelectorAll('.contact-item').forEach(item => {
                    const key = item.dataset.key;
                    const dot = item.querySelector('.unread-dot');
                    if (dot) {
                        if (RMPhone.core.state.unreadStatus[key]) dot.classList.remove('hidden');
                        else dot.classList.add('hidden');
                    }
                });

                const chatViewBackButtonDot = RMPhone.app.qq.elements.chatView.querySelector('.back-button .unread-dot');
                if (chatViewBackButtonDot) {
                    const hasUnread = Object.values(RMPhone.core.state.unreadStatus).some(status => status);
                    if (hasUnread) chatViewBackButtonDot.classList.remove('hidden');
                    else chatViewBackButtonDot.classList.add('hidden');
                }
            }
        },

        app: {
            init() {
                this.settings.init();
                this.music.init();
                this.qq.init();
            },
            settings: {
                elements: {},
                init() {
                    this.elements.settingsView = document.getElementById('view-grey');
                    this.elements.aboutView = document.getElementById('about-view');
                    this.elements.aboutEntry = document.getElementById('about-entry');
                    this.elements.musicManagerView = document.getElementById('music-manager-view');
                    this.elements.musicManagerEntry = document.getElementById('music-manager-entry');
                    this.elements.dynamicIslandToggle = document.getElementById('dynamic-island-toggle');
                    this.elements.nightModeToggle = document.getElementById('night-mode-toggle');
                    this.elements.borderColorPicker = document.getElementById('border-color-picker');
                    this.elements.aspectRatioWInput = document.getElementById('aspect-ratio-w');
                    this.elements.aspectRatioHInput = document.getElementById('aspect-ratio-h');
                    this.elements.fontSelect = document.getElementById('font-select');
                    this.elements.customFontItem = document.getElementById('custom-font-item');
                    this.elements.customFontUrlInput = document.getElementById('custom-font-url');
                    this.elements.phone = document.querySelector('.phone');
                    this.elements.styleTag = document.createElement('style');
                    document.head.appendChild(this.elements.styleTag);
                    this.elements.summaryView = document.getElementById('summary-view');
                    this.elements.summaryEntry = document.getElementById('summary-entry');
                    this.elements.confirmSummaryBtn = document.getElementById('confirm-summary-btn');
                    this.elements.summaryResultContainer = document.getElementById('summary-result-container');
                    this.elements.summaryResult = document.getElementById('summary-result');
                    this.elements.useSummaryBtn = document.getElementById('use-summary-btn');

                    this.elements.aboutEntry.addEventListener('click', () => RMPhone.ui.openView(this.elements.aboutView));
                    this.elements.musicManagerEntry.addEventListener('click', () => {
                        RMPhone.app.music.renderMusicList();
                        RMPhone.ui.openView(this.elements.musicManagerView);
                    });
                    this.elements.dynamicIslandToggle.addEventListener('change', () => {
                        const isDisabled = !this.elements.dynamicIslandToggle.checked;
                        RMPhone.app.music.elements.notchContainer.classList.toggle('disabled', isDisabled);
                        if (isDisabled) {
                            RMPhone.app.music.elements.playerTile.style.backgroundImage = 'none';
                            RMPhone.app.music.audio.pause();
                        } else {
                            const music = RMPhone.app.music;
                            if (music.playlist.length > 0 && music.playlist[music.currentSongIndex]) {
                                music.elements.playerTile.style.backgroundImage = `url('${music.playlist[music.currentSongIndex].cover}')`;
                            }
                        }
                        RMPhone.core.saveSettings();
                    });
                    this.elements.nightModeToggle.addEventListener('change', () => {
                        document.body.classList.toggle('night-mode', this.elements.nightModeToggle.checked);
                        RMPhone.core.saveSettings();
                    });
                    
                    this.elements.borderColorPicker.addEventListener('input', () => RMPhone.core.saveSettings());
                    this.elements.aspectRatioWInput.addEventListener('change', () => RMPhone.core.saveSettings());
                    this.elements.aspectRatioHInput.addEventListener('change', () => RMPhone.core.saveSettings());
                    this.elements.fontSelect.addEventListener('change', () => {
                        this.elements.customFontItem.classList.toggle('hidden', this.elements.fontSelect.value !== 'custom');
                        RMPhone.core.saveSettings();
                    });
                    this.elements.customFontUrlInput.addEventListener('change', () => RMPhone.core.saveSettings());

                    if (this.elements.summaryEntry) {
                        this.elements.summaryEntry.addEventListener('click', () => {
                            RMPhone.ui.openView(this.elements.summaryView);
                        });
                    }

                    if (this.elements.confirmSummaryBtn) {
                        this.elements.confirmSummaryBtn.addEventListener('click', async () => {
                            try {
                                this.elements.confirmSummaryBtn.disabled = true;
                                this.elements.confirmSummaryBtn.textContent = '总结中...';

                                const allPrompts = [{
                                    role: 'assistant',
                                    content: RMPhone.core.state.chatData
                                }];

                                const userInput = `总结当前的所有聊天记录，忠实的记录每个聊天块中发生的对话内容（不需要精确到每一条），精准的保留对话所产生的意义和情感变化。
                - “我方消息”为{{user}}消息，其他为角色消息。
                输出格式为：
“[和{{角色名}}私聊内容]
{{聊天总结内容}}
[/和{{角色名}}私聊内容]
[{{群聊名}}群聊内容]
{{聊天总结内容}}
[/{{群聊名}}群聊内容]”
注意事项：
- 总结内容绝对禁止包含<phone></phone>标签
- 总结内容长度应小于原始聊天内容`;

                                if (typeof generate !== 'function') {
                                    alert('generate 函数未定义。');
                                    return;
                                }

                                const result = await generate({
                                    user_input: userInput,
                                    overrides: {
                                        chat_history: {
                                            prompts: allPrompts
                                        }
                                    }
                                });

                                this.elements.summaryResult.textContent = result;
                                this.elements.summaryResultContainer.style.display = 'block';
                            } catch (error) {
                                console.error('总结生成失败:', error);
                                this.elements.summaryResult.textContent = `生成失败: ${error.message}`;
                                this.elements.summaryResultContainer.style.display = 'block';
                            } finally {
                                this.elements.confirmSummaryBtn.disabled = false;
                                this.elements.confirmSummaryBtn.textContent = '确认';
                            }
                        });
                    }

                    if (this.elements.useSummaryBtn) {
                        this.elements.useSummaryBtn.addEventListener('click', () => {
                            const summaryContent = this.elements.summaryResult.innerText.trim();
                            if (!summaryContent) {
                                alert('总结内容不能为空！');
                                return;
                            }
                            
                            const currentContact = RMPhone.app.qq.chat.getCurrentContactInfo();
                            const charName = currentContact ? currentContact.name : '{{char}}';

                            const command = `/addswipe switch=true ${summaryContent}|/sendas name=${charName} <phone></phone>`;
                            
                            if (typeof triggerSlash === 'function') {
                                triggerSlash(command);
                                alert('已使用总结内容执行命令。');
                            } else {
                                alert('triggerSlash 函数未定义。');
                            }
                        });
                    }
                },
                hexToHsl(hex) {
                    if (!hex) return { h: 0, s: 0, l: 0 };
                    let r = 0, g = 0, b = 0;
                    if (hex.length == 4) {
                        r = "0x" + hex[1] + hex[1];
                        g = "0x" + hex[2] + hex[2];
                        b = "0x" + hex[3] + hex[3];
                    } else if (hex.length == 7) {
                        r = "0x" + hex[1] + hex[2];
                        g = "0x" + hex[3] + hex[4];
                        b = "0x" + hex[5] + hex[6];
                    }
                    r /= 255; g /= 255; b /= 255;
                    let cmin = Math.min(r,g,b),
                        cmax = Math.max(r,g,b),
                        delta = cmax - cmin,
                        h = 0, s = 0, l = 0;

                    if (delta == 0) h = 0;
                    else if (cmax == r) h = ((g - b) / delta) % 6;
                    else if (cmax == g) h = (b - r) / delta + 2;
                    else h = (r - g) / delta + 4;

                    h = Math.round(h * 60);
                    if (h < 0) h += 360;

                    l = (cmax + cmin) / 2;
                    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
                    s = +(s * 100).toFixed(1);
                    l = +(l * 100).toFixed(1);

                    return { h, s, l };
                },
                applyPhoneAppearanceSettings(settings) {
                    const color = settings.borderColor || '#8A2BE2';
                    if (this.elements.borderColorPicker) this.elements.borderColorPicker.value = color;
                    const hsl = this.hexToHsl(color);
                    this.elements.phone.style.setProperty('--c-h', hsl.h);
                    this.elements.phone.style.boxShadow = `0 0 0.1em 0.25em hsl(${hsl.h}, 20%, 25%), 0 0 0 var(--border-width) hsl(${hsl.h}, 30%, 85%)`;

                    const w = settings.aspectRatioW || 37;
                    const h = settings.aspectRatioH || 76;
                    if(this.elements.aspectRatioWInput) this.elements.aspectRatioWInput.value = w;
                    if(this.elements.aspectRatioHInput) this.elements.aspectRatioHInput.value = h;
                    this.elements.phone.style.setProperty('--aspect-ratio', `${w}/${h}`);

                    const font = settings.fontSelection || 'chill';
                    const customUrl = settings.customFontUrl || '';
                    if(this.elements.fontSelect) this.elements.fontSelect.value = font;
                    if(this.elements.customFontUrlInput) this.elements.customFontUrlInput.value = customUrl;

                    if (font === 'custom' && customUrl) {
                        this.elements.styleTag.innerHTML = `${customUrl}`;
                        document.body.style.fontFamily = ''; 
                    } else if (font === 'chill') {
                        this.elements.styleTag.innerHTML = `@import url("https://fontsapi.zeoseven.com/83/main/result.css");`;
                        document.body.style.fontFamily = '"Chill Round Gothic", Inter, sans-serif';
                    } else if (font === 'noto') {
                        this.elements.styleTag.innerHTML = `@import url("https://fontsapi.zeoseven.com/69/main/result.css");`;
                        document.body.style.fontFamily = '"Noto Sans CJK", Inter, sans-serif';
                    } else {
                        this.elements.styleTag.innerHTML = '';
                        document.body.style.fontFamily = 'Inter, sans-serif';
                    }
                    this.elements.customFontItem.classList.toggle('hidden', font !== 'custom');
                }
            },
            music: {
                elements: {},
                playlist: [],
                currentSongIndex: 0,
                audio: new Audio(),
                isPlaying: false,
                editingSongIndex: -1,
                init() {
                    this.elements.notchContainer = document.querySelector('.notch-container');
                    this.elements.musicList = document.getElementById('music-list');
                    this.elements.addMusicBtn = document.getElementById('add-music-btn');
                    this.elements.addMusicModal = document.getElementById('add-music-modal');
                    this.elements.addMusicCancel = document.getElementById('add-music-cancel');
                    this.elements.addMusicConfirm = document.getElementById('add-music-confirm');
                    this.elements.addMusicTitle = document.getElementById('add-music-title');
                    this.elements.addMusicArtist = document.getElementById('add-music-artist');
                    this.elements.addMusicCover = document.getElementById('add-music-cover');
                    this.elements.addMusicAudio = document.getElementById('add-music-audio');
                    this.elements.editMusicModal = document.getElementById('edit-music-modal');
                    this.elements.editMusicCancel = document.getElementById('edit-music-cancel');
                    this.elements.editMusicConfirm = document.getElementById('edit-music-confirm');
                    this.elements.editMusicTitle = document.getElementById('edit-music-title');
                    this.elements.editMusicArtist = document.getElementById('edit-music-artist');
                    this.elements.editMusicCover = document.getElementById('edit-music-cover');
                    this.elements.editMusicAudio = document.getElementById('edit-music-audio');
                    this.elements.playerTile = document.querySelector('.notch .tile');
                    this.elements.playerTitle = document.querySelector('.notch .song-title');
                    this.elements.playerArtist = document.querySelector('.notch .song-artist');
                    this.elements.playerPauseBtn = document.getElementById('pause-btn');
                    this.elements.playerNextBtn = document.getElementById('next-btn');
                    this.elements.playerPlaylistBtn = document.getElementById('playlist-btn');
                    this.elements.playerPlaylistView = document.getElementById('playlist-view').querySelector('ul');
                    this.elements.pauseBtnIcon = this.elements.playerPauseBtn.querySelector('img');
                    this.elements.playlistView = document.getElementById('playlist-view');

                    this.elements.addMusicBtn.addEventListener('click', () => this.elements.addMusicModal.classList.remove('hidden'));
                    this.elements.addMusicCancel.addEventListener('click', () => this.elements.addMusicModal.classList.add('hidden'));
                    this.elements.addMusicConfirm.addEventListener('click', () => {
                        const newSong = {
                            title: this.elements.addMusicTitle.value.trim(),
                            artist: this.elements.addMusicArtist.value.trim(),
                            cover: this.elements.addMusicCover.value.trim(),
                            audio: this.elements.addMusicAudio.value.trim()
                        };
                        if (newSong.title && newSong.artist && newSong.cover && newSong.audio) {
                            this.playlist.push(newSong);
                            RMPhone.core.saveSettings();
                            this.renderMusicList();
                            this.renderPlayerPlaylist();
                            if (this.playlist.length === 1) {
                                this.loadSongToPlayer(0);
                            }
                            this.elements.addMusicModal.classList.add('hidden');
                            this.elements.addMusicTitle.value = '';
                            this.elements.addMusicArtist.value = '';
                            this.elements.addMusicCover.value = '';
                            this.elements.addMusicAudio.value = '';
                        } else {
                            alert('请填写所有字段');
                        }
                    });

                    this.elements.musicList.addEventListener('click', (e) => {
                        if (e.target.classList.contains('delete-music-btn')) {
                            const index = parseInt(e.target.dataset.index, 10);
                            this.playlist.splice(index, 1);
                            RMPhone.core.saveSettings();
                            this.renderMusicList();
                            this.renderPlayerPlaylist();

                            if (this.isPlaying && this.currentSongIndex === index) {
                                this.isPlaying = false;
                            }

                            if (this.playlist.length > 0) {
                                const newIndex = Math.min(this.currentSongIndex, this.playlist.length - 1);
                                this.loadSongToPlayer(newIndex);
                            } else {
                                this.loadSongToPlayer(-1);
                            }
                        }
                    });

                    this.elements.musicList.addEventListener('dblclick', (e) => {
                        const li = e.target.closest('li');
                        if (li && li.dataset.index) {
                            this.editingSongIndex = parseInt(li.dataset.index, 10);
                            const song = this.playlist[this.editingSongIndex];
                            if (song) {
                                this.elements.editMusicTitle.value = song.title;
                                this.elements.editMusicArtist.value = song.artist;
                                this.elements.editMusicCover.value = song.cover;
                                this.elements.editMusicAudio.value = song.audio;
                                this.elements.editMusicModal.classList.remove('hidden');
                            }
                        }
                    });

                    this.elements.editMusicCancel.addEventListener('click', () => {
                        this.elements.editMusicModal.classList.add('hidden');
                        this.editingSongIndex = -1;
                    });

                    this.elements.editMusicConfirm.addEventListener('click', () => {
                        if (this.editingSongIndex === -1) return;

                        const updatedSong = {
                            title: this.elements.editMusicTitle.value.trim(),
                            artist: this.elements.editMusicArtist.value.trim(),
                            cover: this.elements.editMusicCover.value.trim(),
                            audio: this.elements.editMusicAudio.value.trim()
                        };

                        if (updatedSong.title && updatedSong.artist && updatedSong.cover && updatedSong.audio) {
                            this.playlist[this.editingSongIndex] = updatedSong;
                            RMPhone.core.saveSettings();
                            this.renderMusicList();
                            this.renderPlayerPlaylist();

                            if (this.currentSongIndex === this.editingSongIndex) {
                                const wasPlaying = this.isPlaying;
                                this.loadSongToPlayer(this.currentSongIndex);
                                if (wasPlaying) {
                                    this.audio.play().catch(e => console.error("Playback failed:", e));
                                }
                            }

                            this.elements.editMusicModal.classList.add('hidden');
                            this.editingSongIndex = -1;
                        } else {
                            alert('请填写所有字段');
                        }
                    });

                    this.elements.playerPauseBtn.addEventListener('click', () => this.togglePlayPause());
                    this.elements.playerNextBtn.addEventListener('click', () => this.playNextSong());
                    this.elements.playerPlaylistView.addEventListener('click', (e) => {
                        const li = e.target.closest('li');
                        if (li && li.dataset.index) {
                            const index = parseInt(li.dataset.index, 10);
                            if (this.currentSongIndex === index && this.isPlaying) {
                                this.elements.playlistView.classList.add('hidden');
                                return;
                            }

                            this.loadSongToPlayer(index);
                            this.audio.play().catch(e => console.error("Playback failed:", e));

                            this.elements.playlistView.classList.add('hidden');
                        }
                    });
                    this.audio.addEventListener('ended', () => this.playNextSong());
                    this.audio.addEventListener('play', () => { this.isPlaying = true; this.elements.pauseBtnIcon.src = "https://img.icons8.com/ios-glyphs/30/FFFFFF/pause.png"; });
                    this.audio.addEventListener('pause', () => { this.isPlaying = false; this.elements.pauseBtnIcon.src = "https://img.icons8.com/ios-glyphs/30/FFFFFF/play.png"; });
                    
                    if(this.elements.playerPlaylistBtn && this.elements.playlistView) {
                        this.elements.playerPlaylistBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.elements.playlistView.classList.toggle('hidden');
                        });
                    }
                    this.elements.notchContainer.addEventListener('focusout', (e) => {
                        if (!e.currentTarget.contains(e.relatedTarget)) {
                            this.elements.playlistView.classList.add('hidden');
                        }
                    });

                    if (this.playlist.length === 0) {
                        this.playlist.push({
                            title: "august",
                            artist: "Taylor Swift",
                            cover: "https://files.catbox.moe/gbws8m.jpg",
                            audio: "https://files.catbox.moe/l0avcp.ogg"
                        });
                    }

                    if (this.playlist.length > 0) {
                        this.loadSongToPlayer(this.currentSongIndex < this.playlist.length ? this.currentSongIndex : 0);
                    } else {
                        this.loadSongToPlayer(-1);
                    }
                    this.renderPlayerPlaylist();
                },
                renderMusicList() {
                    if (!this.elements.musicList) return;
                    this.elements.musicList.innerHTML = '';
                    if (this.playlist.length === 0) {
                        this.elements.musicList.innerHTML = '<p style="text-align:center; color:#888; padding:2em; font-size: 1.4em;">暂无歌曲</p>';
                        return;
                    }
                    this.playlist.forEach((song, index) => {
                        const li = document.createElement('li');
                        li.innerHTML = `
                            <div class="music-cover" style="background-image: url('${song.cover}')"></div>
                            <div class="music-info">
                                <div class="music-title">${song.title}</div>
                                <div class="music-artist">${song.artist}</div>
                            </div>
                            <button class="delete-music-btn" data-index="${index}">&times;</button>
                        `;
                        li.dataset.index = index;
                        this.elements.musicList.appendChild(li);
                    });
                },
                renderPlayerPlaylist() {
                    if (!this.elements.playerPlaylistView) return;
                    this.elements.playerPlaylistView.innerHTML = '';
                    this.playlist.forEach((song, index) => {
                        const li = document.createElement('li');
                        li.style.cssText = "padding: 0.5em 0; border-bottom: 1px solid rgba(255,255,255,0.2); cursor: pointer;";
                        li.textContent = `${song.title} - ${song.artist}`;
                        li.dataset.index = index;
                        if (index === this.playlist.length - 1) {
                            li.style.borderBottom = 'none';
                        }
                        this.elements.playerPlaylistView.appendChild(li);
                    });
                },
                loadSongToPlayer(index) {
                    if (index < 0 || index >= this.playlist.length) {
                        this.audio.pause();
                        this.audio.src = "";
                        this.elements.playerTile.style.backgroundImage = '';
                        this.elements.playerTitle.textContent = '播放列表为空';
                        this.elements.playerArtist.textContent = '';
                        return;
                    };

                    this.currentSongIndex = index;
                    const song = this.playlist[index];

                    this.elements.playerTile.style.backgroundImage = `url('${song.cover}')`;
                    this.elements.playerTitle.textContent = song.title;
                    this.elements.playerArtist.textContent = song.artist;

                    if (song.audio) {
                        this.audio.src = song.audio;
                        this.audio.load();
                    } else {
                        this.audio.src = "";
                        this.audio.pause();
                    }
                    this.renderPlayerPlaylist();
                },
                togglePlayPause() {
                    if (!this.audio.src || this.playlist.length === 0) return;
                    if (this.isPlaying) {
                        this.audio.pause();
                    } else {
                        this.audio.play().catch(e => console.error("Playback failed:", e));
                    }
                },
                playNextSong() {
                    if (this.playlist.length === 0) return;
                    const nextIndex = (this.currentSongIndex + 1) % this.playlist.length;
                    this.loadSongToPlayer(nextIndex);
                    this.audio.play().catch(e => console.error("Playback failed:", e));
                }
            },
            qq: {
                elements: {},
                isContactEditMode: false,
                init() {
                    this.elements.chatView = document.getElementById('view-white');
                    this.elements.contactsView = document.getElementById('view-contacts');
                    this.elements.settingsButton = document.querySelector('.settings-button');
                    this.elements.settingsPanel = document.querySelector('.settings-panel');
                    this.elements.chatTitle = this.elements.chatView.querySelector('.chat-name');
                    this.elements.chatMessagesContainer = this.elements.chatView.querySelector('.chat-messages');
                    this.elements.messageInput = this.elements.chatView.querySelector('.message-input');
                    this.elements.sendButton = this.elements.chatView.querySelector('.send-button');
                    this.elements.avatarUrlInput = document.getElementById('avatar-url-input');
                    this.elements.replyFormatSelect = document.getElementById('reply-format-select');
                    this.elements.messageSizeSlider = document.getElementById('message-size-slider');
                    this.elements.messageSizeValue = document.getElementById('message-size-value');
                    this.elements.chatBgUrlInput = document.getElementById('chat-bg-url-input');
                    this.elements.useContactAvatarCheckbox = document.getElementById('use-contact-avatar-checkbox');
                    this.elements.contactsList = this.elements.contactsView.querySelector('.contacts-list');
                    this.elements.addContactButton = this.elements.contactsView.querySelector('.add-contact-button');
                    this.elements.createContactModal = document.getElementById('create-contact-modal');
                    this.elements.createContactType = document.getElementById('create-contact-type');
                    this.elements.createContactName = document.getElementById('create-contact-name');
                    this.elements.createContactAvatar = document.getElementById('create-contact-avatar');
                    this.elements.groupMembersContainer = document.getElementById('group-members-container');
                    this.elements.groupExtraInput = document.getElementById('group-extra-input');
                    this.elements.createContactCancel = document.getElementById('create-contact-cancel');
                    this.elements.createContactConfirm = document.getElementById('create-contact-confirm');
                    this.elements.deleteContactModal = document.getElementById('delete-contact-modal');
                    this.elements.deleteContactText = document.getElementById('delete-contact-text');
                    this.elements.deleteContactCancel = document.getElementById('delete-contact-cancel');
                    this.elements.deleteContactConfirm = document.getElementById('delete-contact-confirm');
                    this.elements.voiceMessageModal = document.getElementById('voice-message-modal');
                    this.elements.voiceDurationInput = document.getElementById('voice-duration-input');
                    this.elements.voiceContentInput = document.getElementById('voice-content-input');
                    this.elements.voiceMessageCancel = document.getElementById('voice-message-cancel');
                    this.elements.voiceMessageConfirm = document.getElementById('voice-message-confirm');
                    this.elements.dmtMessageModal = document.getElementById('dmt-message-modal');
                    this.elements.dmtContentInput = document.getElementById('dmt-content-input');
                    this.elements.dmtMessageCancel = document.getElementById('dmt-message-cancel');
                    this.elements.dmtMessageConfirm = document.getElementById('dmt-message-confirm');
                    this.elements.micButton = document.querySelector('.mic-button');
                    this.elements.imageButton = document.querySelector('.image-button');
                    this.elements.doneEditButton = this.elements.contactsView.querySelector('.done-edit-button');
                    this.elements.emojiButton = this.elements.chatView.querySelector('.emoji-button');
                    this.elements.emojiPickerContainer = this.elements.chatView.querySelector('.emoji-picker-container');

                    this.chat.init();
                    this.contact.init();
                    
                    RMPhone.desktop.elements.appContainer.style.display = 'flex';
                    RMPhone.app.settings.elements.settingsView.style.display = 'none';
                    this.elements.chatView.style.display = 'none';
                    this.elements.contactsView.style.display = 'none';

                    RMPhone.ui.openView(this.elements.contactsView);
                },
                contact: {
                    init() {
                        const qq = RMPhone.app.qq;
                        qq.elements.addContactButton?.addEventListener('click', () => this.openCreateContactModal());
                        qq.elements.createContactCancel?.addEventListener('click', () => this.closeCreateContactModal());
                        qq.elements.createContactType?.addEventListener('change', () => {
                            const wrap = document.getElementById('group-members-wrapper');
                            if (!wrap) return;
                            if (qq.elements.createContactType.value === '群聊') {
                                wrap.classList.remove('hidden');
                                if (qq.elements.groupMembersContainer) {
                                    qq.elements.groupMembersContainer.innerHTML = '';
                                    const keys = Object.keys(RMPhone.core.state.chatAvatars || {}).filter(k => k.startsWith('私聊.'));
                                    if (keys.length === 0) {
                                        qq.elements.groupMembersContainer.innerHTML = '<div style="color:#888; font-size:1.2em;">暂无可选联系人</div>';
                                    } else {
                                        keys.forEach(k => {
                                            const name = k.split('.')[1];
                                            const el = document.createElement('label');
                                            el.style.cssText = 'display:flex; align-items:center; gap:0.4em; background:#fff; border:1px solid #eee; border-radius:0.5em; padding:0.3em 0.6em;';
                                            el.innerHTML = `<input type="checkbox" value="${name}"/><span>${name}</span>`;
                                            qq.elements.groupMembersContainer.appendChild(el);
                                        });
                                    }
                                }
                            } else {
                                wrap.classList.add('hidden');
                            }
                        });
                        qq.elements.createContactConfirm?.addEventListener('click', async () => {
                            const type = qq.elements.createContactType.value;
                            const name = qq.elements.createContactName.value.trim();
                            let avatar = qq.elements.createContactAvatar.value.trim();
                            if (!name) return alert('名称不能为空');
                            if (!avatar) avatar = 'https://files.catbox.moe/pcwffp.jpg';
                            const key = `${type}.${name}`;
                            RMPhone.core.state.chatAvatars[key] = avatar;
                            await RMPhone.core.saveSettings();
                            if (type === '群聊') {
                                await this.maybeCreateGroupSelectiveEntry(name);
                            }
                            RMPhone.core.parseAllViews();
                            qq.populateContacts();
                            this.closeCreateContactModal();
                        });
                        qq.elements.doneEditButton.addEventListener('click', () => this.exitContactEditMode());
                    },
                    openCreateContactModal() {
                        const qq = RMPhone.app.qq;
                        qq.elements.createContactType.value = '私聊';
                        qq.elements.createContactName.value = '';
                        qq.elements.createContactAvatar.value = '';
                        qq.elements.createContactModal.classList.remove('hidden');

                        const wrap = document.getElementById('group-members-wrapper');
                        if (wrap) wrap.classList.add('hidden');
                        if (qq.elements.groupMembersContainer) qq.elements.groupMembersContainer.innerHTML = '';
                        if (qq.elements.groupExtraInput) qq.elements.groupExtraInput.value = '';
                    },
                    closeCreateContactModal() {
                        RMPhone.app.qq.elements.createContactModal.classList.add('hidden');
                    },
                    enterContactEditMode() {
                        const qq = RMPhone.app.qq;
                        qq.isContactEditMode = true;
                        document.body.classList.add('contact-edit-mode');
                        qq.elements.addContactButton.classList.add('hidden');
                        qq.elements.doneEditButton.classList.remove('hidden');
                        if ($(qq.elements.contactsList).data('ui-sortable')) {
                            $(qq.elements.contactsList).sortable('enable');
                        }
                    },
                    exitContactEditMode() {
                        const qq = RMPhone.app.qq;
                        qq.isContactEditMode = false;
                        document.body.classList.remove('contact-edit-mode');
                        qq.elements.addContactButton.classList.remove('hidden');
                        qq.elements.doneEditButton.classList.add('hidden');
                        if ($(qq.elements.contactsList).data('ui-sortable')) {
                            $(qq.elements.contactsList).sortable('disable');
                        }
                    },
                    async deleteContact(view) {
                        const key = `${view.type || '私聊'}.${view.name}`;
                        RMPhone.core.parseAllViews();
                        const idx = RMPhone.core.state.availableViews.findIndex(v => v.name === view.name && v.type === (view.type || '私聊'));
                        if (idx !== -1) {
                            const block = RMPhone.core.state.availableViews[idx].rawBlock;
                            RMPhone.core.state.chatData = RMPhone.core.state.chatData.replace(block, '').trim();
                            await RMPhone.core.updateTavernFloor();
                        }
                        if (RMPhone.core.state.settings && RMPhone.core.state.settings.avatars) delete RMPhone.core.state.settings.avatars[key];
                        const bgKey = `${view.type || '私聊'}.${view.name}.背景图片`;
                        if (RMPhone.core.state.settings && RMPhone.core.state.settings.backgrounds && RMPhone.core.state.settings.backgrounds[bgKey]) delete RMPhone.core.state.settings.backgrounds[bgKey];
                        if (RMPhone.core.state.settings && RMPhone.core.state.settings.contactSpecificSettings && RMPhone.core.state.settings.contactSpecificSettings[key]) {
                            delete RMPhone.core.state.settings.contactSpecificSettings[key];
                        }
                        await RMPhone.core.saveSettings();
                        RMPhone.core.parseAllViews();
                    },
                    async maybeCreateGroupSelectiveEntry(groupName) {
                        try {
                            if (typeof createLorebookEntries !== 'function' || typeof getLorebookEntries !== 'function') return;
                            const names = RMPhone.core.getBoundLorebookNames();
                            if (names.length === 0) return;
                            const book = names[0];
                            const entries = await getLorebookEntries(book);
                            const newComment = `强健有力的群聊：${groupName}`;
                            if (entries.find(e => e.comment === newComment)) return;
                            let members = [];
                            const qq = RMPhone.app.qq;
                            if (qq.elements.groupMembersContainer) {
                                members = [...qq.elements.groupMembersContainer.querySelectorAll('input[type="checkbox"]:checked')].map((i) => i.value.trim()).filter(Boolean);
                            }
                            if (qq.elements.groupExtraInput && qq.elements.groupExtraInput.value.trim()) {
                                members = members.concat(qq.elements.groupExtraInput.value.split(',').map(s => s.trim()).filter(Boolean));
                            }
                            members = Array.from(new Set(members));
                            const content = `${members.join('、')}在同一群聊中，该群聊名为${groupName}。`;
                            await createLorebookEntries(book, [{
                                comment: newComment,
                                enabled: true,
                                type: 'selective',
                                keys: ['群聊'],
                                position: 'at_depth_as_system',
                                depth: 4,
                                prevent_recursion: false,
                                exclude_recursion: false,
                                order: 1213,
                                content
                            }]);
                        } catch (err) { console.error(err); }
                    }
                },
                chat: {
                    init() {
                        const qq = RMPhone.app.qq;
                        qq.elements.chatMessagesContainer.addEventListener('click', (e) => {
                            const toggleButton = e.target.closest('.th-voice-toggle');
                            if (!toggleButton) return;

                            const voiceContainer = toggleButton.closest('.th-voice-container');
                            if (!voiceContainer) return;

                            const textElement = voiceContainer.querySelector('.th-voice-text');
                            if (!textElement) return;

                            const isHidden = textElement.style.display === 'none';
                            textElement.style.display = isHidden ? 'block' : 'none';
                        });

                        qq.elements.micButton?.addEventListener('click', () => qq.elements.voiceMessageModal.classList.remove('hidden'));
                        qq.elements.imageButton?.addEventListener('click', () => qq.elements.dmtMessageModal.classList.remove('hidden'));
                        qq.elements.voiceMessageCancel?.addEventListener('click', () => qq.elements.voiceMessageModal.classList.add('hidden'));
                        qq.elements.dmtMessageCancel?.addEventListener('click', () => qq.elements.dmtMessageModal.classList.add('hidden'));

                        qq.elements.voiceMessageConfirm?.addEventListener('click', () => {
                            const duration = qq.elements.voiceDurationInput.value.trim();
                            const content = qq.elements.voiceContentInput.value.trim();
                            if (duration && content) {
                                const message = `<voice>${duration}*${content}</voice>`;
                                qq.elements.messageInput.value = message;
                                this.handleSendMessage();
                                qq.elements.voiceMessageModal.classList.add('hidden');
                                qq.elements.voiceDurationInput.value = '';
                                qq.elements.voiceContentInput.value = '';
                            }
                        });

                        qq.elements.dmtMessageConfirm?.addEventListener('click', () => {
                            const content = qq.elements.dmtContentInput.value.trim();
                            if (content) {
                                const message = `<dmt>${content}</dmt>`;
                                qq.elements.messageInput.value = message;
                                this.handleSendMessage();
                                qq.elements.dmtMessageModal.classList.add('hidden');
                                qq.elements.dmtContentInput.value = '';
                            }
                        });

                        if (qq.elements.settingsButton && qq.elements.settingsPanel) {
                            qq.elements.settingsButton.addEventListener('click', () => {
                                const contactInfo = this.getCurrentContactInfo();
                                if (contactInfo) {
                                    const bgKey = `${contactInfo.type}.${contactInfo.name}.背景图片`;
                                    if (qq.elements.chatBgUrlInput) qq.elements.chatBgUrlInput.value = RMPhone.core.state.settings.backgrounds?.[bgKey] || '';

                                    const contactSettings = RMPhone.core.state.settings.contactSpecificSettings?.[contactInfo.key] || {};
                                    if (qq.elements.useContactAvatarCheckbox) qq.elements.useContactAvatarCheckbox.checked = contactSettings.useContactAvatar || false;
                                }
                                qq.elements.settingsPanel.classList.toggle('hidden');
                            });
                            const closeSettingsButton = document.querySelector('.close-settings-button');
                            if (closeSettingsButton) closeSettingsButton.addEventListener('click', () => qq.elements.settingsPanel.classList.add('hidden'));
                        }
                        
                        if (qq.elements.emojiButton && qq.elements.emojiPickerContainer) {
                            qq.elements.emojiButton.addEventListener('click', () => {
                                const isOpen = qq.elements.chatView.classList.toggle('emoji-picker-open');
                                qq.elements.emojiButton.classList.toggle('active', isOpen);

                                if (isOpen && !qq.elements.emojiPickerContainer.hasChildNodes()) {
                                    if (RMPhone.core.state.emojiList && RMPhone.core.state.emojiList.length > 0) {
                                        const grid = document.createElement('div');
                                        grid.className = 'emoji-picker-grid';
                                        RMPhone.core.state.emojiList.forEach(item => {
                                            const div = document.createElement('div');
                                            div.className = 'emoji-item';
                                            div.innerHTML = `
                                                <img src="${item.url}" alt="${item.name}">
                                                <span>${item.name}</span>
                                            `;
                                            div.addEventListener('click', () => {
                                                qq.elements.messageInput.value = `<bqb>${item.name}${item.messageTag}</bqb>`;
                                                qq.elements.sendButton.click();
                                                qq.elements.chatView.classList.remove('emoji-picker-open');
                                                qq.elements.emojiButton.classList.remove('active');
                                            });
                                            grid.appendChild(div);
                                        });
                                        qq.elements.emojiPickerContainer.appendChild(grid);
                                    } else {
                                        qq.elements.emojiPickerContainer.innerHTML = '<p style="text-align:center; color:#888; padding-top:2em; font-size: 1.4em; grid-column: 1 / -1;">没有可用的表情包</p>';
                                    }
                                }
                            });
                        }
                        
                        qq.elements.chatMessagesContainer.addEventListener('dblclick', (e) => {
                            const bubble = e.target.closest('.bubble');
                            const sentAvatar = e.target.closest('.message.sent .avatar');

                            if (bubble) {
                                const msg = bubble.closest('.message');
                                if (msg) {
                                    this.openActionMenu(msg, parseInt(msg.dataset.messageIndex, 10));
                                }
                            } else if (sentAvatar) {
                                RMPhone.ui.showUrlEditModal('修改你的头像', RMPhone.core.state.userAvatarUrl, async (newUrl) => {
                                    if (newUrl) {
                                        RMPhone.core.state.userAvatarUrl = newUrl;
                                        if (qq.elements.avatarUrlInput) qq.elements.avatarUrlInput.value = newUrl;
                                        await RMPhone.core.saveSettings();
                                        this.renderChatView(RMPhone.core.state.currentViewIndex);
                                    }
                                });
                            }
                        });
                        qq.elements.sendButton.addEventListener('click', () => this.handleSendMessage());
                        qq.elements.sendButton.addEventListener('dblclick', () => this.handleGenerate());
                        qq.elements.messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); this.handleSendMessage(); } });
                        
                        qq.elements.avatarUrlInput?.addEventListener('change', () => { RMPhone.core.state.settings.userAvatarUrl = qq.elements.avatarUrlInput.value; RMPhone.core.saveSettings(); });
                        if (qq.elements.messageSizeSlider) {
                            const updateScale = () => {
                                const scale = qq.elements.messageSizeSlider.value / 100;
                                qq.elements.chatView.style.setProperty('--chat-scale', scale);
                                if (qq.elements.settingsPanel) qq.elements.settingsPanel.style.setProperty('--chat-scale', scale);
                                if (qq.elements.createContactModal) qq.elements.createContactModal.style.setProperty('--chat-scale', scale);
                                if (qq.elements.messageSizeValue) qq.elements.messageSizeValue.textContent = qq.elements.messageSizeSlider.value;
                            };
                            qq.elements.messageSizeSlider.addEventListener('input', updateScale);
                            qq.elements.messageSizeSlider.addEventListener('change', () => {
                                RMPhone.core.state.settings.messageSize = parseInt(qq.elements.messageSizeSlider.value, 10);
                                RMPhone.core.saveSettings();
                            });
                        }
                        qq.elements.replyFormatSelect?.addEventListener('change', () => { RMPhone.core.state.settings.replyFormat = qq.elements.replyFormatSelect.value; RMPhone.core.saveSettings(); });
                        qq.elements.chatBgUrlInput?.addEventListener('change', () => {
                            const contactInfo = this.getCurrentContactInfo(); if (!contactInfo) return;
                            const bgKey = `${contactInfo.type}.${contactInfo.name}.背景图片`;
                            const url = qq.elements.chatBgUrlInput.value.trim();
                            RMPhone.core.state.settings.backgrounds = RMPhone.core.state.settings.backgrounds || {};
                            if (url) RMPhone.core.state.settings.backgrounds[bgKey] = url; else delete RMPhone.core.state.settings.backgrounds[bgKey];
                            RMPhone.core.saveSettings();
                            if (RMPhone.core.state.currentViewIndex !== -1) this.renderChatView(RMPhone.core.state.currentViewIndex);
                            else {
                                qq.elements.chatView.style.backgroundColor = '';
                                if (url) {
                                    qq.elements.chatView.style.backgroundImage = `url('${url}')`;
                                    qq.elements.chatView.style.backgroundSize = 'cover';
                                    qq.elements.chatView.style.backgroundPosition = 'center';
                                    qq.elements.chatView.style.backgroundRepeat = 'no-repeat';
                                } else {
                                    qq.elements.chatView.style.backgroundImage = '';
                                }
                            }
                        });

                        qq.elements.useContactAvatarCheckbox?.addEventListener('change', () => {
                            const contactInfo = this.getCurrentContactInfo(); if (!contactInfo) return;
                            const key = contactInfo.key;
                            RMPhone.core.state.settings.contactSpecificSettings = RMPhone.core.state.settings.contactSpecificSettings || {};
                            RMPhone.core.state.settings.contactSpecificSettings[key] = RMPhone.core.state.settings.contactSpecificSettings[key] || {};
                            RMPhone.core.state.settings.contactSpecificSettings[key].useContactAvatar = qq.elements.useContactAvatarCheckbox.checked;
                            RMPhone.core.saveSettings();
                            if (RMPhone.core.state.currentViewIndex !== -1) this.renderChatView(RMPhone.core.state.currentViewIndex);
                        });

                        const shareMusicStatusCheckbox = document.getElementById('share-music-status-checkbox');
                        if (shareMusicStatusCheckbox) {
                            shareMusicStatusCheckbox.addEventListener('change', () => {
                                RMPhone.core.state.settings.shareMusicStatus = shareMusicStatusCheckbox.checked;
                                RMPhone.core.saveSettings();
                            });
                        }
                    },
                    getCurrentContactInfo() {
                        const core = RMPhone.core.state;
                        if (core.currentViewIndex !== -1 && core.availableViews[core.currentViewIndex]) {
                            return core.availableViews[core.currentViewIndex];
                        }
                        if (core.pendingOpenContact) {
                            return {
                                ...core.pendingOpenContact,
                                key: `${core.pendingOpenContact.type}.${core.pendingOpenContact.name}`
                            };
                        }
                        return null;
                    },
                    processMessageContent(rawText) {
                        if (typeof rawText !== 'string') return rawText;
                        let processedText = rawText;

                        const bqbRegex = /<bqb>([\s\S]*?)<\/bqb>/gi;
                        processedText = processedText.replace(bqbRegex, (_, inner) => {
                            const innerContent = (inner || '').trim();
                            if (!innerContent) return '';

                            let url = '';
                            const httpIndex = innerContent.indexOf('http');
                            if (httpIndex !== -1) {
                                const urlMatch = innerContent.slice(httpIndex).match(/https?:\/\/\S+/);
                                if (urlMatch) url = urlMatch[0];
                            } else {
                                let filenameStartIndex = -1;
                                for (let i = innerContent.length - 1; i >= 0; i--) {
                                    if (innerContent.charCodeAt(i) <= 127) {
                                        filenameStartIndex = i;
                                    } else {
                                        break;
                                    }
                                }
                                if (filenameStartIndex !== -1) {
                                    const filename = innerContent.slice(filenameStartIndex).replace(/[<>\s]/g, '');
                                    if (filename) url = `https://files.catbox.moe/${filename}`;
                                }
                            }

                            if (!url) return '';
                            return `<img src="${url}" alt="" class="th-bqb-image"/>`;
                        });

                        const dmtRegex = /<dmt>([\s\S]*?)<\/dmt>/g;
                        processedText = processedText.replace(dmtRegex, (match, content) => {
                            const cardText = content.trim();
                            return `
                <div class="random-image-container" style="display: inline-block; position: relative; min-width: 9em; max-width: 11em; min-height: 9em; max-height: 11em; border: 2px solid transparent; border-radius: 15px; margin: 0 0 -6px 0; overflow-y: auto; box-shadow: 0 4px 8px rgba(255, 182, 193, 0.4); background-color: rgba(255, 255, 255, 0.8); backdrop-filter: blur(5px);" data-random-image>
                  <details style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: pointer;">
                    <summary style="list-style: none; width: 100%; height: 100%;"></summary>
                    <div style="position: absolute; top: 2px; left: 2px; right: 2px; background: linear-gradient(135deg, rgba(255, 192, 203, 0.4), rgba(255, 182, 193, 0.4)); color: #333333; padding: 2px; border-radius: 12px; text-align: center; z-index: 0; box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.5);">
                      <div style="border: 1px solid rgba(255, 192, 203, 0.3); width: calc(100% - 3px); text-align: center; word-wrap: break-word; border-radius: 10px; background: rgba(255, 255, 255, 0.98); box-shadow: inset 0 0 8px rgba(255, 192, 203, 0.2);">
                        <p style="margin: 0; font-size: 11px; text-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);">${cardText}</p>
                      </div>
                    </div>
                  </details>
                </div>
                            `;
                        });

                        const voiceRegex = /<voice>([\s\S]*?)<\/voice>/gi;
                        processedText = processedText.replace(voiceRegex, (_, inner) => {
                            const parts = (inner || '').split('*');
                            const duration = parts[0] ? parts[0].trim() : '';
                            const content = parts[1] ? parts[1].trim() : '';
                            return `
                <div class="th-voice-container" style="margin: 4px 0;">
                  <div class="th-voice-bar" style="display: flex; align-items: center; padding: 8px 12px; background-color: #f5f5f5; border-radius: 16px;">
                    <div class="th-voice-progress" style="flex-grow: 1; height: 6px; background-color: #ddd; border-radius: 3px; position: relative; margin-right: 8px;">
                      <div style="position: absolute; top: 0; left: 0; bottom: 0; background-color: #3b82f6; width: 40%; border-radius: 3px;"></div>
                    </div>
                    <span class="th-voice-duration" style="font-size: 12px; color: #555; margin-right: 8px;">${duration}</span>
                    <button class="th-voice-toggle" style="font-size: 12px; background: #eee; border: none; border-radius: 4px; padding: 2px 4px; cursor: pointer;">转</button>
                  </div>
                  <div class="th-voice-text" style="display: none; margin-top: 4px; font-size: 12px; color: #333;">${content}</div>
                </div>
                    `;
                        });

                        return processedText;
                    },
                    applyRandomImages() {
                        const containers = document.querySelectorAll('[data-random-image]');
                        if (containers.length === 0) return;

                        const images = [
                            'https://files.catbox.moe/0g3kqu.jpg', 'https://files.catbox.moe/d5b7k6.jpg', 'https://files.catbox.moe/0yrhh6.jpg',
                            'https://files.catbox.moe/8mjvdg.jpg', 'https://files.catbox.moe/fvidas.jpg', 'https://files.catbox.moe/q6so2i.jpg',
                            'https://files.catbox.moe/5a96cp.jpg', 'https://files.catbox.moe/0mp6h0.jpg', 'https://files.catbox.moe/epcn03.jpg',
                            'https://files.catbox.moe/7jzdp7.jpg', 'https://files.catbox.moe/jrmu6w.jpg', 'https://files.catbox.moe/c0bwhn.jpg',
                            'https://files.catbox.moe/0blxme.jpg', 'https://files.catbox.moe/qicobr.jpg', 'https://files.catbox.moe/n94ztu.jpg'
                        ];

                        containers.forEach(container => {
                            const randomImage = images[Math.floor(Math.random() * images.length)];
                            container.style.background = `url('${randomImage}') center/cover`;
                            container.style.backdropFilter = 'none';
                        });
                    },
                    renderChatView(viewIndex) {
                        const core = RMPhone.core.state;
                        const qq = RMPhone.app.qq;
                        if (viewIndex === -1) {
                            const placeholder = core.pendingOpenContact || { type: '私聊', name: '' };
                            qq.elements.chatMessagesContainer.innerHTML = '';
                            qq.elements.chatTitle.textContent = placeholder.name || '新聊天';
                            const bgKey = `${placeholder.type}.${placeholder.name}.背景图片`;
                            const bgUrl = core.settings.backgrounds?.[bgKey];
                            qq.elements.chatView.style.backgroundColor = '';
                            if (bgUrl && bgUrl.trim()) qq.elements.chatView.style.backgroundImage = `url('${bgUrl}')`;
                            else qq.elements.chatView.style.backgroundImage = '';
                            return;
                        }

                        if (!core.availableViews[viewIndex]) {
                            qq.elements.chatMessagesContainer.innerHTML = '';
                            qq.elements.chatTitle.textContent = '聊天';
                            qq.elements.chatView.style.backgroundImage = '';
                            qq.elements.chatView.style.backgroundColor = '';
                            return;
                        }

                        const view = core.availableViews[viewIndex];
                        const bgKey = `${view.type}.${view.name}.背景图片`;
                        const bgUrl = core.settings.backgrounds?.[bgKey];
                        qq.elements.chatView.style.backgroundColor = '';
                        if (bgUrl && bgUrl.trim()) {
                            qq.elements.chatView.style.backgroundImage = `url('${bgUrl}')`;
                            qq.elements.chatView.style.backgroundSize = 'cover';
                            qq.elements.chatView.style.backgroundPosition = 'center';
                            qq.elements.chatView.style.backgroundRepeat = 'no-repeat';
                        } else {
                            qq.elements.chatView.style.backgroundImage = '';
                        }
                        qq.elements.chatTitle.textContent = view.name;
                        const messages = view.content.match(/\[[^\[\]]+\]/g) || [];
                        qq.elements.chatMessagesContainer.innerHTML = '';
                        messages.forEach((line, index) => {
                            line = line.trim();
                            const parts = line.substring(1, line.length - 1).split('|');
                            let el;
                            if (line.startsWith('[我方消息|')) {
                                const messageText = this.processMessageContent(parts[1] || '');
                                const timeText = parts[2] || '';
                                el = document.createElement('div');
                                el.className = 'message sent';
                                el.dataset.messageIndex = index;
                                el.innerHTML = `<div class="content-col"><div class="bubble">${messageText}</div><div class="time">${timeText}</div></div><div class="avatar" style="background-image:url('${core.userAvatarUrl}')"></div>`;
                            } else {
                                if (parts.length >= 4) {
                                    const charName = parts[0].replace(/消息$/, '');
                                    let avatarUrl = parts[1];

                                    const contactSettings = core.settings.contactSpecificSettings?.[view.key] || {};
                                    if (contactSettings.useContactAvatar) {
                                        avatarUrl = view.avatar;
                                    } else if (avatarUrl && !avatarUrl.startsWith('http')) {
                                        avatarUrl = 'https://files.catbox.moe/' + avatarUrl;
                                    }

                                    const messageText = this.processMessageContent(parts[2]);
                                    el = document.createElement('div');
                                    el.className = 'message received';
                                    el.dataset.messageIndex = index;
                                    const showName = (view.type === '群聊');
                                    const timeText = parts[3] ? `${parts[3]}` : '';
                                    const nameHtml = showName ? `<div class="name">${charName}</div>` : '';
                                    el.innerHTML = `<div class="avatar" style="background-image:url('${avatarUrl}')" data-name="${charName}"></div><div class="content-col">${nameHtml}<div class="bubble">${messageText}</div><div class="time">${timeText}</div></div>`;
                                }
                            }
                            if (el) qq.elements.chatMessagesContainer.appendChild(el);
                        });
                        qq.elements.chatMessagesContainer.scrollTop = qq.elements.chatMessagesContainer.scrollHeight;
                        this.applyRandomImages();
                    },
                    async handleSendMessage() {
                        const qq = RMPhone.app.qq;
                        const core = RMPhone.core;
                        const text = qq.elements.messageInput.value.trim();
                        if (!text) return;
                        let currentView = core.state.availableViews[core.state.currentViewIndex];
                        if (!currentView && core.state.pendingOpenContact) {
                            const contact = core.state.pendingOpenContact;
                            const openTag = contact.type === '群聊' ? `[${contact.name}群聊内容]` : `[和${contact.name}私聊内容]`;
                            const closeTag = contact.type === '群聊' ? `[/${contact.name}群聊内容]` : `[/和${contact.name}私聊内容]`;
                            const nowTime = '';
                            const firstLine = `[我方消息|${text}|${nowTime}|pending]`;
                            const block = `\n${openTag}\n${firstLine}\n${closeTag}`;
                            core.state.chatData += block;
                            await core.updateTavernFloor();
                            core.parseAllViews();
                            core.state.currentViewIndex = core.state.availableViews.findIndex(v => v.name === contact.name && v.type === contact.type);
                            currentView = core.state.availableViews[core.state.currentViewIndex];
                            core.state.pendingOpenContact = null;
                            this.renderChatView(core.state.currentViewIndex);
                            qq.elements.messageInput.value = '';
                            qq.elements.messageInput.focus();
                            return;
                        }

                        if (!currentView) {
                            core.parseAllViews();
                            currentView = core.state.availableViews[core.state.currentViewIndex];
                        }
                        if (!currentView) return;
                        let lastOpponentTime = '';
                        if (currentView && currentView.content) {
                            const msgs = currentView.content.match(/\[[^\[\]]+\]/g) || [];
                            for (let i = msgs.length - 1; i >= 0; i--) {
                                const line = msgs[i];
                                if (!line.startsWith('[我方消息|')) {
                                    const parts = line.substring(1, line.length - 1).split('|');
                                    if (parts.length >= 4 && parts[3]) {
                                        lastOpponentTime = parts[3];
                                        break;
                                    }
                                }
                            }
                        }
                        const newLine = `[我方消息|${text}|${lastOpponentTime}|pending]`;
                        let newContent;
                        let newRawBlock;
                        if (!currentView || !currentView.id) {
                            const contact = (function() {
                                return { type: '私聊', name: qq.elements.chatTitle.textContent || '未命名' };
                            })();
                            const openBlockTag = contact.type === '群聊' ? `[${contact.name}群聊内容]` : `[和${contact.name}私聊内容]`;
                            const closeBlockTag = contact.type === '群聊' ? `[/${contact.name}群聊内容]` : `[/和${contact.name}私聊内容]`;
                            newContent = newLine;
                            const newBlock = `\n${openBlockTag}\n${newContent}\n${closeBlockTag}`;
                            core.state.chatData += newBlock;
                            await core.updateTavernFloor();
                            core.parseAllViews();
                            core.state.currentViewIndex = core.state.availableViews.findIndex(v => v.name === contact.name && v.type === contact.type);
                            currentView = core.state.availableViews[core.state.currentViewIndex];
                            newRawBlock = currentView.rawBlock;
                        } else {
                            newContent = `${currentView.content}\n${newLine}`.trim();
                            newRawBlock = `${currentView.id}\n${newContent}\n[/${currentView.id.substring(1)}`;
                            core.state.chatData = core.state.chatData.replace(currentView.rawBlock, newRawBlock);
                            currentView.content = newContent;
                            currentView.rawBlock = newRawBlock;
                        }
                        this.renderChatView(core.state.currentViewIndex);
                        qq.elements.messageInput.value = '';
                        qq.elements.messageInput.focus();
                        await core.updateTavernFloor();
                    },
                    async handleGenerate() {
                        const core = RMPhone.core;
                        let allPendingBlocks = [];
                        for (const view of core.state.availableViews) {
                            let pendingRegex = /\[我方消息\|.*?\|.*?\|pending\]/g;
                            let pendingMessages = view.content.match(pendingRegex);
                            if (!pendingMessages) {
                                let messages = view.content.split('\n').filter(line => line.trim() !== '');
                                let lastUserMessageIndices = [];
                                for (let i = messages.length - 1; i >= 0; i--) {
                                    if (messages[i].startsWith('[我方消息|') && !messages[i].includes('|pending]')) {
                                        lastUserMessageIndices.unshift(i);
                                    } else {
                                        break;
                                    }
                                }

                                if (lastUserMessageIndices.length > 0) {
                                    lastUserMessageIndices.forEach(index => {
                                        messages[index] = messages[index].replace(/\]$/, '|pending]');
                                    });
                                    const newContent = messages.join('\n');
                                    const newRawBlock = `${view.id}\n${newContent}\n[/${view.id.substring(1)}`;
                                    core.state.chatData = core.state.chatData.replace(view.rawBlock, newRawBlock);
                                    view.content = newContent;
                                    view.rawBlock = newRawBlock;
                                    pendingMessages = view.content.match(pendingRegex);
                                }
                            }

                            if (pendingMessages && pendingMessages.length > 0) {
                                const userInputForBlock = pendingMessages.map(msg => msg.replace(/\|pending\]/g, ']')).join('\n');
                                const block = `${view.id}\n${userInputForBlock}\n[/${view.id.substring(1)}`;
                                allPendingBlocks.push(block);
                            }
                        }

                        if (allPendingBlocks.length === 0) return;

                        let combinedUserInput = allPendingBlocks.join('\n');
                        const replyFormat = core.state.settings.replyFormat || 'same-level';
                        
                        const music = RMPhone.app.music;
                        if (core.state.settings.shareMusicStatus && music.isPlaying && music.playlist[music.currentSongIndex]) {
                            const song = music.playlist[music.currentSongIndex];
                            const listeningStatus = `\n{{user}}正在听${song.title}（${song.artist}）`;
                            combinedUserInput += listeningStatus;
                        }

                        if (replyFormat.startsWith('diff-level')) {
                            if (typeof triggerSlash !== 'function') return;
                            const escaped = combinedUserInput.replace(/\|/g, '\\|');
                            let cmd = `/send ${escaped}`;
                            if (replyFormat === 'diff-level-trigger') cmd += ' | /trigger';
                            triggerSlash(cmd);

                            core.state.availableViews.forEach(view => {
                                if (view.content.includes('|pending]')) {
                                    let newContent = view.content.replace(/\|pending\]/g, ']');
                                    const newRaw = `${view.id}\n${newContent.trim()}\n[/${view.id.substring(1)}`;
                                    core.state.chatData = core.state.chatData.replace(view.rawBlock, newRaw);
                                    view.content = newContent.trim();
                                    view.rawBlock = newRaw;
                                }
                            });
                            this.renderChatView(core.state.currentViewIndex);
                            await core.updateTavernFloor();
                            return;
                        }

                        try {
                            if (typeof generate !== 'function') throw new Error('generate not defined');
                            let result = await generate({ user_input: combinedUserInput });
                            if (!result || typeof result !== 'string') return;

                            const phoneMatch = result.match(/<phone>([\s\S]*)<\/phone>/);
                            if (phoneMatch) result = phoneMatch[1];

                            const viewRegex = /\[(和(.+?)私聊内容|(.+?)群聊内容)\]([\s\S]*?)\[\/\1\]/g;
                            let match;
                            const newBlocks = [];
                            while ((match = viewRegex.exec(result)) !== null) {
                                newBlocks.push({
                                    fullTag: match[1],
                                    privateName: match[2],
                                    groupName: match[3],
                                    content: match[4].trim(),
                                    rawBlock: match[0]
                                });
                            }

                            core.state.availableViews.forEach(view => {
                                if (view.content.includes('|pending]')) {
                                    let updatedContent = view.content.replace(/\|pending\]/g, ']');
                                    const finalBlock = `${view.id}\n${updatedContent.trim()}\n[/${view.id.substring(1)}`;
                                    core.state.chatData = core.state.chatData.replace(view.rawBlock, finalBlock);
                                }
                            });

                            core.parseAllViews();

                            if (newBlocks.length === 0) {
                                const currentView = core.state.availableViews[core.state.currentViewIndex];
                                if (currentView) {
                                    const lineRegex = /\[[^\]]+?消息\|.*?\|.*?\|.*?\]/g;
                                    const extra = result.match(lineRegex);
                                    if (extra) {
                                        let newContent = currentView.content + '\n' + extra.join('\n');
                                        const newRaw = `${currentView.id}\n${newContent.trim()}\n[/${currentView.id.substring(1)}`;
                                        core.state.chatData = core.state.chatData.replace(currentView.rawBlock, newRaw);
                                    }
                                }
                            } else {
                                newBlocks.forEach(newBlockInfo => {
                                    const type = newBlockInfo.privateName ? '私聊' : '群聊';
                                    const name = newBlockInfo.privateName || newBlockInfo.groupName;
                                    const key = `${type}.${name}`;
                                    const existingView = core.state.availableViews.find(v => v.key === key);
                                    const currentOpenView = core.state.availableViews[core.state.currentViewIndex];

                                    if (!currentOpenView || currentOpenView.key !== key) {
                                        core.state.unreadStatus[key] = true;
                                    }

                                    if (existingView) {
                                        let updatedContent = existingView.content + `\n${newBlockInfo.content}`;
                                        const finalBlock = `${existingView.id}\n${updatedContent.trim()}\n[/${existingView.id.substring(1)}`;
                                        core.state.chatData = core.state.chatData.replace(existingView.rawBlock, finalBlock);
                                    } else {
                                        core.state.chatData += `\n${newBlockInfo.rawBlock}`;
                                    }
                                });
                            }

                            await core.parseAllViews();
                            RMPhone.app.qq.populateContacts();
                            this.renderChatView(core.state.currentViewIndex);
                            RMPhone.ui.updateUnreadIndicators();
                            await core.saveSettings();
                            await core.updateTavernFloor();

                        } catch (e) {
                            console.error('An error occurred during generate and sync:', e);
                        }
                    },
                    openActionMenu(messageElement, index) {
                        const menu = document.createElement('div');
                        menu.className = 'message-actions';
                        menu.innerHTML = `<button class="action-btn edit">编辑</button><button class="action-btn delete">删除</button>`;
                        const bubble = messageElement.querySelector('.bubble');
                        bubble.insertAdjacentElement('afterend', menu);
                        menu.querySelector('.delete').addEventListener('click', async (ev) => {
                            ev.stopPropagation();
                            await this.deleteMessage(index);
                        });
                        menu.querySelector('.edit').addEventListener('click', (ev) => {
                            ev.stopPropagation();
                            this.editMessage(index, messageElement);
                        });
                        setTimeout(() => document.addEventListener('click', () => menu.remove(), { once: true }), 0);
                    },
                    async deleteMessage(index) {
                        const core = RMPhone.core;
                        const currentView = core.state.availableViews[core.state.currentViewIndex];
                        if (!currentView) return;
                        let msgs = currentView.content.match(/\[[^\[\]]+\]/g) || [];
                        msgs.splice(index, 1);
                        const newContent = msgs.join('\n');
                        const newRaw = `${currentView.id}\n${newContent}\n[/${currentView.id.substring(1)}`;
                        core.state.chatData = core.state.chatData.replace(currentView.rawBlock, newRaw);
                        currentView.content = newContent;
                        currentView.rawBlock = newRaw;
                        this.renderChatView(core.state.currentViewIndex);
                        await core.updateTavernFloor();
                    },
                    editMessage(index, messageElement) {
                        const core = RMPhone.core;
                        const currentView = core.state.availableViews[core.state.currentViewIndex];
                        const msgs = currentView.content.match(/\[[^\[\]]+\]/g) || [];
                        const original = msgs[index];
                        const parts = original.substring(1, original.length - 1).split('|');
                        const isSent = original.startsWith('[我方消息|');
                        const originalText = isSent ? parts[1] : parts[2];
                        const bubble = messageElement.querySelector('.bubble');
                        bubble.innerHTML = `<div class="message-edit-container"><textarea class="message-edit-textarea">${originalText}</textarea><div class="edit-actions"><button class="action-btn edit save-edit-btn">保存</button><button class="action-btn delete cancel-edit-btn">取消</button></div></div>`;
                        const textarea = bubble.querySelector('.message-edit-textarea');
                        textarea.focus();
                        textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
                        bubble.querySelector('.save-edit-btn').addEventListener('click', async () => { await this.saveEditedMessage(index, textarea.value); });
                        bubble.querySelector('.cancel-edit-btn').addEventListener('click', () => this.renderChatView(core.state.currentViewIndex));
                    },
                    async saveEditedMessage(index, newText) {
                        const core = RMPhone.core;
                        const currentView = core.state.availableViews[core.state.currentViewIndex];
                        let msgs = currentView.content.match(/\[[^\[\]]+\]/g) || [];
                        let line = msgs[index];
                        let parts = line.substring(1, line.length - 1).split('|');
                        if (line.startsWith('[我方消息|')) parts[1] = newText;
                        else parts[2] = newText;
                        msgs[index] = `[${parts.join('|')}]`;
                        const newContent = msgs.join('\n');
                        const newRaw = `${currentView.id}\n${newContent}\n[/${currentView.id.substring(1)}`;
                        core.state.chatData = core.state.chatData.replace(currentView.rawBlock, newRaw);
                        currentView.content = newContent;
                        currentView.rawBlock = newRaw;
                        this.renderChatView(core.state.currentViewIndex);
                        await core.updateTavernFloor();
                    }
                },
                populateContacts() {
                    const core = RMPhone.core;
                    this.elements.contactsList.innerHTML = '';
                    let displayed = [...core.state.availableViews.map(v => ({ type: v.type, name: v.name, avatar: v.avatar, id: v.id, key: `${v.type}.${v.name}` }))];
                    const existingKeys = new Set(displayed.map(v => v.key));

                    for (const key in core.state.chatAvatars) {
                        if (Object.hasOwn(core.state.chatAvatars, key) && !existingKeys.has(key)) {
                            const [type, name] = key.split('.');
                            if (name) displayed.push({ type, name, avatar: core.state.chatAvatars[key], isPlaceholder: true, key });
                        }
                    }

                    if (core.state.settings.contactOrder && Array.isArray(core.state.settings.contactOrder)) {
                        displayed.sort((a, b) => {
                            const indexA = core.state.settings.contactOrder.indexOf(a.key);
                            const indexB = core.state.settings.contactOrder.indexOf(b.key);
                            if (indexA === -1 && indexB === -1) return 0;
                            if (indexA === -1) return 1;
                            if (indexB === -1) return -1;
                            return indexA - indexB;
                        });
                    }

                    if (displayed.length === 0) {
                        this.elements.contactsList.innerHTML = '<div style="color:#888; text-align:center; padding:1.5em; font-size:1.4em;">暂无联系人</div>';
                        return;
                    }

                    displayed.forEach((view) => {
                        const item = document.createElement('div');
                        item.className = 'contact-item';
                        const key = view.key;
                        item.dataset.key = key;
                        item.innerHTML = `
                            <div class="drag-handle"></div>
                            <div class="contact-avatar" style="background-image:url('${view.avatar}')"></div>
                            <div class="contact-name">${view.name}</div>
                            <div class="contact-type">${view.type || ''}</div>
                            <span class="unread-dot hidden">1</span>
                            <button class="delete-contact-btn">&times;</button>
                        `;

                        const contactAvatarEl = item.querySelector('.contact-avatar');
                        const deleteBtn = item.querySelector('.delete-contact-btn');

                        item.addEventListener('click', async (event) => {
                            if (this.isContactEditMode) {
                                if (contactAvatarEl && event.target === contactAvatarEl) {
                                    RMPhone.ui.showUrlEditModal(`修改 ${view.name} 的头像`, view.avatar, async (newUrl) => {
                                        if (newUrl) {
                                            core.state.chatAvatars[key] = newUrl;
                                            await core.saveSettings();
                                            this.populateContacts();
                                        }
                                    });
                                }
                                return;
                            }

                            if (core.state.unreadStatus[key]) {
                                delete core.state.unreadStatus[key];
                                RMPhone.ui.updateUnreadIndicators();
                                core.saveSettings();
                            }

                            core.state.currentViewIndex = core.state.availableViews.findIndex(v => v.name === view.name && v.type === (view.type || '私聊'));
                            if (core.state.currentViewIndex === -1) {
                                core.state.pendingOpenContact = { type: view.type || '私聊', name: view.name, avatar: view.avatar };
                            }
                            if (core.state.currentViewIndex === -1) {
                                RMPhone.ui.openView(this.elements.chatView);
                                this.chat.renderChatView(-1);
                            } else {
                                RMPhone.ui.openView(this.elements.chatView);
                                this.chat.renderChatView(core.state.currentViewIndex);
                            }
                        });

                        let pressTimer = null;
                        const pressDuration = 500;
                        const startPress = (e) => {
                            if (this.isContactEditMode) return;
                            pressTimer = setTimeout(() => {
                                this.contact.enterContactEditMode();
                            }, pressDuration);
                        };
                        const cancelPress = () => { if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; } };
                        item.addEventListener('mousedown', startPress);
                        item.addEventListener('touchstart', startPress);
                        ['mouseup', 'mouseleave', 'touchend', 'touchcancel', 'click'].forEach(evt => item.addEventListener(evt, cancelPress));

                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            if (!this.elements.deleteContactModal || !this.elements.deleteContactText) return;
                            this.elements.deleteContactText.textContent = `是否删除${view.type || ''} ${view.name}?`;
                            this.elements.deleteContactModal.classList.remove('hidden');

                            const onCancel = () => this.elements.deleteContactModal.classList.add('hidden');
                            const onConfirm = async () => {
                                await this.contact.deleteContact(view);
                                this.elements.deleteContactModal.classList.add('hidden');
                                this.populateContacts();
                            };

                            this.elements.deleteContactCancel.onclick = onCancel;
                            this.elements.deleteContactConfirm.onclick = onConfirm;
                        });

                        this.elements.contactsList.appendChild(item);
                    });

                    $(this.elements.contactsList).sortable({
                        axis: 'y',
                        handle: '.drag-handle',
                        disabled: !this.isContactEditMode,
                        stop: function() {
                            const newOrder = Array.from(RMPhone.app.qq.elements.contactsList.querySelectorAll('.contact-item')).map(item => item.dataset.key);
                            core.state.settings.contactOrder = newOrder;
                            core.saveSettings();
                        }
                    });
                    
                    RMPhone.ui.updateUnreadIndicators();
                }
            }
        }
    };
    RMPhone.init();
</script>
  </body>
</html>
